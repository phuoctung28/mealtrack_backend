This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src/**/*.py
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  api/
    builders/
      __init__.py
      chat_response_builder.py
    converters/
      meal_plan_converters.py
    dependencies/
      __init__.py
      auth.py
      event_bus.py
    mappers/
      __init__.py
      base_mapper.py
      daily_meal_mapper.py
      meal_mapper.py
      meal_suggestion_mapper.py
      tdee_mapper.py
    middleware/
      dev_auth_bypass.py
      premium_check.py
    routes/
      v1/
        chat/
          __init__.py
          message_routes.py
          thread_routes.py
        activities.py
        chat_ws.py
        daily_meals.py
        feature_flags.py
        foods.py
        health.py
        ingredients.py
        meal_plans.py
        meal_suggestions.py
        meals.py
        monitoring.py
        notifications.py
        user_profiles.py
        users.py
        webhooks.py
    schemas/
      common/
        __init__.py
        auth_enums.py
        meal_plan_enums.py
        meal_type_enum.py
      request/
        __init__.py
        chat_requests.py
        daily_meal_requests.py
        feature_flag_requests.py
        ingredient_based_meal_plan_requests.py
        ingredient_recognition_requests.py
        meal_plan_requests.py
        meal_requests.py
        meal_suggestion_requests.py
        notification_requests.py
        onboarding_requests.py
        tdee_requests.py
        user_profile_update_requests.py
        user_requests.py
      response/
        __init__.py
        activity_responses.py
        chat_responses.py
        daily_meal_responses.py
        daily_nutrition_response.py
        feature_flag_responses.py
        ingredient_recognition_responses.py
        meal_plan_responses.py
        meal_responses.py
        meal_suggestion_responses.py
        notification_responses.py
        onboarding_responses.py
        tdee_responses.py
        user_responses.py
        weekly_meal_plan_responses.py
      __init__.py
    utils/
      __init__.py
      file_validation.py
      file_validator.py
    base_dependencies.py
    exceptions.py
    main.py
  app/
    commands/
      chat/
        __init__.py
        create_thread_command.py
        delete_thread_command.py
        send_message_command.py
      daily_meal/
        __init__.py
        generate_daily_meal_suggestions_command.py
        generate_single_meal_command.py
      ingredient/
        __init__.py
        recognize_ingredient_command.py
      meal/
        __init__.py
        create_manual_meal_command.py
        delete_meal_command.py
        edit_meal_command.py
        upload_meal_image_immediately_command.py
      meal_plan/
        __init__.py
        generate_weekly_ingredient_based_meal_plan_command.py
      meal_suggestion/
        __init__.py
        accept_suggestion_command.py
        discard_session_command.py
        generate_meal_suggestions_command.py
        regenerate_suggestions_command.py
        reject_suggestion_command.py
        save_meal_suggestion_command.py
      notification/
        __init__.py
        delete_fcm_token_command.py
        register_fcm_token_command.py
        update_notification_preferences_command.py
      user/
        __init__.py
        complete_onboarding_command.py
        delete_user_command.py
        save_user_onboarding_command.py
        sync_user_command.py
        update_user_metrics_command.py
      __init__.py
    events/
      daily_meal/
        __init__.py
        daily_meals_generated_event.py
      meal/
        __init__.py
        meal_analysis_started_event.py
        meal_edited_event.py
        meal_image_uploaded_event.py
        meal_nutrition_updated_event.py
      meal_plan/
        __init__.py
        conversation_started_event.py
        meal_plan_generated_event.py
        meal_replaced_event.py
      tdee/
        __init__.py
        tdee_calculated_event.py
      user/
        __init__.py
        user_onboarded_event.py
        user_profile_updated_event.py
      __init__.py
      base.py
      chat_events.py
    handlers/
      command_handlers/
        chat/
          __init__.py
          create_thread_command_handler.py
          delete_thread_command_handler.py
          send_message_command_handler.py
        __init__.py
        accept_suggestion_handler.py
        add_custom_ingredient_command_handler.py
        complete_onboarding_command_handler.py
        create_manual_meal_command_handler.py
        delete_fcm_token_command_handler.py
        delete_meal_command_handler.py
        delete_user_command_handler.py
        discard_session_handler.py
        edit_meal_command_handler.py
        generate_daily_meal_suggestions_command_handler.py
        generate_meal_suggestions_command_handler.py
        generate_single_meal_command_handler.py
        get_session_suggestions_handler.py
        recognize_ingredient_command_handler.py
        regenerate_suggestions_handler.py
        register_fcm_token_command_handler.py
        reject_suggestion_handler.py
        save_meal_suggestion_command_handler.py
        save_user_onboarding_command_handler.py
        sync_user_command_handler.py
        update_notification_preferences_command_handler.py
        update_user_last_accessed_command_handler.py
        update_user_metrics_command_handler.py
        upload_meal_image_immediately_command_handler.py
        weekly_ingredient_based_meal_plan_command_handler.py
      event_handlers/
        __init__.py
        meal_analysis_event_handler.py
      query_handlers/
        chat/
          __init__.py
          get_messages_query_handler.py
          get_thread_query_handler.py
          get_threads_query_handler.py
        __init__.py
        get_daily_activities_query_handler.py
        get_daily_macros_query_handler.py
        get_food_details_query_handler.py
        get_meal_by_id_query_handler.py
        get_meal_plan_query_handler.py
        get_meal_planning_summary_query_handler.py
        get_meal_suggestions_for_profile_query_handler.py
        get_meals_by_date_query_handler.py
        get_meals_from_plan_by_date_query_handler.py
        get_notification_preferences_query_handler.py
        get_single_meal_for_profile_query_handler.py
        get_user_by_firebase_uid_query_handler.py
        get_user_metrics_query_handler.py
        get_user_onboarding_status_query_handler.py
        get_user_profile_query_handler.py
        get_user_tdee_query_handler.py
        search_foods_query_handler.py
      __init__.py
    queries/
      activity/
        __init__.py
        get_daily_activities_query.py
      chat/
        __init__.py
        get_messages_query.py
        get_thread_query.py
        get_threads_query.py
      daily_meal/
        __init__.py
        get_meal_planning_summary_query.py
        get_meal_suggestions_for_profile_query.py
        get_single_meal_for_profile_query.py
      food/
        get_food_details_query.py
        search_foods_query.py
      meal/
        __init__.py
        get_daily_macros_query.py
        get_meal_by_id_query.py
      meal_plan/
        __init__.py
        get_meal_plan_query.py
        get_meals_by_date_query.py
        get_meals_from_plan_by_date_query.py
      meal_suggestion/
        __init__.py
        get_session_suggestions_query.py
      notification/
        __init__.py
        get_notification_preferences_query.py
      tdee/
        __init__.py
        get_user_tdee_query.py
      user/
        __init__.py
        get_user_by_firebase_uid_query.py
        get_user_metrics_query.py
        get_user_onboarding_status_query.py
        get_user_profile_query.py
      __init__.py
    services/
      chat/
        __init__.py
        ai_response_coordinator.py
        chat_notification_service.py
        message_orchestration_service.py
      __init__.py
    __init__.py
  domain/
    constants/
      __init__.py
      meal_constants.py
    mappers/
      activity_goal_mapper.py
    model/
      ai/
        __init__.py
        gpt_response_errors.py
        gpt_response.py
      chat/
        __init__.py
        chat_enums.py
        message.py
        thread.py
      conversation/
        __init__.py
        conversation.py
        meal_query_response.py
        prompt_context.py
      meal/
        __init__.py
        ingredient.py
        meal_image.py
        meal.py
      meal_planning/
        __init__.py
        macro_targets.py
        meal_generation_request.py
        meal_generation_response.py
        meal_plan.py
        meal_suggestion.py
        suggestion_session.py
      meal_suggestion/
        __init__.py
        meal_suggestion.py
        portion_target.py
        suggestion_session.py
      notification/
        __init__.py
        enums.py
        notification_preferences.py
        push_notification.py
        user_fcm_token.py
      nutrition/
        __init__.py
        food.py
        macros.py
        micros.py
        nutrition.py
      user/
        __init__.py
        activity.py
        onboarding.py
        tdee.py
        user_macros.py
      __init__.py
    parsers/
      __init__.py
      gpt_response_parser.py
    ports/
      __init__.py
      ai_chat_service_port.py
      chat_repository_port.py
      food_cache_service_port.py
      food_data_service_port.py
      food_mapping_service_port.py
      image_store_port.py
      meal_generation_service_port.py
      meal_plan_repository_port.py
      meal_repository_port.py
      meal_suggestion_repository_port.py
      notification_repository_port.py
      subscription_repository_port.py
      user_repository_port.py
      vision_ai_service_port.py
    prompts/
      daily_meal_plan_prompt.py
      meal_suggestion_prompt.py
      unified_meal_plan_prompt.py
      weekly_meal_plan_prompt.py
    schemas/
      meal_generation_schemas.py
    services/
      conversation/
        __init__.py
        conversation_formatter.py
        conversation_handler.py
        conversation_parser.py
      meal_plan/
        __init__.py
        meal_plan_formatter.py
        meal_plan_generator.py
        meal_plan_validator.py
        request_builder.py
      meal_suggestion/
        __init__.py
        json_extractor.py
        recipe_search_service.py
        suggestion_fallback_provider.py
        suggestion_orchestration_service.py
        suggestion_prompt_builder.py
      __init__.py
      bmr_calculator.py
      conversation_service.py
      daily_meal_suggestion_service.py
      fallback_meal_service.py
      food_mapping_service.py
      ingredient_based_meal_plan_service.py
      meal_distribution_service.py
      meal_plan_conversation_service.py
      meal_plan_orchestration_service.py
      meal_plan_persistence_service.py
      meal_plan_service.py
      meal_service.py
      meal_suggestion_service.py
      meal_type_determination_service.py
      notification_service.py
      nutrition_calculation_service.py
      portion_calculation_service.py
      prompt_generation_service.py
      revenuecat_service.py
      tdee_service.py
      timezone_utils.py
      user_profile_service.py
      weekly_ingredient_based_meal_plan_service.py
    strategies/
      __init__.py
      meal_analysis_strategy.py
      meal_edit_strategies.py
  infra/
    adapters/
      cloudinary_image_store.py
      food_cache_service.py
      food_data_service.py
      image_store.py
      meal_generation_service.py
      mock_image_store.py
      mock_meal_suggestion_service.py
      vision_ai_service.py
    cache/
      __init__.py
      cache_keys.py
      cache_service.py
      decorators.py
      metrics.py
      redis_client.py
    config/
      settings.py
    database/
      models/
        chat/
          __init__.py
          message.py
          thread.py
        conversation/
          __init__.py
          conversation.py
          message.py
        meal/
          __init__.py
          meal_image.py
          meal.py
        meal_planning/
          __init__.py
          meal_plan_day.py
          meal_plan.py
          planned_meal.py
        notification/
          __init__.py
          notification_preferences.py
          user_fcm_token.py
        nutrition/
          __init__.py
          food_item.py
          nutrition.py
        user/
          __init__.py
          profile.py
          user.py
        __init__.py
        base.py
        enums.py
        feature_flag.py
        subscription.py
      config.py
      migration_manager.py
      uow.py
    event_bus/
      __init__.py
      event_bus.py
      pymediator_event_bus.py
    mappers/
      __init__.py
      status_mapper.py
    repositories/
      notification/
        __init__.py
        fcm_token_operations.py
        notification_preferences_operations.py
        reminder_query_builder.py
      base.py
      chat_repository.py
      meal_plan_repository.py
      meal_repository.py
      meal_suggestion_repository.py
      notification_repository.py
      subscription_repository.py
      user_repository.py
    services/
      ai/
        parsers/
          __init__.py
          ai_response_parser.py
        prompts/
          __init__.py
          system_prompts.py
        __init__.py
        gemini_chat_service.py
        llm_provider_factory.py
        openai_chat_service.py
      firebase_auth_service.py
      firebase_service.py
      pinecone_service.py
      scheduled_notification_service.py
    websocket/
      __init__.py
      connection_manager.py
  __init__.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/api/mappers/__init__.py">
"""
API Mappers for converting between domain models and API DTOs.

This module provides mapping functions to convert between:
- Domain models (business layer)
- API request/response DTOs (presentation layer)

Following clean architecture principles, mappers ensure proper
separation between layers and consistent data transformation.
"""

from .base_mapper import BaseMapper
from .daily_meal_mapper import DailyMealMapper
from .meal_mapper import MealMapper
from .tdee_mapper import TdeeMapper

__all__ = [
    'BaseMapper',
    'DailyMealMapper', 
    'TdeeMapper',
    'MealMapper'
]
</file>

<file path="src/api/mappers/base_mapper.py">
"""
Base mapper class for API data transformation.
"""
from abc import ABC, abstractmethod
from typing import TypeVar, Generic, List

# Type variables for domain and DTO types
DomainModel = TypeVar('DomainModel')
RequestDTO = TypeVar('RequestDTO')
ResponseDTO = TypeVar('ResponseDTO')


class BaseMapper(ABC, Generic[DomainModel, RequestDTO, ResponseDTO]):
    """
    Abstract base class for mappers that convert between domain models and DTOs.
    
    Provides a consistent interface for data transformation between layers:
    - Request DTO → Domain Model (for incoming requests)
    - Domain Model → Response DTO (for outgoing responses)
    """
    
    @abstractmethod
    def to_domain(self, dto: RequestDTO) -> DomainModel:
        """
        Convert a request DTO to a domain model.
        
        Args:
            dto: The request DTO to convert
            
        Returns:
            The corresponding domain model
        """
        pass
    
    @abstractmethod
    def to_response_dto(self, domain: DomainModel) -> ResponseDTO:
        """
        Convert a domain model to a response DTO.
        
        Args:
            domain: The domain model to convert
            
        Returns:
            The corresponding response DTO
        """
        pass
    
    def to_domain_list(self, dtos: List[RequestDTO]) -> List[DomainModel]:
        """
        Convert a list of request DTOs to domain models.
        
        Args:
            dtos: List of request DTOs
            
        Returns:
            List of domain models
        """
        return [self.to_domain(dto) for dto in dtos]
    
    def to_response_dto_list(self, domains: List[DomainModel]) -> List[ResponseDTO]:
        """
        Convert a list of domain models to response DTOs.
        
        Args:
            domains: List of domain models
            
        Returns:
            List of response DTOs
        """
        return [self.to_response_dto(domain) for domain in domains]
</file>

<file path="src/api/routes/v1/daily_meals.py">
"""
Daily meal suggestions API endpoints - Event-driven architecture.
"""
from typing import Optional

from fastapi import APIRouter, Depends

from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.mappers.daily_meal_mapper import DailyMealMapper
from src.api.schemas.request import UserPreferencesRequest, MealTypeEnum
from src.api.schemas.response import (
    DailyMealSuggestionsResponse,
    SingleMealSuggestionResponse
)
from src.app.commands.daily_meal import (
    GenerateDailyMealSuggestionsCommand,
    GenerateSingleMealCommand
)
from src.app.queries.daily_meal import (
    GetMealSuggestionsForProfileQuery,
    GetSingleMealForProfileQuery,
    GetMealPlanningSummaryQuery
)
from src.infra.event_bus import EventBus

router = APIRouter(prefix="/v1/daily-meals", tags=["Daily Meal Suggestions"])


@router.post("/suggestions", response_model=DailyMealSuggestionsResponse)
async def get_daily_meal_suggestions(
    request: Optional[UserPreferencesRequest] = None,
    user_profile_id: Optional[str] = None,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get 3-5 meal suggestions for a day in a single request.
    
    This endpoint generates all daily meals (breakfast, lunch, dinner, snack) 
    in one unified API call, ensuring better meal coordination and variety.
    
    Two modes supported:
    1. Profile-based (preferred): Provide user_profile_id
    2. Direct preferences: Provide full UserPreferencesRequest
    
    Profile-based suggestions use stored user data including:
    - User profile (age, gender, height, weight)
    - Preferences (dietary, health conditions, allergies)
    - Goals (activity level, fitness goal)
    - Calculated TDEE and macros
    """
    try:
        if user_profile_id:
            # Use profile-based query (preferred v2 approach)
            query = GetMealSuggestionsForProfileQuery(user_profile_id=user_profile_id)
            result = await event_bus.send(query)
        elif request:
            # Use direct command (legacy v1 approach)
            command = GenerateDailyMealSuggestionsCommand(
                age=request.age,
                gender=request.gender,
                height=request.height,
                weight=request.weight,
                activity_level=request.activity_level,
                goal=request.goal,
                dietary_preferences=request.dietary_preferences,
                health_conditions=request.health_conditions,
                target_calories=request.target_calories,
                target_macros=request.target_macros.dict() if request.target_macros else None
            )
            result = await event_bus.send(command)
        else:
            raise ValueError("Either user_profile_id or request data must be provided")
        
        # Use mapper to convert to response
        return DailyMealMapper.map_to_suggestions_response(result)
        
    except Exception as e:
        raise handle_exception(e)


@router.post("/suggestions/{meal_type}", response_model=SingleMealSuggestionResponse)
async def get_single_meal_suggestion(
    meal_type: MealTypeEnum,
    request: Optional[UserPreferencesRequest] = None,
    user_profile_id: Optional[str] = None,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get a single meal suggestion for a specific meal type.
    
    Meal types: breakfast, lunch, dinner, snack
    
    Two modes supported:
    1. Profile-based (preferred): Provide user_profile_id
    2. Direct preferences: Provide full UserPreferencesRequest
    """
    try:
        if user_profile_id:
            # Use profile-based query (preferred v2 approach)
            query = GetSingleMealForProfileQuery(
                user_profile_id=user_profile_id,
                meal_type=meal_type.value
            )
            result = await event_bus.send(query)
            # Direct response for profile-based query
            return SingleMealSuggestionResponse(meal=result["meal"])
        elif request:
            # Use direct command (legacy v1 approach)
            command = GenerateSingleMealCommand(
                meal_type=meal_type.value,
                age=request.age,
                gender=request.gender,
                height=request.height,
                weight=request.weight,
                activity_level=request.activity_level,
                goal=request.goal,
                dietary_preferences=request.dietary_preferences,
                health_conditions=request.health_conditions,
                target_calories=request.target_calories,
                target_macros=request.target_macros.dict() if request.target_macros else None
            )
            result = await event_bus.send(command)
            # Use mapper for command-based response
            mapped_result = DailyMealMapper.map_to_single_meal_response(result)
            return SingleMealSuggestionResponse(**mapped_result)
        else:
            raise ValueError("Either user_profile_id or request data must be provided")
        
    except Exception as e:
        raise handle_exception(e)


@router.get("/profile/{user_profile_id}/summary")
async def get_meal_planning_summary(
    user_profile_id: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get meal planning data summary for a user profile.
    
    Returns user profile data, preferences, and calculated targets.
    Useful for debugging and verifying meal planning inputs.
    """
    try:
        # Create query
        query = GetMealPlanningSummaryQuery(user_profile_id=user_profile_id)
        
        # Send query
        result = await event_bus.send(query)
        
        return result
        
    except Exception as e:
        raise handle_exception(e)


@router.get("/health")
async def daily_meals_health():
    """Check if daily meal suggestions service is healthy."""
    return {
        "status": "healthy",
        "service": "daily_meal_suggestions",
        "features": [
            "personalized_daily_suggestions",
            "single_meal_generation",
            "profile_based_suggestions",
            "direct_preferences_support",
            "onboarding_integration",
            "macro_calculation"
        ]
    }
</file>

<file path="src/api/schemas/common/__init__.py">
# Common enums and shared schemas
</file>

<file path="src/api/schemas/common/auth_enums.py">
"""
Authentication-related enums for API schemas.
"""
from enum import Enum


class AuthProviderEnum(str, Enum):
    """Authentication provider enumeration."""
    GOOGLE = "google"
    APPLE = "apple"
    
    @classmethod
    def from_string(cls, value: str) -> 'AuthProviderEnum':
        """Convert string to AuthProviderEnum with validation."""
        try:
            return cls(value.lower())
        except ValueError:
            # Default to email for unknown providers
            return cls.GOOGLE
</file>

<file path="src/api/schemas/request/feature_flag_requests.py">
"""
Feature flag request schemas for CRUD operations.
"""
from typing import Optional

from pydantic import BaseModel, Field


class CreateFeatureFlagRequest(BaseModel):
    """Request to create a new feature flag."""
    
    name: str = Field(..., min_length=1, max_length=255, description="Feature flag name")
    enabled: bool = Field(False, description="Initial enabled state")
    description: Optional[str] = Field(None, max_length=500, description="Feature flag description")


class UpdateFeatureFlagRequest(BaseModel):
    """Request to update an existing feature flag."""
    
    enabled: Optional[bool] = Field(None, description="Feature flag enabled state")
    description: Optional[str] = Field(None, max_length=500, description="Feature flag description")
</file>

<file path="src/api/schemas/request/ingredient_based_meal_plan_requests.py">
"""
Request schemas for ingredient-based meal plan generation.
"""
from typing import List

from pydantic import BaseModel, Field


class IngredientBasedMealPlanRequest(BaseModel):
    """
    Simplified request schema for generating meal plans based on available ingredients.
    
    All other preferences (dietary restrictions, nutrition targets, meal planning preferences)
    are automatically retrieved from the user's profile.
    """
    
    # Only ingredient data - everything else comes from user profile
    available_ingredients: List[str] = Field(
        ..., 
        min_items=1,
        description="List of available ingredient names (e.g., ['chicken breast', 'broccoli', 'rice'])"
    )
    available_seasonings: List[str] = Field(
        default_factory=list,
        description="List of available seasonings and spices (e.g., ['salt', 'pepper', 'garlic'])"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "available_ingredients": [
                    "chicken breast",
                    "broccoli", 
                    "brown rice",
                    "olive oil",
                    "onions"
                ],
                "available_seasonings": [
                    "salt", "black pepper", "garlic powder", "paprika", "thyme"
                ]
            }
        }
</file>

<file path="src/api/schemas/request/meal_plan_requests.py">
from datetime import date
from typing import List, Optional

from pydantic import BaseModel, Field

from ..common.meal_plan_enums import (
    DietaryPreferenceSchema,
    FitnessGoalSchema,
    PlanDurationSchema
)


class UserPreferencesSchema(BaseModel):
    dietary_preferences: List[DietaryPreferenceSchema]
    allergies: List[str]
    fitness_goal: FitnessGoalSchema
    meals_per_day: int = Field(..., ge=1, le=6)
    snacks_per_day: int = Field(default=0, ge=0, le=4)
    cooking_time_weekday: int = Field(..., description="Available cooking time on weekdays in minutes")
    cooking_time_weekend: int = Field(..., description="Available cooking time on weekends in minutes")
    favorite_cuisines: List[str]
    disliked_ingredients: List[str]
    plan_duration: PlanDurationSchema = PlanDurationSchema.weekly


class ConversationMessageRequest(BaseModel):
    message: str = Field(..., description="User's message to the meal planning assistant")


class ReplaceMealRequest(BaseModel):
    date: date
    meal_id: str
    dietary_preferences: Optional[List[DietaryPreferenceSchema]] = None
    exclude_ingredients: Optional[List[str]] = None
    preferred_cuisine: Optional[str] = None
</file>

<file path="src/api/schemas/request/user_requests.py">
"""
User management request schemas for Firebase integration.
"""
from datetime import datetime
from typing import Optional

from pydantic import BaseModel, EmailStr, Field

from ..common.auth_enums import AuthProviderEnum


class UserSyncRequest(BaseModel):
    """Request to sync user data from Firebase authentication."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    email: EmailStr = Field(..., description="User email address")
    phone_number: Optional[str] = Field(None, description="User phone number (E.164 format)")
    display_name: Optional[str] = Field(None, description="User display name from Firebase")
    photo_url: Optional[str] = Field(None, description="User profile photo URL")
    provider: AuthProviderEnum = Field(..., description="Authentication provider (phone, google)")
    
    # Generated/computed fields
    username: Optional[str] = Field(None, description="Generated username (auto-generated if not provided)")
    first_name: Optional[str] = Field(None, description="First name (extracted from display_name if not provided)")
    last_name: Optional[str] = Field(None, description="Last name (extracted from display_name if not provided)")


class UserUpdateLastAccessedRequest(BaseModel):
    """Request to update user's last accessed timestamp."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    last_accessed: Optional[datetime] = Field(default_factory=datetime.utcnow, description="Last accessed timestamp")


class UserCreateRequest(BaseModel):
    """Request to create a new user (legacy support)."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    email: EmailStr = Field(..., description="User email address")
    username: Optional[str] = Field(None, description="Username (auto-generated if not provided)")
    first_name: Optional[str] = Field(None, description="First name")
    last_name: Optional[str] = Field(None, description="Last name")
    phone_number: Optional[str] = Field(None, description="Phone number")
    display_name: Optional[str] = Field(None, description="Display name")
    photo_url: Optional[str] = Field(None, description="Profile photo URL")
    provider: AuthProviderEnum = Field(default=AuthProviderEnum.GOOGLE, description="Authentication provider")
</file>

<file path="src/api/schemas/response/activity_responses.py">
"""
Response schemas for activity endpoints.
"""
from typing import Optional

from pydantic import BaseModel


class MacrosResponse(BaseModel):
    """Macronutrient information."""
    protein: float
    carbs: float
    fat: float


class MealActivityResponse(BaseModel):
    """Response schema for meal activity."""
    id: str
    type: str = "meal"
    timestamp: str
    title: str
    meal_type: str
    calories: float
    macros: MacrosResponse
    quantity: float
    status: str
    image_url: Optional[str] = None


class WorkoutActivityResponse(BaseModel):
    """Response schema for workout activity."""
    id: str
    type: str = "workout"
    timestamp: str
    title: str
    description: str
    exercise_type: str
    duration_minutes: int
    calories_burned: float
    notes: Optional[str] = None


class ActivityResponse(BaseModel):
    """Generic activity response that can be either meal or workout."""
    id: str
    type: str
    timestamp: str
    title: str
    
    # Additional fields stored as dict for flexibility
    # This allows both meal and workout activities to use same response
    class Config:
        extra = "allow"
</file>

<file path="src/api/schemas/response/daily_nutrition_response.py">
"""
Daily nutrition summary response DTO.
"""
from typing import Dict

from pydantic import BaseModel, Field


class MacrosResponse(BaseModel):
    """Macronutrient response model."""
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams") 
    fat: float = Field(..., description="Fat in grams")

class DailyNutritionResponse(BaseModel):
    """Response DTO for daily nutrition summary - matches Flutter frontend expectations."""
    date: str = Field(..., description="Date in YYYY-MM-DD format")
    target_calories: float = Field(..., description="Target calories for the day")
    target_macros: MacrosResponse = Field(..., description="Target macros for the day")
    consumed_calories: float = Field(..., description="Calories consumed so far")
    consumed_macros: MacrosResponse = Field(..., description="Macros consumed so far")
    remaining_calories: float = Field(..., description="Remaining calories for the day")
    remaining_macros: MacrosResponse = Field(..., description="Remaining macros for the day")
    completion_percentage: Dict[str, float] = Field(..., description="Completion percentage for calories and macros")
</file>

<file path="src/api/schemas/response/feature_flag_responses.py">
"""
Feature flags response schemas for application-level feature control.
"""
from datetime import datetime
from typing import Dict

from pydantic import BaseModel, Field


class FeatureFlagsResponse(BaseModel):
    """Response containing feature flags for a specific environment."""
    
    flags: Dict[str, bool] = Field(..., description="Feature flag states")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat() + 'Z'
        }


class IndividualFeatureFlagResponse(BaseModel):
    """Response containing a single feature flag."""
    
    name: str = Field(..., description="Feature flag name")
    enabled: bool = Field(..., description="Feature flag state")
    description: str = Field(None, description="Feature flag description")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat() + 'Z'
        }


class FeatureFlagCreatedResponse(BaseModel):
    """Response for successfully created feature flag."""
    
    name: str = Field(..., description="Feature flag name")
    enabled: bool = Field(..., description="Feature flag state")
    description: str = Field(None, description="Feature flag description")
    created_at: datetime = Field(..., description="Creation timestamp")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat() + 'Z'
        }


class FeatureFlagUpdatedResponse(BaseModel):
    """Response for successfully updated feature flag."""
    
    name: str = Field(..., description="Feature flag name")
    enabled: bool = Field(..., description="Feature flag state")
    description: str = Field(None, description="Feature flag description")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    class Config:
        json_encoders = {
            datetime: lambda v: v.isoformat() + 'Z'
        }
</file>

<file path="src/api/schemas/response/meal_plan_responses.py">
from datetime import datetime, date
from typing import List, Optional, Dict

from pydantic import BaseModel, Field

from ..common.meal_plan_enums import (
    MealTypeSchema,
    PlanDurationSchema
)


class PlannedMealSchema(BaseModel):
    meal_id: str
    meal_type: MealTypeSchema
    name: str
    description: str
    prep_time: int = Field(..., description="Preparation time in minutes")
    cook_time: int = Field(..., description="Cooking time in minutes")
    total_time: int = Field(..., description="Total time in minutes")
    calories: int
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams")
    fat: float = Field(..., description="Fat in grams")
    ingredients: List[str]
    seasonings: List[str]
    instructions: List[str]
    is_vegetarian: bool
    is_vegan: bool
    is_gluten_free: bool
    cuisine_type: Optional[str] = None


class DayPlanSchema(BaseModel):
    date: date
    meals: List[PlannedMealSchema]
    total_nutrition: Dict[str, float] = Field(..., description="Total daily nutrition values")


class MealPlanSummaryResponse(BaseModel):
    plan_id: str
    user_id: str
    plan_duration: PlanDurationSchema
    start_date: date
    end_date: date
    total_meals: int
    created_at: datetime


class ErrorResponse(BaseModel):
    error: str
    message: str
    details: Optional[Dict] = None


class NutritionSummarySchema(BaseModel):
    calories: int
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams")
    fat: float = Field(..., description="Fat in grams")


class UserPreferenceSummarySchema(BaseModel):
    dietary_preferences: List[str]
    health_conditions: List[str]
    allergies: List[str]
    activity_level: str
    fitness_goal: str
    meals_per_day: int
    snacks_per_day: int


class MealsByDateResponse(BaseModel):
    """Response for getting meals by specific date."""
    date: str = Field(..., description="Date in ISO format (YYYY-MM-DD)")
    day_formatted: str = Field(..., description="Human-readable date format (e.g., 'Monday, January 15, 2024')")
    meals: List[PlannedMealSchema] = Field(..., description="List of meals for this date")
    total_meals: int = Field(..., description="Total number of meals for this date")
    user_id: str = Field(..., description="User ID")
    
    class Config:
        json_schema_extra = {
            "example": {
                "date": "2024-01-15",
                "day_formatted": "Monday, January 15, 2024",
                "meals": [
                    {
                        "meal_id": "meal_001",
                        "meal_type": "breakfast",
                        "name": "Greek Yogurt Parfait",
                        "description": "Healthy breakfast with berries and granola",
                        "prep_time": 5,
                        "cook_time": 0,
                        "total_time": 5,
                        "calories": 350,
                        "protein": 20.5,
                        "carbs": 35.2,
                        "fat": 12.8,
                        "ingredients": ["Greek yogurt", "Mixed berries", "Granola", "Honey"],
                        "instructions": ["Layer yogurt in bowl", "Add berries", "Top with granola"],
                        "is_vegetarian": True,
                        "is_vegan": False,
                        "is_gluten_free": True,
                        "cuisine_type": "Mediterranean"
                    }
                ],
                "total_meals": 1,
                "user_id": "user123"
            }
        }


# New strongly typed response models for meal generation
class GeneratedMealResponse(BaseModel):
    """Response model for a generated meal (strongly typed version)."""
    meal_id: str = Field(..., description="Unique meal identifier")
    meal_type: str = Field(..., description="Type of meal (breakfast, lunch, dinner, snack)")
    name: str = Field(..., description="Name of the meal")
    description: str = Field(..., description="Brief description of the meal")
    prep_time: int = Field(..., description="Preparation time in minutes")
    cook_time: int = Field(..., description="Cooking time in minutes")
    total_time: int = Field(..., description="Total time (prep + cook) in minutes")
    calories: int = Field(..., description="Calories for this meal")
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams")
    fat: float = Field(..., description="Fat in grams")
    ingredients: List[str] = Field(..., description="List of ingredients")
    instructions: List[str] = Field(..., description="Cooking instructions")
    is_vegetarian: bool = Field(..., description="Whether meal is vegetarian")
    is_vegan: bool = Field(..., description="Whether meal is vegan")
    is_gluten_free: bool = Field(..., description="Whether meal is gluten-free")
    cuisine_type: Optional[str] = Field(None, description="Type of cuisine")


class UserPreferencesStrongResponse(BaseModel):
    """User preferences in the response (strongly typed version)."""
    dietary_preferences: List[str] = Field(default=[], description="Dietary preferences")
    health_conditions: List[str] = Field(default=[], description="Health conditions")
    allergies: List[str] = Field(default=[], description="Food allergies")
    activity_level: str = Field(..., description="Activity level")
    fitness_goal: str = Field(..., description="Fitness goal")
    meals_per_day: int = Field(..., description="Number of meals per day")
    snacks_per_day: int = Field(..., description="Number of snacks per day")




    class Config:
        """Pydantic config."""
        json_encoders = {
            date: lambda v: v.isoformat()
        }


class MealPlanGenerationStatusResponse(BaseModel):
    """Simple status response for meal plan generation operations."""
    success: bool = Field(..., description="Whether the meal plan generation was successful")
    message: str = Field(..., description="Status message for the user")
    user_id: str = Field(..., description="User identifier")
    
    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "message": "Weekly meal plan generated successfully!",
                "user_id": "user123"
            }
        }
</file>

<file path="src/api/schemas/response/onboarding_responses.py">
from typing import Optional, List, Dict, Any, Union

from pydantic import BaseModel


class OnboardingFieldResponse(BaseModel):
    field_id: str
    label: str
    field_type: str
    required: bool
    placeholder: Optional[str] = None
    help_text: Optional[str] = None
    options: Optional[List[Dict[str, Any]]] = None
    validation: Optional[Dict[str, Any]] = None
    default_value: Optional[Union[str, int, float, bool]] = None

class OnboardingSectionResponse(BaseModel):
    section_id: str
    title: str
    description: str
    section_type: str
    order: int
    fields: List[OnboardingFieldResponse]
    is_active: bool
    created_at: Optional[str] = None
    updated_at: Optional[str] = None

class OnboardingSectionsResponse(BaseModel):
    sections: List[OnboardingSectionResponse]
    total_sections: int

class OnboardingResponseResponse(BaseModel):
    response_id: str
    user_id: Optional[str] = None
    section_id: str
    field_responses: Dict[str, Any]
    completed_at: Optional[str] = None
    created_at: Optional[str] = None


class OnboardingResponse(BaseModel):
    """Response for successful onboarding data save."""
    message: str
    user_id: str
    profile_id: str
    tdee_calculation: Dict[str, Any]
</file>

<file path="src/api/schemas/__init__.py">
"""
API Schemas module - Request and Response DTOs.

This module provides a clean import structure for all API schemas,
organized into request and response categories following clean architecture.
"""

# Re-export all request schemas
from .request import *

# Re-export all response schemas
from .response import *
</file>

<file path="src/api/utils/__init__.py">
"""
API utility modules.
"""
</file>

<file path="src/api/utils/file_validation.py">
"""
File validation utilities for API endpoints.
"""
from typing import List

from fastapi import UploadFile

from src.api.exceptions import ValidationException


class FileValidator:
    """Validates uploaded files."""
    
    @staticmethod
    def validate_image_file(
        file: UploadFile,
        allowed_content_types: List[str],
        max_size_bytes: int
    ) -> bytes:
        """
        Validate an uploaded image file.
        
        Args:
            file: The uploaded file
            allowed_content_types: List of allowed MIME types
            max_size_bytes: Maximum file size in bytes
            
        Returns:
            The file content as bytes
            
        Raises:
            ValidationException: If validation fails
        """
        # Validate content type
        if file.content_type not in allowed_content_types:
            raise ValidationException(
                message=f"Invalid file type. Only {', '.join(allowed_content_types)} are allowed.",
                error_code="INVALID_FILE_TYPE",
                details={"content_type": file.content_type, "allowed": allowed_content_types}
            )
        
        # Read file content
        try:
            contents = file.file.read()
        except Exception as e:
            raise ValidationException(
                message="Failed to read file content",
                error_code="FILE_READ_ERROR",
                details={"error": str(e)}
            )
        finally:
            file.file.seek(0)  # Reset file pointer
        
        # Validate file size
        if len(contents) > max_size_bytes:
            raise ValidationException(
                message=f"File size exceeds maximum allowed ({max_size_bytes // (1024*1024)}MB)",
                error_code="FILE_TOO_LARGE",
                details={"size_bytes": len(contents), "max_bytes": max_size_bytes}
            )
        
        return contents
</file>

<file path="src/api/utils/file_validator.py">
"""
File validation utilities for API endpoints.
"""
from typing import List

from fastapi import UploadFile

from src.api.exceptions import ValidationException


class FileValidator:
    """Utility class for file validation."""
    
    @staticmethod
    async def validate_image_file(
        file: UploadFile,
        allowed_content_types: List[str],
        max_size_bytes: int
    ) -> bytes:
        """
        Validate an uploaded image file.
        
        Args:
            file: The uploaded file
            allowed_content_types: List of allowed MIME types
            max_size_bytes: Maximum file size in bytes
            
        Returns:
            The file contents as bytes
            
        Raises:
            ValidationException: If validation fails
        """
        # Validate content type
        if file.content_type not in allowed_content_types:
            raise ValidationException(
                f"Invalid file type '{file.content_type}'. "
                f"Allowed types: {', '.join(allowed_content_types)}"
            )
        
        # Read file contents
        contents = await file.read()
        
        # Validate file size
        if len(contents) > max_size_bytes:
            size_mb = max_size_bytes / (1024 * 1024)
            raise ValidationException(
                f"File size exceeds maximum allowed size of {size_mb}MB"
            )
        
        # Validate file is not empty
        if len(contents) == 0:
            raise ValidationException("File is empty")
        
        # Reset file position for potential reuse
        await file.seek(0)
        
        return contents
</file>

<file path="src/app/commands/daily_meal/__init__.py">
"""Daily meal commands."""
from .generate_daily_meal_suggestions_command import GenerateDailyMealSuggestionsCommand
from .generate_single_meal_command import GenerateSingleMealCommand

__all__ = [
    "GenerateDailyMealSuggestionsCommand",
    "GenerateSingleMealCommand",
]
</file>

<file path="src/app/commands/daily_meal/generate_daily_meal_suggestions_command.py">
"""
Generate daily meal suggestions command.
"""
from dataclasses import dataclass
from typing import Optional, List, Dict

from src.app.events.base import Command


@dataclass
class GenerateDailyMealSuggestionsCommand(Command):
    """Command to generate daily meal suggestions."""
    age: int
    gender: str
    height: float
    weight: float
    activity_level: str
    goal: str
    dietary_preferences: Optional[List[str]] = None
    health_conditions: Optional[List[str]] = None
    target_calories: Optional[float] = None
    target_macros: Optional[Dict[str, float]] = None
</file>

<file path="src/app/commands/daily_meal/generate_single_meal_command.py">
"""
Generate single meal command.
"""
from dataclasses import dataclass
from typing import Optional, List, Dict

from src.app.events.base import Command


@dataclass
class GenerateSingleMealCommand(Command):
    """Command to generate a single meal suggestion."""
    meal_type: str
    age: int
    gender: str
    height: float
    weight: float
    activity_level: str
    goal: str
    dietary_preferences: Optional[List[str]] = None
    health_conditions: Optional[List[str]] = None
    target_calories: Optional[float] = None
    target_macros: Optional[Dict[str, float]] = None
</file>

<file path="src/app/commands/meal/__init__.py">
"""
Meal commands.
"""
from .delete_meal_command import DeleteMealCommand
from .edit_meal_command import EditMealCommand, AddCustomIngredientCommand, FoodItemChange, CustomNutritionData
from .upload_meal_image_immediately_command import UploadMealImageImmediatelyCommand

__all__ = [
    "UploadMealImageImmediatelyCommand",
    "EditMealCommand",
    "AddCustomIngredientCommand",
    "FoodItemChange",
    "CustomNutritionData",
    "DeleteMealCommand",
]
</file>

<file path="src/app/commands/meal/delete_meal_command.py">
"""
Command to mark a meal as INACTIVE (soft delete).
"""
from dataclasses import dataclass


@dataclass
class DeleteMealCommand:
    meal_id: str
</file>

<file path="src/app/commands/meal/edit_meal_command.py">
"""
Command to edit meal ingredients and portions.
"""
from dataclasses import dataclass, field
from typing import Optional, List

from src.app.events.base import Command


@dataclass
class FoodItemChange:
    """Represents a change to a food item in meal editing."""
    action: str  # "add", "update", "remove"
    id: Optional[str] = None
    fdc_id: Optional[int] = None
    name: Optional[str] = None
    quantity: Optional[float] = None
    unit: Optional[str] = None
    custom_nutrition: Optional['CustomNutritionData'] = None


@dataclass
class CustomNutritionData:
    """Custom nutrition data for non-USDA ingredients."""
    calories_per_100g: float
    protein_per_100g: float
    carbs_per_100g: float
    fat_per_100g: float


@dataclass
class EditMealCommand(Command):
    """Command to edit a meal's ingredients."""
    meal_id: str
    dish_name: Optional[str] = None
    food_item_changes: List[FoodItemChange] = field(default_factory=list)


@dataclass
class AddCustomIngredientCommand(Command):
    """Command to add a custom ingredient to a meal."""
    meal_id: str
    name: str
    quantity: float
    unit: str
    nutrition: CustomNutritionData
</file>

<file path="src/app/commands/meal/upload_meal_image_immediately_command.py">
"""
Command for immediate meal image upload and analysis.
"""
from dataclasses import dataclass
from datetime import date
from typing import Optional

from src.app.events.base import Command


@dataclass
class UploadMealImageImmediatelyCommand(Command):
    """
    Command to upload and immediately analyze a meal image.
    
    This command combines upload and analysis in a single synchronous operation,
    returning complete nutritional analysis without background processing.
    """
    user_id: str
    file_contents: bytes
    content_type: str
    target_date: Optional[date] = None
</file>

<file path="src/app/commands/meal_plan/__init__.py">
"""Meal plan commands."""
from .generate_weekly_ingredient_based_meal_plan_command import GenerateWeeklyIngredientBasedMealPlanCommand

__all__ = [
    "GenerateWeeklyIngredientBasedMealPlanCommand",
]
</file>

<file path="src/app/commands/meal_plan/generate_weekly_ingredient_based_meal_plan_command.py">
"""
Command for generating weekly meal plans based on available ingredients and seasonings.
"""
from dataclasses import dataclass
from typing import List

from src.app.events.base import Command


@dataclass
class GenerateWeeklyIngredientBasedMealPlanCommand(Command):
    """
    Command to generate a weekly meal plan (Monday to Sunday) based on available ingredients and seasonings.
    All other preferences are retrieved from the user's profile.
    """
    # User identification
    user_id: str

    # Only ingredient data - everything else comes from user profile
    available_ingredients: List[str]  # List of ingredient names
    available_seasonings: List[str]  # List of seasoning names
    
    def __post_init__(self):
        """Validate command data."""
        if not self.available_ingredients:
            raise ValueError("At least one ingredient must be provided")
</file>

<file path="src/app/commands/user/complete_onboarding_command.py">
"""
Command to mark user onboarding as completed.
"""
from dataclasses import dataclass

from src.app.events.base import Command


@dataclass
class CompleteOnboardingCommand(Command):
    """Command to mark user onboarding as completed."""
    firebase_uid: str
</file>

<file path="src/app/commands/user/sync_user_command.py">
"""
Command to sync user data from Firebase authentication.
"""
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from src.api.schemas.common.auth_enums import AuthProviderEnum


@dataclass
class SyncUserCommand:
    """Command to sync user data from Firebase authentication."""
    firebase_uid: str
    email: str
    phone_number: Optional[str] = None
    display_name: Optional[str] = None
    photo_url: Optional[str] = None
    provider: AuthProviderEnum = AuthProviderEnum.GOOGLE
    username: Optional[str] = None
    first_name: Optional[str] = None
    last_name: Optional[str] = None


@dataclass
class UpdateUserLastAccessedCommand:
    """Command to update user's last accessed timestamp."""
    firebase_uid: str
    last_accessed: Optional[datetime] = None
</file>

<file path="src/app/events/daily_meal/__init__.py">
"""
Daily meal event exports.
"""
from .daily_meals_generated_event import DailyMealsGeneratedEvent

__all__ = [
    "DailyMealsGeneratedEvent",
]
</file>

<file path="src/app/events/daily_meal/daily_meals_generated_event.py">
"""
Daily meals generated event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import List
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class DailyMealsGeneratedEvent(DomainEvent):
    """Event raised when daily meals are generated."""
    aggregate_id: str
    user_id: str
    date: str
    meal_count: int
    total_calories: float
    meal_ids: List[str]
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal/__init__.py">
"""
Meal domain events.
"""
from src.app.events.meal.meal_analysis_started_event import MealAnalysisStartedEvent
from src.app.events.meal.meal_edited_event import MealEditedEvent
from src.app.events.meal.meal_image_uploaded_event import MealImageUploadedEvent
from src.app.events.meal.meal_nutrition_updated_event import MealNutritionUpdatedEvent

__all__ = [
    "MealImageUploadedEvent",
    "MealAnalysisStartedEvent",
    "MealNutritionUpdatedEvent",
    "MealEditedEvent",
]
</file>

<file path="src/app/events/meal/meal_analysis_started_event.py">
"""
Meal analysis started event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class MealAnalysisStartedEvent(DomainEvent):
    """Event raised when meal analysis starts."""
    aggregate_id: str
    meal_id: str
    analysis_type: str = "vision_ai"
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal/meal_edited_event.py">
"""
Event published when a meal is edited.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class MealEditedEvent(DomainEvent):
    """Event published when a meal is edited."""
    aggregate_id: str
    meal_id: str
    user_id: str
    edit_type: str  # "ingredients_updated", "portions_changed", "ingredient_added", etc.
    changes_summary: str
    nutrition_delta: Dict[str, float]  # Change in nutrition values
    edit_count: int
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal/meal_image_uploaded_event.py">
"""
Meal image uploaded event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class MealImageUploadedEvent(DomainEvent):
    """Event raised when a meal image is uploaded."""
    aggregate_id: str  # This should be the meal_id
    meal_id: str
    image_url: str
    upload_timestamp: datetime
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal/meal_nutrition_updated_event.py">
"""
Meal nutrition updated event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Any
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class MealNutritionUpdatedEvent(DomainEvent):
    """Event raised when meal nutrition is updated."""
    aggregate_id: str
    meal_id: str
    old_weight: float
    new_weight: float
    updated_nutrition: Dict[str, Any]
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal_plan/__init__.py">
"""
Meal plan event exports.
"""
from .conversation_started_event import ConversationStartedEvent
from .meal_plan_generated_event import MealPlanGeneratedEvent
from .meal_replaced_event import MealReplacedEvent

__all__ = [
    "ConversationStartedEvent",
    "MealPlanGeneratedEvent",
    "MealReplacedEvent",
]
</file>

<file path="src/app/events/meal_plan/conversation_started_event.py">
"""
Conversation started event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class ConversationStartedEvent(DomainEvent):
    """Event raised when conversation starts."""
    aggregate_id: str
    conversation_id: str
    user_id: str
    initial_state: str
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal_plan/meal_plan_generated_event.py">
"""
Meal plan generated event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class MealPlanGeneratedEvent(DomainEvent):
    """Event raised when meal plan is generated."""
    aggregate_id: str
    plan_id: str
    user_id: str
    days: int
    total_meals: int
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/meal_plan/meal_replaced_event.py">
"""
Meal replaced event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class MealReplacedEvent(DomainEvent):
    """Event raised when a meal is replaced in plan."""
    aggregate_id: str
    plan_id: str
    old_meal_id: str
    new_meal_id: str
    date: str
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/tdee/__init__.py">
"""
TDEE domain events.
"""
from src.app.events.tdee.tdee_calculated_event import TdeeCalculatedEvent

__all__ = [
    "TdeeCalculatedEvent",
]
</file>

<file path="src/app/events/tdee/tdee_calculated_event.py">
"""
TDEE calculated event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Any
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class TdeeCalculatedEvent(DomainEvent):
    """Event raised when TDEE is calculated."""
    aggregate_id: str
    user_id: str
    bmr: float
    tdee: float
    target_calories: float
    formula_used: str
    calculation_params: Dict[str, Any]
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/user/__init__.py">
"""
User event exports.
"""
from .user_onboarded_event import UserOnboardedEvent
from .user_profile_updated_event import UserProfileUpdatedEvent

__all__ = [
    "UserOnboardedEvent",
    "UserProfileUpdatedEvent",
]
</file>

<file path="src/app/events/user/user_onboarded_event.py">
"""
User onboarded event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class UserOnboardedEvent(DomainEvent):
    """Event raised when user completes onboarding."""
    aggregate_id: str
    user_id: str
    profile_id: str
    tdee: float
    target_calories: float
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/user/user_profile_updated_event.py">
"""
User profile updated event.
"""
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional
from uuid import uuid4

from src.app.events.base import DomainEvent


@dataclass
class UserProfileUpdatedEvent(DomainEvent):
    """Event raised when user profile is updated."""
    aggregate_id: str
    profile_id: str
    updated_fields: List[str]
    old_tdee: Optional[float] = None
    new_tdee: Optional[float] = None
    # Metadata fields with defaults
    event_id: str = field(default_factory=lambda: str(uuid4()))
    timestamp: datetime = field(default_factory=datetime.now)
    correlation_id: str = field(default_factory=lambda: str(uuid4()))
</file>

<file path="src/app/events/__init__.py">
"""
Event-driven architecture components.
"""
from .base import DomainEvent

# Daily meal events
from .daily_meal import (
    DailyMealsGeneratedEvent,
)

# Meal events
from .meal import (
    MealAnalysisStartedEvent,
    MealImageUploadedEvent,
    MealNutritionUpdatedEvent,
    MealEditedEvent,
)

# Meal plan events
from .meal_plan import (
    ConversationStartedEvent,
    MealPlanGeneratedEvent,
    MealReplacedEvent,
)

# TDEE events
from .tdee import (
    TdeeCalculatedEvent,
)

# User events
from .user import (
    UserOnboardedEvent,
    UserProfileUpdatedEvent,
)

__all__ = [
    # Base
    "DomainEvent",
    
    # Daily meal events
    "DailyMealsGeneratedEvent",
    
    # Meal events
    "MealAnalysisStartedEvent",
    "MealImageUploadedEvent",
    "MealNutritionUpdatedEvent",
    "MealEditedEvent",

    # Meal plan events
    "ConversationStartedEvent",
    "MealPlanGeneratedEvent",
    "MealReplacedEvent",
    
    # TDEE events
    "TdeeCalculatedEvent",
    
    # User events
    "UserOnboardedEvent",
    "UserProfileUpdatedEvent",
]
</file>

<file path="src/app/events/base.py">
"""
Base classes for event-driven architecture.
"""
import logging
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TypeVar, Generic

logger = logging.getLogger(__name__)

# Type variable for event
TEvent = TypeVar('TEvent', bound='Event')
TResult = TypeVar('TResult')


class Event(ABC):
    """Base class for all events."""
    pass


@dataclass
class Command(Event):
    """Base class for commands (events that change state)."""
    pass


@dataclass
class Query(Event):
    """Base class for queries (events that read state)."""
    pass


class DomainEvent(Event):
    """
    Base class for domain events (things that happened).
    
    Subclasses should:
    1. Use @dataclass decorator
    2. Define aggregate_id: str as the first field
    3. Define any other required fields
    4. Add these metadata fields at the end with defaults:
       - event_id: str = field(default_factory=lambda: str(uuid4()))
       - timestamp: datetime = field(default_factory=datetime.now)
       - correlation_id: str = field(default_factory=lambda: str(uuid4()))
    """
    pass


class EventHandler(ABC, Generic[TEvent, TResult]):
    """Base class for event handlers."""
    
    @abstractmethod
    async def handle(self, event: TEvent) -> TResult:
        """Handle the event and return result."""
        pass
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for the handler. Override in subclasses if needed."""
        pass


def handles(event_type: type):
    """Decorator to mark which event type a handler handles."""
    def decorator(handler_class):
        handler_class._handles = event_type
        return handler_class
    return decorator
</file>

<file path="src/app/handlers/command_handlers/update_user_last_accessed_command_handler.py">
"""
UpdateUserLastAccessedCommandHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from datetime import datetime
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.commands.user.sync_user_command import UpdateUserLastAccessedCommand
from src.app.events.base import EventHandler, handles
from src.infra.database.models.user import User

logger = logging.getLogger(__name__)


@handles(UpdateUserLastAccessedCommand)
class UpdateUserLastAccessedCommandHandler(EventHandler[UpdateUserLastAccessedCommand, Dict[str, Any]]):
    """Handler for updating user's last accessed timestamp."""

    def __init__(self, db: Session = None):
        self.db = db

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, command: UpdateUserLastAccessedCommand) -> Dict[str, Any]:
        """Update user's last accessed timestamp."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        try:
            # Find user by firebase_uid
            user = self.db.query(User).filter(
                User.firebase_uid == command.firebase_uid
            ).first()

            if not user:
                raise ResourceNotFoundException(f"User with Firebase UID {command.firebase_uid} not found")

            # Update last_accessed timestamp
            last_accessed = command.last_accessed or datetime.utcnow()
            user.last_accessed = last_accessed

            self.db.commit()

            return {
                "firebase_uid": command.firebase_uid,
                "updated": True,
                "message": "Last accessed timestamp updated successfully",
                "timestamp": last_accessed
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating last accessed: {str(e)}")
            raise
</file>

<file path="src/app/handlers/event_handlers/__init__.py">
"""
Event handlers for domain events.
"""
</file>

<file path="src/app/handlers/query_handlers/get_food_details_query_handler.py">
"""
GetFoodDetailsQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
from typing import Any, Dict

from src.app.events.base import EventHandler, handles
from src.app.queries.food.get_food_details_query import GetFoodDetailsQuery
from src.domain.services.food_mapping_service import FoodMappingService


@handles(GetFoodDetailsQuery)
class GetFoodDetailsQueryHandler(EventHandler[GetFoodDetailsQuery, Dict[str, Any]]):
    """Handler for getting food details by FDC ID."""

    def __init__(self, food_data_service, cache_service, mapping_service: FoodMappingService):
        self.food_data_service = food_data_service
        self.cache_service = cache_service
        self.mapping_service = mapping_service

    async def handle(self, event: GetFoodDetailsQuery) -> Dict[str, Any]:
        cached = await self.cache_service.get_cached_food(event.fdc_id)
        if cached is not None:
            return self.mapping_service.map_food_details(cached)

        raw = await self.food_data_service.get_food_details(event.fdc_id)
        await self.cache_service.cache_food(event.fdc_id, raw)
        return self.mapping_service.map_food_details(raw)
</file>

<file path="src/app/handlers/query_handlers/get_meal_by_id_query_handler.py">
"""
GetMealByIdQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.meal import GetMealByIdQuery
from src.domain.model.meal import Meal
from src.domain.ports.meal_repository_port import MealRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetMealByIdQuery)
class GetMealByIdQueryHandler(EventHandler[GetMealByIdQuery, Meal]):
    """Handler for retrieving a meal by ID."""

    def __init__(self, meal_repository: MealRepositoryPort = None):
        self.meal_repository = meal_repository

    def set_dependencies(self, meal_repository: MealRepositoryPort):
        """Set dependencies for dependency injection."""
        self.meal_repository = meal_repository

    async def handle(self, query: GetMealByIdQuery) -> Meal:
        """Get meal by ID."""
        if not self.meal_repository:
            raise RuntimeError("Meal repository not configured")

        meal = self.meal_repository.find_by_id(query.meal_id)

        if not meal:
            raise ResourceNotFoundException(f"Meal with ID {query.meal_id} not found")

        return meal
</file>

<file path="src/app/handlers/query_handlers/get_meal_plan_query_handler.py">
"""
GetMealPlanQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.meal_plan import GetMealPlanQuery

logger = logging.getLogger(__name__)


@handles(GetMealPlanQuery)
class GetMealPlanQueryHandler(EventHandler[GetMealPlanQuery, Dict[str, Any]]):
    """Handler for getting meal plans."""

    def __init__(self):
        # In-memory storage for demo
        self._meal_plans: Dict[str, Dict[str, Any]] = {}

    def set_dependencies(self):
        """No external dependencies needed."""
        pass

    async def handle(self, query: GetMealPlanQuery) -> Dict[str, Any]:
        """Get a meal plan by ID."""
        # For demo purposes, return not found
        # In production, this would fetch from database
        raise ResourceNotFoundException(
            message="Meal plan not found",
            details={"plan_id": query.plan_id}
        )

        return {
            "meal_plan": meal_plan
        }
</file>

<file path="src/app/handlers/query_handlers/get_meal_planning_summary_query_handler.py">
"""
GetMealPlanningSummaryQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.daily_meal import GetMealPlanningSummaryQuery
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)


@handles(GetMealPlanningSummaryQuery)
class GetMealPlanningSummaryQueryHandler(EventHandler[GetMealPlanningSummaryQuery, Dict[str, Any]]):
    """Handler for getting meal planning summary."""

    def __init__(self, db: Session = None):
        self.db = db

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, query: GetMealPlanningSummaryQuery) -> Dict[str, Any]:
        """Get meal planning summary for a profile."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get user profile
        profile = self.db.query(UserProfile).filter(
            UserProfile.id == query.user_profile_id
        ).first()

        if not profile:
            raise ResourceNotFoundException(
                message="User profile not found",
                details={"user_profile_id": query.user_profile_id}
            )

        # Calculate TDEE using the proper query handler
        from src.app.handlers.query_handlers.get_user_tdee_query_handler import GetUserTdeeQueryHandler
        from src.app.queries.tdee import GetUserTdeeQuery

        tdee_handler = GetUserTdeeQueryHandler(self.db)
        tdee_query = GetUserTdeeQuery(user_id=profile.user_id)
        tdee_result = await tdee_handler.handle(tdee_query)

        return {
            "profile": {
                "id": profile.id,
                "user_id": profile.user_id,
                "age": profile.age,
                "gender": profile.gender,
                "height_cm": profile.height_cm,
                "weight_kg": profile.weight_kg,
                "body_fat_percentage": profile.body_fat_percentage,
                "activity_level": profile.activity_level,
                "fitness_goal": profile.fitness_goal,
                "target_weight_kg": profile.target_weight_kg,
                "meals_per_day": profile.meals_per_day,
                "snacks_per_day": profile.snacks_per_day
            },
            "preferences": {
                "dietary_preferences": profile.dietary_preferences or [],
                "health_conditions": profile.health_conditions or [],
                "allergies": profile.allergies or []
            },
            "tdee_calculation": {
                "bmr": tdee_result['bmr'],
                "tdee": tdee_result['tdee'],
                "target_calories": tdee_result['target_calories'],
                "macros": {
                    "protein": tdee_result['macros']['protein'],
                    "carbs": tdee_result['macros']['carbs'],
                    "fat": tdee_result['macros']['fat']
                }
            }
        }
</file>

<file path="src/app/handlers/query_handlers/get_meal_suggestions_for_profile_query_handler.py">
"""
GetMealSuggestionsForProfileQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from datetime import date
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.daily_meal import GetMealSuggestionsForProfileQuery
from src.domain.services.daily_meal_suggestion_service import DailyMealSuggestionService
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)


@handles(GetMealSuggestionsForProfileQuery)
class GetMealSuggestionsForProfileQueryHandler(EventHandler[GetMealSuggestionsForProfileQuery, Dict[str, Any]]):
    """Handler for getting meal suggestions based on user profile."""

    def __init__(self, db: Session = None):
        self.db = db
        self.suggestion_service = DailyMealSuggestionService()

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, query: GetMealSuggestionsForProfileQuery) -> Dict[str, Any]:
        """Get meal suggestions for a user profile."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get user profile
        profile = self.db.query(UserProfile).filter(
            UserProfile.id == query.user_profile_id
        ).first()

        if not profile:
            raise ResourceNotFoundException(
                message="User profile not found",
                details={"user_profile_id": query.user_profile_id}
            )

        # Calculate TDEE using the proper query handler
        from src.app.handlers.query_handlers.get_user_tdee_query_handler import GetUserTdeeQueryHandler
        from src.app.queries.tdee import GetUserTdeeQuery

        tdee_handler = GetUserTdeeQueryHandler(self.db)
        tdee_query = GetUserTdeeQuery(user_id=profile.user_id)
        tdee_result = await tdee_handler.handle(tdee_query)

        # Prepare user data
        user_data = {
            'age': profile.age,
            'gender': profile.gender,
            'height': profile.height_cm,
            'weight': profile.weight_kg,
            'activity_level': profile.activity_level or 'moderate',
            'goal': profile.fitness_goal or 'maintenance',
            'dietary_preferences': profile.dietary_preferences or [],
            'health_conditions': profile.health_conditions or [],
            'target_calories': tdee_result['target_calories'],
            'target_macros': tdee_result['macros']
        }

        # Generate suggestions
        suggested_meals = self.suggestion_service.generate_daily_suggestions(user_data)

        # Format response
        from src.app.handlers.command_handlers.generate_daily_meal_suggestions_command_handler import GenerateDailyMealSuggestionsCommandHandler
        meal_handler = GenerateDailyMealSuggestionsCommandHandler()
        meals = [meal_handler._format_meal(meal) for meal in suggested_meals]

        # Calculate totals
        total_calories = sum(meal.calories for meal in suggested_meals)
        total_protein = sum(meal.protein for meal in suggested_meals)
        total_carbs = sum(meal.carbs for meal in suggested_meals)
        total_fat = sum(meal.fat for meal in suggested_meals)

        return {
            "date": date.today().isoformat(),
            "meal_count": len(meals),
            "meals": meals,
            "daily_totals": {
                "calories": round(total_calories, 1),
                "protein": round(total_protein, 1),
                "carbs": round(total_carbs, 1),
                "fat": round(total_fat, 1)
            },
            "target_calories": tdee_result['target_calories'],
            "target_macros": tdee_result['macros']
        }
</file>

<file path="src/app/handlers/query_handlers/get_single_meal_for_profile_query_handler.py">
"""
GetSingleMealForProfileQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.app.events.base import EventHandler, handles
from src.app.queries.daily_meal import GetSingleMealForProfileQuery, GetMealSuggestionsForProfileQuery
from src.domain.services.daily_meal_suggestion_service import DailyMealSuggestionService

logger = logging.getLogger(__name__)


@handles(GetSingleMealForProfileQuery)
class GetSingleMealForProfileQueryHandler(EventHandler[GetSingleMealForProfileQuery, Dict[str, Any]]):
    """Handler for getting a single meal suggestion for a profile."""

    def __init__(self, db: Session = None):
        self.db = db
        self.suggestion_service = DailyMealSuggestionService()

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, query: GetSingleMealForProfileQuery) -> Dict[str, Any]:
        """Get a single meal suggestion for a profile."""
        # Use the profile suggestions handler to get all meals
        from src.app.handlers.query_handlers.get_meal_suggestions_for_profile_query_handler import GetMealSuggestionsForProfileQueryHandler

        profile_handler = GetMealSuggestionsForProfileQueryHandler(self.db)
        all_suggestions = await profile_handler.handle(
            GetMealSuggestionsForProfileQuery(user_profile_id=query.user_profile_id)
        )

        # Find the requested meal type
        for meal in all_suggestions["meals"]:
            if meal["meal_type"].lower() == query.meal_type.lower():
                return {
                    "success": True,
                    "meal": meal
                }

        raise ValueError(f"No {query.meal_type} suggestion found for profile")
</file>

<file path="src/app/handlers/query_handlers/search_foods_query_handler.py">
"""
SearchFoodsQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
from typing import Any, Dict, List

from src.app.events.base import EventHandler, handles
from src.app.queries.food.search_foods_query import SearchFoodsQuery
from src.domain.services.food_mapping_service import FoodMappingService


@handles(SearchFoodsQuery)
class SearchFoodsQueryHandler(EventHandler[SearchFoodsQuery, Dict[str, Any]]):
    """Handler for searching foods in the database."""

    def __init__(self, food_data_service, cache_service, mapping_service: FoodMappingService):
        self.food_data_service = food_data_service
        self.cache_service = cache_service
        self.mapping_service = mapping_service

    async def handle(self, event: SearchFoodsQuery) -> Dict[str, Any]:
        if not event.query or not event.query.strip():
            return {"results": [], "query": event.query, "total": 0}

        cached = await self.cache_service.get_cached_search(event.query)
        if cached is not None:
            # Process cached results as well
            processed_cached = self._process_search_results(cached)
            mapped = [self.mapping_service.map_search_item(i) for i in processed_cached]
            return {"results": mapped, "query": event.query, "total": len(mapped)}

        raw = await self.food_data_service.search_foods(event.query, event.limit)

        # Process results: deduplicate exact matches and capitalize names
        processed_raw = self._process_search_results(raw)

        await self.cache_service.cache_search(event.query, processed_raw)
        mapped = [self.mapping_service.map_search_item(i) for i in processed_raw]
        return {"results": mapped, "query": event.query, "total": len(mapped)}

    def _process_search_results(self, raw_results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Process search results to:
        1. Deduplicate exact matches (keep only first occurrence)
        2. Capitalize food names properly
        """
        if not raw_results:
            return raw_results

        seen_names = set()
        processed_results = []

        for item in raw_results:
            # Get the original name
            original_name = item.get("description", "")

            # Capitalize the name properly
            capitalized_name = self._capitalize_food_name(original_name)

            # Check for exact duplicates (case-insensitive)
            name_key = capitalized_name.lower().strip()

            if name_key not in seen_names:
                # First occurrence of this name, keep it
                seen_names.add(name_key)

                # Create a copy and update the name
                processed_item = item.copy()
                processed_item["description"] = capitalized_name
                processed_results.append(processed_item)

        return processed_results

    def _capitalize_food_name(self, name: str) -> str:
        """
        Properly capitalize food names.
        Examples:
        - "CHICKEN BREAST" -> "Chicken Breast"
        - "chicken breast" -> "Chicken Breast"
        - "CHICKEN BREAST, BONELESS" -> "Chicken Breast, Boneless"
        """
        if not name:
            return name

        # Split by common separators and capitalize each part
        parts = []
        for part in name.split(','):
            # Capitalize each word in the part
            words = []
            for word in part.strip().split():
                # Handle special cases for common food terms
                word_lower = word.lower()
                if word_lower in ['and', 'or', 'with', 'in', 'on', 'of', 'the', 'a', 'an']:
                    # Keep articles and prepositions lowercase unless they're the first word
                    words.append(word_lower if words else word.capitalize())
                else:
                    words.append(word.capitalize())

            if words:
                parts.append(' '.join(words))

        return ', '.join(parts)
</file>

<file path="src/app/queries/activity/__init__.py">
"""Activity queries."""
from .get_daily_activities_query import GetDailyActivitiesQuery

__all__ = [
    "GetDailyActivitiesQuery",
]
</file>

<file path="src/app/queries/activity/get_daily_activities_query.py">
"""
Get daily activities query.
"""
from dataclasses import dataclass
from datetime import datetime

from src.app.events.base import Query


@dataclass
class GetDailyActivitiesQuery(Query):
    """Query to get all activities for a specific date and user."""
    user_id: str
    target_date: datetime
</file>

<file path="src/app/queries/daily_meal/__init__.py">
"""Daily meal queries."""
from .get_meal_planning_summary_query import GetMealPlanningSummaryQuery
from .get_meal_suggestions_for_profile_query import GetMealSuggestionsForProfileQuery
from .get_single_meal_for_profile_query import GetSingleMealForProfileQuery

__all__ = [
    "GetMealSuggestionsForProfileQuery",
    "GetSingleMealForProfileQuery",
    "GetMealPlanningSummaryQuery",
]
</file>

<file path="src/app/queries/daily_meal/get_meal_planning_summary_query.py">
"""
Get meal planning summary query.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetMealPlanningSummaryQuery(Query):
    """Query to get meal planning summary for a profile."""
    user_profile_id: str
</file>

<file path="src/app/queries/daily_meal/get_meal_suggestions_for_profile_query.py">
"""
Get meal suggestions for profile query.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetMealSuggestionsForProfileQuery(Query):
    """Query to get meal suggestions for a user profile."""
    user_profile_id: str
</file>

<file path="src/app/queries/daily_meal/get_single_meal_for_profile_query.py">
"""
Get single meal for profile query.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetSingleMealForProfileQuery(Query):
    """Query to get a single meal suggestion for a profile."""
    user_profile_id: str
    meal_type: str
</file>

<file path="src/app/queries/food/get_food_details_query.py">
"""
Query to get detailed nutrition by FDC ID.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetFoodDetailsQuery(Query):
    fdc_id: int
</file>

<file path="src/app/queries/food/search_foods_query.py">
"""
Query to search foods via external database (USDA FDC).
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class SearchFoodsQuery(Query):
    query: str
    limit: int = 20
</file>

<file path="src/app/queries/meal/__init__.py">
"""
Meal queries.
"""
from .get_daily_macros_query import GetDailyMacrosQuery
from .get_meal_by_id_query import GetMealByIdQuery

__all__ = [
    "GetMealByIdQuery",
    "GetDailyMacrosQuery",
]
</file>

<file path="src/app/queries/meal/get_daily_macros_query.py">
"""
Get daily macros query.
"""
from dataclasses import dataclass
from datetime import date
from typing import Optional

from src.app.events.base import Query


@dataclass
class GetDailyMacrosQuery(Query):
    """Query to get daily macros summary with user targets."""
    user_id: str
    target_date: Optional[date] = None
</file>

<file path="src/app/queries/meal/get_meal_by_id_query.py">
"""
Get meal by ID query.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetMealByIdQuery(Query):
    """Query to get a meal by ID."""
    meal_id: str
</file>

<file path="src/app/queries/meal_plan/get_meal_plan_query.py">
"""
Get meal plan query.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetMealPlanQuery(Query):
    """Query to get a meal plan."""
    plan_id: str
</file>

<file path="src/app/queries/meal_plan/get_meals_by_date_query.py">
"""
Query for getting meals by specific date.
"""
from dataclasses import dataclass
from datetime import date

from src.app.events.base import Query


@dataclass
class GetMealsByDateQuery(Query):
    """Query for getting meals for a specific date."""
    user_id: str
    meal_date: date
</file>

<file path="src/app/queries/tdee/__init__.py">
"""
TDEE query commands.
"""
from .get_user_tdee_query import GetUserTdeeQuery

__all__ = [
    'GetUserTdeeQuery'
]
</file>

<file path="src/app/queries/tdee/get_user_tdee_query.py">
"""
Query to get user's TDEE calculation data.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetUserTdeeQuery(Query):
    """Query to get user's current TDEE calculation."""
    user_id: str
</file>

<file path="src/app/queries/user/get_user_profile_query.py">
"""
Get user profile query.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetUserProfileQuery(Query):
    """Query to get user profile."""
    user_id: str
</file>

<file path="src/app/queries/__init__.py">
"""
Query definitions for CQRS pattern.
"""
# Import from activity module
from .activity import (
    GetDailyActivitiesQuery,
)
# Import from daily_meal module
from .daily_meal import (
    GetMealSuggestionsForProfileQuery,
    GetSingleMealForProfileQuery,
    GetMealPlanningSummaryQuery,
)
# Import from meal module
from .meal import (
    GetDailyMacrosQuery,
    GetMealByIdQuery,
)
# Import from meal_plan module
from .meal_plan import (
    GetMealPlanQuery,
)
# Import from tdee module
# No TDEE queries imported - all removed
# Import from user module
from .user import (
    GetUserProfileQuery,
)

__all__ = [
    # Meal queries
    "GetDailyMacrosQuery",
    "GetMealByIdQuery",
    # Daily meal queries
    "GetMealSuggestionsForProfileQuery",
    "GetSingleMealForProfileQuery",
    "GetMealPlanningSummaryQuery",
    # User queries
    "GetUserProfileQuery",
    # Meal plan queries
    "GetMealPlanQuery",
    # Activity queries
    "GetDailyActivitiesQuery",
]
</file>

<file path="src/domain/constants/__init__.py">
"""
Domain constants and configuration values.

This package centralizes all constants, magic numbers, and configuration
values used throughout the domain layer.
"""
from .meal_constants import (
    MealDistribution,
    NutritionConstants,
    PortionUnits,
    GPTPromptConstants,
    MealPlanningConstants,
    TDEEConstants,
    ConversationConstants
)

__all__ = [
    'MealDistribution',
    'NutritionConstants',
    'PortionUnits',
    'GPTPromptConstants',
    'MealPlanningConstants',
    'TDEEConstants',
    'ConversationConstants'
]
</file>

<file path="src/domain/parsers/__init__.py">
"""
Domain parsers for external data.

This package contains parsers for converting external data formats
(like GPT responses) into domain models.
"""
from .gpt_response_parser import GPTResponseParser, GPTResponseParsingError

__all__ = [
    'GPTResponseParser',
    'GPTResponseParsingError'
]
</file>

<file path="src/domain/ports/__init__.py">
"""Domain ports package."""

from src.domain.ports.image_store_port import ImageStorePort
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.domain.ports.vision_ai_service_port import VisionAIServicePort

__all__ = [
    'MealRepositoryPort', 
    'ImageStorePort', 
    'VisionAIServicePort'
]
</file>

<file path="src/domain/ports/food_cache_service_port.py">
from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional


class FoodCacheServicePort(ABC):
    """
    Port interface for caching food provider responses.

    Used to reduce external API calls by caching search results and individual
    food detail payloads for a bounded time (TTL).
    """

    @abstractmethod
    async def get_cached_search(self, query: str) -> Optional[List[Dict[str, Any]]]:
        """
        Retrieve cached search results for the given query if available and valid.

        Args:
            query: The exact search string used for provider lookup.

        Returns:
            A list of provider-native search result dictionaries or None if missing/expired.
        """
        pass

    @abstractmethod
    async def cache_search(self, query: str, results: List[Dict[str, Any]], ttl: int = 3600):
        """
        Store search results for a given query with a time-to-live.

        Args:
            query: The exact search string.
            results: Provider-native search results to cache.
            ttl: Time-to-live in seconds (default: 3600).
        """
        pass

    @abstractmethod
    async def get_cached_food(self, fdc_id: int) -> Optional[Dict[str, Any]]:
        """
        Retrieve cached food details by provider ID if available and valid.

        Args:
            fdc_id: Provider food identifier (FDC ID).

        Returns:
            Provider-native details dictionary or None if missing/expired.
        """
        pass

    @abstractmethod
    async def cache_food(self, fdc_id: int, food_data: Dict[str, Any], ttl: int = 86400):
        """
        Store food details payload for a given ID with a time-to-live.

        Args:
            fdc_id: Provider food identifier.
            food_data: Provider-native details dictionary to cache.
            ttl: Time-to-live in seconds (default: 86400).
        """
        pass
</file>

<file path="src/domain/ports/food_data_service_port.py">
from abc import ABC, abstractmethod
from typing import Any, Dict, List


class FoodDataServicePort(ABC):
    """
    Port interface for external food data providers (e.g., USDA FoodData Central).

    Responsible for network-bound lookups of food search results and detailed
    nutrition data, returning provider-native payloads for a separate mapping layer
    to transform.
    """

    @abstractmethod
    async def search_foods(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        """
        Search foods by a free-text query.

        Args:
            query: Search terms entered by the user (e.g., "chicken breast").
            limit: Maximum number of results to return (default: 20).

        Returns:
            A list of provider-native search result dictionaries.

        Raises:
            Exception: If the provider returns an error or the request fails.
        """
        pass

    @abstractmethod
    async def get_food_details(self, fdc_id: int) -> Dict[str, Any]:
        """
        Get detailed nutrient information for a single food item.

        Args:
            fdc_id: Provider food identifier (USDA FDC ID).

        Returns:
            A provider-native details dictionary including nutrients and portions.

        Raises:
            Exception: If the provider returns an error or the request fails.
        """
        pass

    @abstractmethod
    async def get_multiple_foods(self, fdc_ids: List[int]) -> List[Dict[str, Any]]:
        """
        Batch fetch multiple foods by their provider IDs.

        Args:
            fdc_ids: List of provider food identifiers (FDC IDs).

        Returns:
            A list of provider-native details dictionaries, one per ID.

        Raises:
            Exception: If the provider returns an error or the request fails.
        """
        pass
</file>

<file path="src/domain/ports/food_mapping_service_port.py">
from abc import ABC, abstractmethod
from typing import Any, Dict


class FoodMappingServicePort(ABC):
    """
    Port interface for transforming provider payloads into internal models.

    This layer isolates mapping logic and normalization rules (nutrient ID
    mapping, serving normalization, field renaming) from consumers.
    """

    @abstractmethod
    def map_search_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        """
        Transform a provider-native search result item into a simplified dict
        used by the API/application layer.

        Args:
            item: Provider-native search result dictionary.

        Returns:
            A simplified dictionary containing keys like fdc_id, name, brand, data_type.
        """
        pass

    @abstractmethod
    def map_food_details(self, details: Dict[str, Any]) -> Dict[str, Any]:
        """
        Transform provider-native food details into a dict capturing serving,
        calories and macro nutrients with normalized names.

        Args:
            details: Provider-native food details dictionary.

        Returns:
            A simplified dictionary with keys: fdc_id, name, brand, serving_size,
            serving_unit, calories, macros, portions.
        """
        pass
</file>

<file path="src/domain/ports/image_store_port.py">
from abc import ABC, abstractmethod
from typing import Optional

class ImageStorePort(ABC):
    """Port interface for image storage operations."""
    
    @abstractmethod
    def save(self, image_bytes: bytes, content_type: str) -> str:
        """
        Saves image bytes to storage.
        
        Args:
            image_bytes: The raw bytes of the image
            content_type: MIME type of the image ("image/jpeg" or "image/png")
            
        Returns:
            A unique image ID (UUID string)
            
        Raises:
            ValueError: If content_type is not supported or image is invalid
        """
        pass
    
    @abstractmethod
    def load(self, image_id: str) -> Optional[bytes]:
        """
        Loads image bytes by ID.
        
        Args:
            image_id: The ID of the image to load
            
        Returns:
            The raw bytes of the image if found, None otherwise
        """
        pass
    
    @abstractmethod
    def get_url(self, image_id: str) -> Optional[str]:
        """
        Gets a URL for accessing the image, if applicable.
        
        Args:
            image_id: The ID of the image
            
        Returns:
            URL to access the image if available, None otherwise
        """
        pass
    
    @abstractmethod
    def delete(self, image_id: str) -> bool:
        """
        Deletes an image by ID.
        
        Args:
            image_id: The ID of the image to delete
            
        Returns:
            True if deleted successfully, False otherwise
        """
        pass
</file>

<file path="src/domain/ports/meal_generation_service_port.py">
"""
Port for meal generation services following clean architecture.
Single LLM service that handles different prompts and request data.
"""
from abc import ABC, abstractmethod
from typing import Dict, Any


class MealGenerationServicePort(ABC):
    """Unified port for all meal generation using single LLM with different prompts."""
    
    @abstractmethod
    def generate_meal_plan(self, prompt: str, system_message: str, response_type: str = "json") -> Dict[str, Any]:
        """
        Generate meal plan using provided prompt and system message.
        
        Args:
            prompt: The meal generation prompt
            system_message: System message for the LLM
            response_type: Expected response type ("json" or "text")
            
        Returns:
            Generated meal plan data
        """
        pass
</file>

<file path="src/domain/ports/meal_repository_port.py">
from abc import ABC, abstractmethod
from typing import List, Optional

from src.domain.model.meal import Meal, MealStatus


class MealRepositoryPort(ABC):
    """Port interface for meal persistence operations."""
    
    @abstractmethod
    def save(self, meal: Meal) -> Meal:
        """
        Persists a meal entity.
        
        Args:
            meal: The meal to be saved
            
        Returns:
            The saved meal with any generated IDs
        """
        pass
    
    @abstractmethod
    def find_by_id(self, meal_id: str) -> Optional[Meal]:
        """
        Finds a meal by its ID.
        
        Args:
            meal_id: The ID of the meal to find
            
        Returns:
            The meal if found, None otherwise
        """
        pass
    
    @abstractmethod
    def find_by_status(self, status: MealStatus, limit: int = 10) -> List[Meal]:
        """
        Finds meals by status.
        
        Args:
            status: The status to filter by
            limit: Maximum number of results
            
        Returns:
            List of meals with the specified status
        """
        pass
    
    @abstractmethod
    def find_all_paginated(self, offset: int = 0, limit: int = 20) -> List[Meal]:
        """
        Retrieves all meals with pagination.
        
        Args:
            offset: Pagination offset
            limit: Maximum number of results
            
        Returns:
            Paginated list of meals
        """
        pass
    
    @abstractmethod
    def count(self) -> int:
        """
        Counts the total number of meals.
        
        Returns:
            Total count
        """
        pass
    
    @abstractmethod
    def find_by_date(self, date, user_id: str = None, limit: int = 50) -> List[Meal]:
        """
        Finds meals created on a specific date, optionally filtered by user.
        
        Args:
            date: The date to filter by (date object)
            user_id: Optional user ID to filter meals by specific user
            limit: Maximum number of results
            
        Returns:
            List of meals created on the specified date
        """
        pass
</file>

<file path="src/domain/ports/vision_ai_service_port.py">
from abc import ABC, abstractmethod
from typing import Dict, Any, List


class VisionAIServicePort(ABC):
    """
    Port interface for AI vision services that can analyze food images.
    
    This port is used by the application layer to interact with vision AI services
    like OpenAI Vision API.
    """
    
    @abstractmethod
    def analyze(self, image_bytes: bytes) -> Dict[str, Any]:
        """
        Analyze a food image to extract nutritional information.
        
        Args:
            image_bytes: The raw bytes of the image to analyze
            
        Returns:
            JSON-compatible dictionary with the raw AI response
            
        Raises:
            RuntimeError: If analysis fails
        """
        pass

    @abstractmethod
    def analyze_with_ingredients_context(self, image_bytes: bytes, ingredients: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Analyze a food image to extract nutritional information.

        Args:
            image_bytes: The raw bytes of the image to analyze

        Returns:
            JSON-compatible dictionary with the raw AI response

        Raises:
            RuntimeError: If analysis fails
            :param image_bytes:
            :param ingredients:
        """
        pass

    @abstractmethod
    def analyze_with_portion_context(self, image_bytes: bytes, portion_size: float, unit: str) -> Dict[str, Any]:
        """
        Analyze a food image to extract nutritional information.

        Args:
            image_bytes: The raw bytes of the image to analyze

        Returns:
            JSON-compatible dictionary with the raw AI response

        Raises:
            RuntimeError: If analysis fails
            :param image_bytes:
            :param unit:
            :param portion_size:
        """
        pass

    @abstractmethod
    def analyze_with_weight_context(self, image_bytes: bytes, weight_grams: float) -> Dict[str, Any]:
        """
        Analyze a food image with specific weight context for accurate nutrition.

        Args:
            image_bytes: The raw bytes of the image to analyze
            weight_grams: The target weight in grams

        Returns:
            JSON-compatible dictionary with the raw AI response

        Raises:
            RuntimeError: If analysis fails
        """
        pass
</file>

<file path="src/domain/prompts/weekly_meal_plan_prompt.py">
"""
Prompt templates for weekly meal plan generation.
"""
from typing import Dict, Any


def build_weekly_ingredient_based_prompt(request: Dict[str, Any]) -> str:
    """Build optimized prompt for weekly ingredient-based meal plans."""
    ing = ", ".join(request.get("available_ingredients", [])) or "(any)"
    season = ", ".join(request.get("available_seasonings", [])) or "basic spices"
    dietary_prefs = request.get("dietary_preferences", [])
    meals_per_day = request.get("meals_per_day", 3)
    include_snacks = request.get("include_snacks", False)
    target_calories = request.get("target_calories", 2000)
    
    # Define meal types based on configuration
    meal_types = ["breakfast", "lunch", "dinner"]
    if meals_per_day == 4:
        meal_types.append("lunch")  # Add second lunch or brunch
    
    snack_requirement = ""
    if include_snacks:
        meal_types.append("snack")
        snack_requirement = "\n6. Include 1 healthy snack per day."
    
    schema = (
        '{"week":[{"day":"Monday","meals":[{"meal_type":"breakfast","name":"…",'
        '"description":"…","calories":450,"protein":25.0,"carbs":55.0,"fat":15.0,'
        '"prep_time":10,"cook_time":15,"ingredients":["…"],"instructions":["…"],'
        '"is_vegetarian":true,"is_vegan":false,"is_gluten_free":false,"cuisine_type":"International"}]},'
        '{"day":"Tuesday","meals":[]}, "…"]}'
    )

    dietary_requirements = ""
    if dietary_prefs:
        dietary_requirements = f"\nDietary preferences: {', '.join(dietary_prefs)}"

    calorie_guidance = f"\nDaily target: ~{target_calories} calories total per day"

    return (
        f"Generate a concise 7-day meal plan (Monday-Sunday) using only available ingredients.\n"
        f"Ingredients: {ing}\n"
        f"Seasonings: {season}{dietary_requirements}{calorie_guidance}\n"
        f"Meal types required: {', '.join(meal_types)}\n"
        "Rules:\n"
        "1. Use ONLY listed ingredients - no exceptions.\n"
        "2. Generate exactly 3 main meals per day" + (" + 1 snack" if include_snacks else "") + ".\n"
        "3. Each meal must have: meal_type, name, description, calories, protein, carbs, fat, prep_time, cook_time, ingredients, instructions, is_vegetarian, is_vegan, is_gluten_free, cuisine_type.\n"
        "4. Accurate nutritional values and dietary flags.\n"
        "5. Keep instructions concise (3-5 steps max)." + snack_requirement + "\n"
        f"Output ONLY valid JSON:\n{schema}"
    )


def get_system_message() -> str:
    """Get optimized system message for meal planning."""
    return "Meal planner. JSON only, no markdown."
</file>

<file path="src/domain/services/meal_plan_conversation_service.py">
"""
Meal plan conversation service for managing conversational meal planning.
"""
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)


class MealPlanConversationService:
    """Service for managing meal planning conversations."""
    
    def __init__(self):
        # In-memory storage for conversations (should be replaced with persistent storage)
        self._conversations: Dict[str, Dict[str, Any]] = {}
    
    def start_conversation(self, conversation_id: str, user_id: str) -> Dict[str, Any]:
        """Start a new meal planning conversation."""
        conversation = {
            "conversation_id": conversation_id,
            "user_id": user_id,
            "state": "gathering_preferences",
            "messages": [],
            "preferences": {
                "dietary_preferences": [],
                "health_conditions": [],
                "excluded_ingredients": [],
                "preferred_cuisines": [],
                "meals_per_day": None,
                "days": None,
                "calories_target": None
            },
            "current_question": "preferences"
        }
        
        self._conversations[conversation_id] = conversation
        logger.info(f"Started conversation {conversation_id} for user {user_id}")
        
        return conversation
    
    def get_initial_message(self) -> str:
        """Get the initial greeting message."""
        return (
            "Hi! I'm here to help you create a personalized meal plan. "
            "To get started, could you tell me about any dietary preferences "
            "or restrictions you have? (e.g., vegetarian, gluten-free, nut allergies)"
        )
    
    def process_message(self, conversation_id: str, message: str) -> Dict[str, Any]:
        """Process a user message in the conversation."""
        conversation = self._conversations.get(conversation_id)
        
        if not conversation:
            raise ValueError(f"Conversation {conversation_id} not found")
        
        # Add message to history
        conversation["messages"].append({
            "role": "user",
            "content": message
        })
        
        # Process based on current state
        response = self._process_based_on_state(conversation, message)
        
        # Add assistant response to history
        conversation["messages"].append({
            "role": "assistant",
            "content": response["assistant_message"]
        })
        
        return response
    
    def get_conversation(self, conversation_id: str) -> Optional[Dict[str, Any]]:
        """Get conversation details."""
        return self._conversations.get(conversation_id)
    
    def _process_based_on_state(self, conversation: Dict[str, Any], message: str) -> Dict[str, Any]:
        """Process message based on conversation state."""
        state = conversation["state"]
        
        if state == "gathering_preferences":
            return self._handle_preferences(conversation, message)
        elif state == "gathering_goals":
            return self._handle_goals(conversation, message)
        elif state == "gathering_details":
            return self._handle_details(conversation, message)
        elif state == "complete":
            return {
                "state": "complete",
                "assistant_message": "Your meal plan is ready! You can view it in the meal plans section.",
                "requires_input": False,
                "preferences": conversation["preferences"]
            }
        
        return {
            "state": state,
            "assistant_message": "I didn't understand that. Could you please clarify?",
            "requires_input": True
        }
    
    def _handle_preferences(self, conversation: Dict[str, Any], message: str) -> Dict[str, Any]:
        """Handle dietary preferences gathering."""
        # Simple keyword extraction (in production, use NLP)
        message_lower = message.lower()
        
        dietary_keywords = {
            "vegetarian": "vegetarian",
            "vegan": "vegan",
            "gluten-free": "gluten-free",
            "gluten free": "gluten-free",
            "dairy-free": "dairy-free",
            "dairy free": "dairy-free",
            "keto": "keto",
            "low-carb": "low-carb",
            "low carb": "low-carb"
        }
        
        # Extract preferences
        for keyword, preference in dietary_keywords.items():
            if keyword in message_lower:
                if preference not in conversation["preferences"]["dietary_preferences"]:
                    conversation["preferences"]["dietary_preferences"].append(preference)
        
        # Check for allergies
        if any(word in message_lower for word in ["allergy", "allergic", "intolerant"]):
            if "nut" in message_lower:
                conversation["preferences"]["excluded_ingredients"].append("nuts")
            if "shellfish" in message_lower:
                conversation["preferences"]["excluded_ingredients"].append("shellfish")
            if "dairy" in message_lower:
                conversation["preferences"]["excluded_ingredients"].append("dairy")
        
        # Move to next state
        conversation["state"] = "gathering_goals"
        
        return {
            "state": "gathering_goals",
            "assistant_message": (
                "Great! Now, what's your main health or fitness goal? "
                "(e.g., lose weight, gain muscle, maintain current weight, improve energy)"
            ),
            "requires_input": True
        }
    
    def _handle_goals(self, conversation: Dict[str, Any], message: str) -> Dict[str, Any]:
        """Handle fitness goals gathering."""
        message_lower = message.lower()
        
        # Map goals
        if any(word in message_lower for word in ["lose", "weight loss", "cut"]):
            conversation["preferences"]["fitness_goal"] = "weight_loss"
        elif any(word in message_lower for word in ["gain", "muscle", "bulk"]):
            conversation["preferences"]["fitness_goal"] = "muscle_gain"
        elif any(word in message_lower for word in ["maintain", "maintenance"]):
            conversation["preferences"]["fitness_goal"] = "maintenance"
        else:
            conversation["preferences"]["fitness_goal"] = "general_health"
        
        # Move to details
        conversation["state"] = "gathering_details"
        
        return {
            "state": "gathering_details",
            "assistant_message": (
                "Perfect! One last thing - how many days would you like me to plan for? "
                "(e.g., 1 day, 3 days, 7 days)"
            ),
            "requires_input": True
        }
    
    def _handle_details(self, conversation: Dict[str, Any], message: str) -> Dict[str, Any]:
        """Handle meal plan details."""
        message_lower = message.lower()
        
        # Extract days
        if "1" in message or "one" in message_lower:
            conversation["preferences"]["days"] = 1
        elif "3" in message or "three" in message_lower:
            conversation["preferences"]["days"] = 3
        elif "7" in message or "seven" in message_lower or "week" in message_lower:
            conversation["preferences"]["days"] = 7
        else:
            conversation["preferences"]["days"] = 3  # Default
        
        # Mark as complete
        conversation["state"] = "complete"
        conversation["preferences"]["user_id"] = conversation["user_id"]
        
        return {
            "state": "complete",
            "assistant_message": (
                f"Excellent! I'll create a {conversation['preferences']['days']}-day meal plan "
                f"that's {', '.join(conversation['preferences']['dietary_preferences']) if conversation['preferences']['dietary_preferences'] else 'balanced'} "
                f"and aligned with your {conversation['preferences'].get('fitness_goal', 'health')} goals. "
                "Your personalized meal plan is being generated now!"
            ),
            "requires_input": False,
            "preferences": conversation["preferences"],
            "user_id": conversation["user_id"]
        }
</file>

<file path="src/domain/services/weekly_ingredient_based_meal_plan_service.py">
"""
Weekly ingredient-based meal plan service.
Uses the unified orchestration service.
"""
import logging
from typing import Any, Dict

from src.domain.services.meal_plan_orchestration_service import MealPlanOrchestrationService
from src.infra.adapters.meal_generation_service import MealGenerationService

logger = logging.getLogger(__name__)


class WeeklyIngredientBasedMealPlanService:
    """
    Service for generating weekly ingredient-based meal plans.
    Delegates to unified orchestration service.
    """

    def __init__(self) -> None:
        meal_generation_service = MealGenerationService()
        self.orchestration_service = MealPlanOrchestrationService(meal_generation_service)

    def generate_weekly_meal_plan(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Generate weekly meal plan using orchestration service."""
        return self.orchestration_service.generate_weekly_ingredient_based_plan(request)
</file>

<file path="src/domain/strategies/__init__.py">
"""
Domain strategies for meal analysis.

This package contains strategy pattern implementations for different
types of meal analysis approaches.
"""
from .meal_analysis_strategy import (
    MealAnalysisStrategy,
    BasicAnalysisStrategy,
    PortionAwareAnalysisStrategy,
    IngredientAwareAnalysisStrategy,
    WeightAwareAnalysisStrategy,
    AnalysisStrategyFactory
)

__all__ = [
    'MealAnalysisStrategy',
    'BasicAnalysisStrategy',
    'PortionAwareAnalysisStrategy',
    'IngredientAwareAnalysisStrategy',
    'WeightAwareAnalysisStrategy',
    'AnalysisStrategyFactory'
]
</file>

<file path="src/infra/adapters/food_data_service.py">
"""
USDA FoodData Central HTTP client. Real implementation would call external API; this is a thin wrapper.
"""
import os
from typing import Dict, Any, List, Optional

import requests

from src.domain.ports.food_data_service_port import FoodDataServicePort


class FoodDataService(FoodDataServicePort):
    BASE_URL = "https://api.nal.usda.gov/fdc/v1"

    def __init__(self, api_key: Optional[str] = None, session: Optional[requests.Session] = None):
        self.api_key = api_key or os.getenv("USDA_FDC_API_KEY", "")
        self.session = session or requests.Session()

    def _get(self, path: str, params: Dict[str, Any]) -> Dict[str, Any]:
        params = {**params, "api_key": self.api_key}
        resp = self.session.get(f"{self.BASE_URL}{path}", params=params, timeout=10)
        resp.raise_for_status()
        return resp.json()

    async def search_foods(self, query: str, limit: int = 20) -> List[Dict[str, Any]]:
        # For simplicity in tests, this won't be called. Kept for completeness.
        data = self._get("/foods/search", {"query": query, "pageSize": limit})
        return data.get("foods", [])

    async def get_food_details(self, fdc_id: int) -> Dict[str, Any]:
        return self._get(f"/food/{fdc_id}", {})

    async def get_multiple_foods(self, fdc_ids: List[int]) -> List[Dict[str, Any]]:
        # Batch endpoint; many accounts need POST. To keep simple, call individually.
        return [await self.get_food_details(fid) for fid in fdc_ids]
</file>

<file path="src/infra/adapters/image_store.py">
import os
import uuid
from typing import Optional

from dotenv import load_dotenv

from src.domain.ports.image_store_port import ImageStorePort

# Load environment variables if not already loaded
load_dotenv()

# For development/testing, can use a mock storage instead
USE_MOCK_STORAGE = bool(int(os.getenv("USE_MOCK_STORAGE", "1")))
UPLOAD_DIR = "uploads"

class ImageStore(ImageStorePort):
    """
    Implementation of ImageStorePort using a local file store for development.
    
    This class implements US-1.3 - Save the raw image bytes securely.
    """
    
    def __init__(self):
        """Initialize the image store."""
        if USE_MOCK_STORAGE and not os.path.exists(UPLOAD_DIR):
            os.makedirs(UPLOAD_DIR)
    
    def save(self, image_bytes: bytes, content_type: str) -> str:
        """
        Save image bytes to storage.
        
        Args:
            image_bytes: The raw bytes of the image
            content_type: MIME type of the image ("image/jpeg" or "image/png")
            
        Returns:
            A unique image ID (UUID string)
            
        Raises:
            ValueError: If content_type is not supported or image is invalid
        """
        # Validate content type
        if content_type not in ["image/jpeg", "image/png"]:
            raise ValueError(f"Unsupported content type: {content_type}")
        
        # Generate a deterministic UUID for the image
        image_id = str(uuid.uuid4())
        
        # For development, save locally
        extension = "jpg" if content_type == "image/jpeg" else "png"
        file_path = os.path.join(UPLOAD_DIR, f"{image_id}.{extension}")
        
        with open(file_path, "wb") as f:
            f.write(image_bytes)
        
        return image_id
    
    def load(self, image_id: str) -> Optional[bytes]:
        """
        Load image bytes by ID.
        
        Args:
            image_id: The ID of the image to load
            
        Returns:
            The raw bytes of the image if found, None otherwise
        """
        # Try both jpg and png extensions
        for ext in ["jpg", "png"]:
            file_path = os.path.join(UPLOAD_DIR, f"{image_id}.{ext}")
            if os.path.exists(file_path):
                with open(file_path, "rb") as f:
                    return f.read()
        return None
    
    def get_url(self, image_id: str) -> Optional[str]:
        """
        Gets a URL for accessing the image.
        
        Args:
            image_id: The ID of the image
            
        Returns:
            URL to access the image if available, None otherwise
        """
        # For local development, construct a path-based URL
        # This would typically point to a local development server
        for ext in ["jpg", "png"]:
            file_path = os.path.join(UPLOAD_DIR, f"{image_id}.{ext}")
            if os.path.exists(file_path):
                return f"/uploads/{image_id}.{ext}"
        return None
    
    def delete(self, image_id: str) -> bool:
        """
        Delete an image by ID.
        
        Args:
            image_id: The ID of the image to delete
            
        Returns:
            True if deleted successfully, False otherwise
        """
        # Try to delete local file
        for ext in ["jpg", "png"]:
            file_path = os.path.join(UPLOAD_DIR, f"{image_id}.{ext}")
            if os.path.exists(file_path):
                os.remove(file_path)
                return True
        return False
</file>

<file path="src/infra/adapters/mock_image_store.py">
"""
Mock Image Store for testing.
"""
import uuid
from typing import Dict, Optional

from src.domain.ports.image_store_port import ImageStorePort


class MockImageStore(ImageStorePort):
    """Mock implementation of image store for testing."""
    
    def __init__(self):
        """Initialize with in-memory storage."""
        self.storage: Dict[str, bytes] = {}
    
    def save(self, image_data: bytes, content_type: str) -> str:
        """Save image data and return image ID."""
        image_id = str(uuid.uuid4())
        self.storage[image_id] = image_data
        return image_id
    
    def load(self, image_id: str) -> Optional[bytes]:
        """Load image data from storage."""
        # Extract ID from mock URL if needed
        if image_id.startswith("mock://images/"):
            image_id = image_id.replace("mock://images/", "")
        return self.storage.get(image_id)
    
    def delete(self, image_id: str) -> bool:
        """Delete image from storage."""
        if image_id in self.storage:
            del self.storage[image_id]
            return True
        return False
    
    def get_url(self, image_id: str) -> str:
        """Get mock URL for image."""
        return f"mock://images/{image_id}"
</file>

<file path="src/infra/database/models/conversation/__init__.py">
"""Conversation-related database models."""
from .conversation import Conversation
from .message import ConversationMessage

__all__ = [
    "Conversation",
    "ConversationMessage",
]
</file>

<file path="src/infra/database/models/conversation/conversation.py">
"""
Conversation model for tracking chat conversations with users.
"""
from sqlalchemy import Column, String, JSON, Enum
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin
from src.infra.database.models.enums import ConversationStateEnum


class Conversation(Base, BaseMixin):
    """Tracks chat conversations and their state."""
    __tablename__ = "conversations"
    
    user_id = Column(String(255), nullable=False, index=True)
    state = Column(Enum(ConversationStateEnum), nullable=False)
    
    # Conversation context stored as JSON
    context = Column(JSON)
    
    # Relationships
    messages = relationship("ConversationMessage", back_populates="conversation", cascade="all, delete-orphan")
</file>

<file path="src/infra/database/models/conversation/message.py">
"""
Conversation message model for individual messages within a conversation.
"""
from sqlalchemy import Column, String, Text, JSON, ForeignKey
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import SecondaryEntityMixin


class ConversationMessage(Base, SecondaryEntityMixin):
    """Individual messages within a conversation."""
    __tablename__ = "conversation_messages"
    
    conversation_id = Column(String(36), ForeignKey("conversations.id"), nullable=False)
    role = Column(String(20), nullable=False)  # user, assistant, system
    content = Column(Text, nullable=False)
    message_metadata = Column(JSON)
    
    # Relationships
    conversation = relationship("Conversation", back_populates="messages")
</file>

<file path="src/infra/database/models/meal/__init__.py">
"""Meal-related database models."""
from .meal import Meal
from .meal_image import MealImage

__all__ = [
    "Meal",
    "MealImage",
]
</file>

<file path="src/infra/database/models/meal_planning/__init__.py">
"""Meal planning-related database models."""
from .meal_plan import MealPlan
from .meal_plan_day import MealPlanDay
from .planned_meal import PlannedMeal

__all__ = [
    "MealPlan",
    "MealPlanDay",
    "PlannedMeal",
]
</file>

<file path="src/infra/database/models/meal_planning/meal_plan_day.py">
"""
Meal plan day model for individual days within a meal plan.
"""
from sqlalchemy import Column, String, Date, ForeignKey
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import SecondaryEntityMixin


class MealPlanDay(Base, SecondaryEntityMixin):
    """Represents a single day within a meal plan."""
    __tablename__ = "meal_plan_days"
    
    meal_plan_id = Column(String(36), ForeignKey("meal_plans.id"), nullable=False)
    date = Column(Date, nullable=False)
    
    # Relationships
    meal_plan = relationship("MealPlan", back_populates="days")
    meals = relationship("PlannedMeal", back_populates="day", cascade="all, delete-orphan")
</file>

<file path="src/infra/database/models/meal_planning/meal_plan.py">
"""
Meal plan model for storing user meal planning preferences and settings.
"""
from sqlalchemy import Column, String, Integer, JSON, Enum
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin
from src.infra.database.models.enums import FitnessGoalEnum, PlanDurationEnum


class MealPlan(Base, BaseMixin):
    """Main meal plan entity storing user preferences and settings."""
    __tablename__ = "meal_plans"
    
    user_id = Column(String(255), nullable=False, index=True)
    
    # User preferences stored as JSON
    dietary_preferences = Column(JSON)
    allergies = Column(JSON)
    fitness_goal = Column(Enum(FitnessGoalEnum))
    meals_per_day = Column(Integer)
    snacks_per_day = Column(Integer)
    cooking_time_weekday = Column(Integer)
    cooking_time_weekend = Column(Integer)
    favorite_cuisines = Column(JSON)
    disliked_ingredients = Column(JSON)
    plan_duration = Column(Enum(PlanDurationEnum))
    
    # Relationships
    days = relationship("MealPlanDay", back_populates="meal_plan", cascade="all, delete-orphan")
</file>

<file path="src/infra/database/models/meal_planning/planned_meal.py">
"""
Planned meal model for individual meals within a meal plan day.
"""
from sqlalchemy import Column, String, Integer, Float, Boolean, Text, JSON, Enum, ForeignKey
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import SecondaryEntityMixin
from src.infra.database.models.enums import MealTypeEnum


class PlannedMeal(Base, SecondaryEntityMixin):
    """Represents a planned meal within a meal plan day."""
    __tablename__ = "planned_meals"
    
    day_id = Column(Integer, ForeignKey("meal_plan_days.id"), nullable=False)
    meal_type = Column(Enum(MealTypeEnum), nullable=False)
    
    name = Column(String(255), nullable=False)
    description = Column(Text)
    prep_time = Column(Integer)  # minutes
    cook_time = Column(Integer)  # minutes
    
    # Nutrition info
    calories = Column(Integer)
    protein = Column(Float)
    carbs = Column(Float)
    fat = Column(Float)
    
    # Stored as JSON arrays - ingredients now include portions
    ingredients = Column(JSON)  # ["2 cups rice", "1 lb chicken breast", "1 tablespoon olive oil"]
    seasonings = Column(JSON)   # ["1 teaspoon salt", "1/2 teaspoon black pepper", "1 tablespoon oregano"]
    instructions = Column(JSON)
    
    # Dietary flags
    is_vegetarian = Column(Boolean, default=False)
    is_vegan = Column(Boolean, default=False)
    is_gluten_free = Column(Boolean, default=False)
    
    cuisine_type = Column(String(100))
    
    # Relationships
    day = relationship("MealPlanDay", back_populates="meals")
</file>

<file path="src/infra/database/models/nutrition/__init__.py">
"""Nutrition-related database models."""
from .food_item import FoodItem
from .nutrition import Nutrition

__all__ = [
    "Nutrition",
    "FoodItem",
]
</file>

<file path="src/infra/database/models/user/__init__.py">
"""User-related database models."""
from .profile import UserProfile
from .user import User

__all__ = [
    "User",
    "UserProfile",
]
</file>

<file path="src/infra/database/models/base.py">
import uuid
from datetime import datetime

from sqlalchemy import Column, String, DateTime, Integer
from sqlalchemy.ext.declarative import declared_attr
from sqlalchemy.orm import declarative_mixin


@declarative_mixin
class PrimaryEntityMixin:
    """Base mixin for primary entities with GUID as primary key."""
    
    @declared_attr
    def __tablename__(cls):
        return cls.__name__.lower()
    
    id = Column(String(36), primary_key=True, default=lambda: str(uuid.uuid4()))
    created_at = Column(DateTime, default=datetime.now, nullable=False)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, nullable=False)


@declarative_mixin
class SecondaryEntityMixin:
    """Base mixin for secondary entities with auto-incrementing ID."""
    
    @declared_attr
    def __tablename__(cls):
        return cls.__name__.lower()
    
    id = Column(Integer, primary_key=True, autoincrement=True)
    created_at = Column(DateTime, default=datetime.now, nullable=False)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, nullable=False)


@declarative_mixin
class TimestampMixin:
    """Mixin that only provides timestamp fields without ID."""
    created_at = Column(DateTime, default=datetime.now, nullable=False)
    updated_at = Column(DateTime, default=datetime.now, onupdate=datetime.now, nullable=False)


# Maintain backward compatibility
BaseMixin = PrimaryEntityMixin
</file>

<file path="src/infra/database/models/feature_flag.py">
"""
Feature flag database model for application-wide feature control.
"""
from datetime import datetime

from sqlalchemy import Boolean, Column, String, DateTime

from src.infra.database.config import Base


class FeatureFlag(Base):
    """Database model for feature flags."""
    
    __tablename__ = "feature_flags"
    
    name = Column(String(255), primary_key=True, index=True)
    enabled = Column(Boolean, nullable=False, default=False)
    description = Column(String(500), nullable=True)
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
</file>

<file path="src/infra/event_bus/__init__.py">
"""
Event bus infrastructure implementation.
"""
from .event_bus import EventBus
from .pymediator_event_bus import PyMediatorEventBus

__all__ = ['EventBus', 'PyMediatorEventBus']
</file>

<file path="src/infra/event_bus/event_bus.py">
"""
Event bus interface and in-memory implementation.
"""
import logging
from abc import ABC, abstractmethod
from typing import Any, Type, TypeVar, Callable, Awaitable

from src.app.events.base import Event, DomainEvent, EventHandler

logger = logging.getLogger(__name__)

T = TypeVar('T')


class EventBus(ABC):
    """
    Abstract event bus interface.
    
    This defines the contract that all event bus implementations must follow.
    """
    
    @abstractmethod
    async def send(self, event: Event) -> Any:
        """Send a command/query and wait for the result."""
        pass
    
    @abstractmethod
    async def publish(self, event: DomainEvent) -> None:
        """Publish a domain event to all subscribers."""
        pass
    
    @abstractmethod
    def register_handler(self, event_type: Type[Event], handler: EventHandler) -> None:
        """Register a handler for a specific event type."""
        pass
    
    @abstractmethod
    def subscribe(self, event_type: Type[DomainEvent], handler: Callable[[DomainEvent], Awaitable[None]]) -> None:
        """Subscribe to domain events."""
        pass
</file>

<file path="src/infra/mappers/__init__.py">
"""Mappers for converting between domain and infrastructure models."""
from .status_mapper import MealStatusMapper

__all__ = ["MealStatusMapper"]
</file>

<file path="src/infra/mappers/status_mapper.py">
"""
Status mapper utility to convert between domain and database enums.
Centralizes status mapping logic to avoid duplication.
"""
from src.domain.model.meal import MealStatus
from src.infra.database.models.enums import MealStatusEnum


class MealStatusMapper:
    """Maps meal status between domain and database layers."""

    DOMAIN_TO_DB = {
        MealStatus.PROCESSING: MealStatusEnum.PROCESSING,
        MealStatus.ANALYZING: MealStatusEnum.ANALYZING,
        MealStatus.ENRICHING: MealStatusEnum.ENRICHING,
        MealStatus.READY: MealStatusEnum.READY,
        MealStatus.FAILED: MealStatusEnum.FAILED,
        MealStatus.INACTIVE: MealStatusEnum.INACTIVE,
    }

    DB_TO_DOMAIN = {
        MealStatusEnum.PROCESSING: MealStatus.PROCESSING,
        MealStatusEnum.ANALYZING: MealStatus.ANALYZING,
        MealStatusEnum.ENRICHING: MealStatus.ENRICHING,
        MealStatusEnum.READY: MealStatus.READY,
        MealStatusEnum.FAILED: MealStatus.FAILED,
        MealStatusEnum.INACTIVE: MealStatus.INACTIVE,
    }

    @classmethod
    def to_db(cls, domain_status: MealStatus) -> MealStatusEnum:
        """Convert domain status to database enum."""
        return cls.DOMAIN_TO_DB[domain_status]

    @classmethod
    def to_domain(cls, db_status: MealStatusEnum) -> MealStatus:
        """Convert database enum to domain status."""
        return cls.DB_TO_DOMAIN[db_status]
</file>

<file path="src/api/builders/__init__.py">
"""Response builders for API layer."""
</file>

<file path="src/api/converters/meal_plan_converters.py">
"""
Converters for transforming domain models to API response models.
"""
from typing import Optional

from src.api.schemas.response.meal_plan_responses import (
    DailyMealPlanStrongResponse,
    GeneratedMealResponse,
    UserPreferencesStrongResponse
)
from src.domain.model.meal_planning import DailyMealPlan, GeneratedMeal, NutritionSummary
from src.domain.model.meal_planning import MealGenerationRequest


class MealPlanConverter:
    """Converter for meal plan domain models to API response models."""

    @staticmethod
    def nutrition_summary_to_response(nutrition: NutritionSummary) -> 'NutritionSummarySchema':
        """Convert domain NutritionSummary to response model."""
        from src.api.schemas.response.meal_plan_responses import NutritionSummarySchema
        return NutritionSummarySchema(
            calories=nutrition.calories,
            protein=round(nutrition.protein, 1),
            carbs=round(nutrition.carbs, 1),
            fat=round(nutrition.fat, 1)
        )

    @staticmethod
    def generated_meal_to_response(meal: GeneratedMeal) -> GeneratedMealResponse:
        """Convert domain GeneratedMeal to response model."""
        return GeneratedMealResponse(
            meal_id=meal.meal_id,
            meal_type=meal.meal_type,
            name=meal.name,
            description=meal.description,
            prep_time=meal.prep_time,
            cook_time=meal.cook_time,
            total_time=meal.total_time,
            calories=meal.nutrition.calories,
            protein=round(meal.nutrition.protein, 1),
            carbs=round(meal.nutrition.carbs, 1),
            fat=round(meal.nutrition.fat, 1),
            ingredients=meal.ingredients,
            instructions=meal.instructions,
            is_vegetarian=meal.is_vegetarian,
            is_vegan=meal.is_vegan,
            is_gluten_free=meal.is_gluten_free,
            cuisine_type=meal.cuisine_type
        )

    @staticmethod
    def user_preferences_to_response(request: MealGenerationRequest) -> 'UserPreferencesStrongResponse':
        """Convert domain MealGenerationRequest to user preferences response."""
        from src.api.schemas.response.meal_plan_responses import UserPreferencesStrongResponse
        return UserPreferencesStrongResponse(
            dietary_preferences=request.user_profile.dietary_preferences or [],
            health_conditions=request.user_profile.health_conditions or [],
            allergies=request.user_profile.allergies or [],
            activity_level=request.user_profile.activity_level,
            fitness_goal=request.user_profile.fitness_goal,
            meals_per_day=request.user_profile.meals_per_day,
            snacks_per_day=1 if request.user_profile.include_snacks else 0
        )

    @staticmethod
    def daily_meal_plan_to_response(
        daily_plan: DailyMealPlan, 
        request: MealGenerationRequest,
        plan_id: Optional[str] = None
    ) -> 'DailyMealPlanStrongResponse':
        """Convert domain DailyMealPlan to response model."""
        from src.api.schemas.response.meal_plan_responses import DailyMealPlanStrongResponse
        return DailyMealPlanStrongResponse(
            user_id=daily_plan.user_id,
            date=daily_plan.plan_date.isoformat(),
            plan_id=plan_id,
            meals=[
                MealPlanConverter.generated_meal_to_response(meal) 
                for meal in daily_plan.meals
            ],
            total_nutrition=MealPlanConverter.nutrition_summary_to_response(daily_plan.total_nutrition),
            target_nutrition=MealPlanConverter.nutrition_summary_to_response(request.nutrition_targets),
            user_preferences=MealPlanConverter.user_preferences_to_response(request)
        )
</file>

<file path="src/api/routes/v1/chat/__init__.py">
"""
Chat API routes.
Organized by feature area for better maintainability.
"""
from fastapi import APIRouter
from .thread_routes import router as thread_router
from .message_routes import router as message_router

# Main chat router that combines all sub-routers
router = APIRouter(prefix="/v1/chat", tags=["Chat"])

# Include sub-routers
router.include_router(thread_router)
router.include_router(message_router)

__all__ = ["router"]
</file>

<file path="src/api/routes/v1/chat/message_routes.py">
"""
Chat message routes - Sending and retrieving messages.
"""
from fastapi import APIRouter, Depends, Query

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request.chat_requests import SendMessageRequest
from src.api.schemas.response.chat_responses import SendMessageResponse
from src.api.builders.chat_response_builder import ChatResponseBuilder
from src.app.commands.chat import SendMessageCommand
from src.app.queries.chat import GetMessagesQuery
from src.infra.event_bus import EventBus

router = APIRouter()


@router.post("/threads/{thread_id}/messages", response_model=SendMessageResponse)
async def send_message(
    thread_id: str,
    request: SendMessageRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Send a message in a thread and get AI response.

    Authentication required: User ID is automatically extracted from the Firebase token.

    The assistant response includes:
    - message: The friendly response text
    - follow_ups: Suggested follow-up questions/actions
    - structured_data: Meal suggestions, recipes, etc.
    """
    try:
        command = SendMessageCommand(
            thread_id=thread_id,
            user_id=user_id,
            content=request.content,
            metadata=request.metadata
        )

        result = await event_bus.send(command)

        # Build responses with proper follow_ups and structured_data
        user_msg = ChatResponseBuilder.build_message_response(result["user_message"])

        assistant_msg = None
        if result.get("assistant_message"):
            assistant_msg = ChatResponseBuilder.build_message_response(
                result["assistant_message"]
            )

        return SendMessageResponse(
            success=result["success"],
            user_message=user_msg,
            assistant_message=assistant_msg
        )

    except Exception as e:
        raise handle_exception(e) from e


@router.get("/threads/{thread_id}/messages")
async def get_messages(
    thread_id: str,
    limit: int = Query(100, ge=1, le=200),
    offset: int = Query(0, ge=0),
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get messages from a thread with pagination.

    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        query = GetMessagesQuery(
            thread_id=thread_id,
            user_id=user_id,
            limit=limit,
            offset=offset
        )

        result = await event_bus.send(query)

        return result

    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/api/routes/v1/chat/thread_routes.py">
"""
Chat thread routes - Thread CRUD operations.
"""
from fastapi import APIRouter, Depends, Query

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request.chat_requests import CreateThreadRequest
from src.api.schemas.response.chat_responses import (
    ThreadResponse,
    ThreadListResponse
)
from src.api.builders.chat_response_builder import ChatResponseBuilder
from src.app.commands.chat import CreateThreadCommand, DeleteThreadCommand
from src.app.queries.chat import GetThreadsQuery, GetThreadQuery
from src.infra.event_bus import EventBus

router = APIRouter()


@router.post("/threads", response_model=ThreadResponse)
async def create_thread(
    request: CreateThreadRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Create a new chat thread with automatic welcome message.

    Authentication required: User ID is automatically extracted from the Firebase token.

    Returns the thread with a welcome message from the meal planning assistant,
    including suggested follow-up questions to help users get started.
    """
    try:
        command = CreateThreadCommand(
            user_id=user_id,
            title=request.title,
            metadata=request.metadata
        )

        result = await event_bus.send(command)

        # Build thread response with properly structured messages
        thread_data = ChatResponseBuilder.build_thread_with_messages(
            thread_data=result["thread"],
            messages=result["thread"].get("messages")
        )

        return ThreadResponse(**thread_data)

    except Exception as e:
        raise handle_exception(e) from e


@router.get("/threads", response_model=ThreadListResponse)
async def get_threads(
    limit: int = Query(50, ge=1, le=100),
    offset: int = Query(0, ge=0),
    include_deleted: bool = Query(False),
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get list of chat threads for the current user.

    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        query = GetThreadsQuery(
            user_id=user_id,
            limit=limit,
            offset=offset,
            include_deleted=include_deleted
        )

        result = await event_bus.send(query)

        return ThreadListResponse(**result)

    except Exception as e:
        raise handle_exception(e) from e


@router.get("/threads/{thread_id}", response_model=ThreadResponse)
async def get_thread(
    thread_id: str,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get a specific thread with its messages.

    Authentication required: User ID is automatically extracted from the Firebase token.

    Messages include follow_ups and structured_data when available.
    """
    try:
        query = GetThreadQuery(
            thread_id=thread_id,
            user_id=user_id
        )

        result = await event_bus.send(query)

        # Build thread response with properly structured messages
        thread_data = ChatResponseBuilder.build_thread_with_messages(
            thread_data=result["thread"],
            messages=result.get("messages", [])
        )

        return ThreadResponse(**thread_data)

    except Exception as e:
        raise handle_exception(e) from e


@router.delete("/threads/{thread_id}")
async def delete_thread(
    thread_id: str,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Delete a thread (soft delete).

    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        command = DeleteThreadCommand(
            thread_id=thread_id,
            user_id=user_id
        )

        result = await event_bus.send(command)

        return result

    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/api/routes/v1/feature_flags.py">
"""
Feature flags API endpoints for application-level feature control.
"""
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, HTTPException, Depends
from sqlalchemy.orm import Session

from src.api.schemas.request.feature_flag_requests import CreateFeatureFlagRequest, UpdateFeatureFlagRequest
from src.api.schemas.response.feature_flag_responses import (
    FeatureFlagsResponse,
    IndividualFeatureFlagResponse,
    FeatureFlagCreatedResponse,
    FeatureFlagUpdatedResponse
)
from src.api.base_dependencies import get_cache_service, get_db
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService
from src.infra.database.models.feature_flag import FeatureFlag

router = APIRouter(prefix="/v1/feature-flags", tags=["Feature Flags"])


@router.get("/", response_model=FeatureFlagsResponse)
async def get_feature_flags(
    db: Session = Depends(get_db),
    cache_service: Optional[CacheService] = Depends(get_cache_service),
):
    """
    Get all feature flags from the database.
    
    Returns all feature flags currently stored in the system.
    """
    cache_key, ttl = CacheKeys.feature_flags()
    if cache_service:
        cached = await cache_service.get_json(cache_key)
        if cached:
            return FeatureFlagsResponse(**cached)

    feature_flags = db.query(FeatureFlag).all()
    flags_dict = {flag.name: flag.enabled for flag in feature_flags}

    response = FeatureFlagsResponse(
        flags=flags_dict,
        updated_at=datetime.utcnow()
    )

    if cache_service:
        await cache_service.set_json(cache_key, response.model_dump(), ttl)

    return response


@router.get("/{feature_name}", response_model=IndividualFeatureFlagResponse)
async def get_individual_feature_flag(
    feature_name: str,
    db: Session = Depends(get_db),
    cache_service: Optional[CacheService] = Depends(get_cache_service),
):
    """
    Get a specific feature flag from the database.
    
    - **feature_name**: Name of the feature flag to retrieve
    
    Returns the status of a single feature flag.
    """
    cache_key, ttl = CacheKeys.feature_flag(feature_name)
    if cache_service:
        cached = await cache_service.get_json(cache_key)
        if cached:
            return IndividualFeatureFlagResponse(**cached)

    feature_flag = db.query(FeatureFlag).filter(FeatureFlag.name == feature_name).first()
    
    if not feature_flag:
        raise HTTPException(
            status_code=404,
            detail=f"Feature flag '{feature_name}' not found"
        )
    
    response = IndividualFeatureFlagResponse(
        name=feature_flag.name,
        enabled=feature_flag.enabled,
        description=feature_flag.description,
        created_at=feature_flag.created_at,
        updated_at=feature_flag.updated_at
    )

    if cache_service:
        await cache_service.set_json(cache_key, response.model_dump(), ttl)

    return response


@router.post("/", response_model=FeatureFlagCreatedResponse, status_code=201)
async def create_feature_flag(
    request: CreateFeatureFlagRequest,
    db: Session = Depends(get_db),
    cache_service: Optional[CacheService] = Depends(get_cache_service),
):
    """
    Create a new feature flag.
    
    - **name**: Unique name for the feature flag
    - **enabled**: Initial enabled state (default: False)  
    - **description**: Optional description of the feature flag
    
    Returns the created feature flag information.
    """
    # Check if feature flag already exists
    existing_flag = db.query(FeatureFlag).filter(FeatureFlag.name == request.name).first()
    if existing_flag:
        raise HTTPException(
            status_code=409,
            detail=f"Feature flag '{request.name}' already exists"
        )
    
    # Create new feature flag
    new_flag = FeatureFlag(
        name=request.name,
        enabled=request.enabled,
        description=request.description
    )
    
    db.add(new_flag)
    db.commit()
    db.refresh(new_flag)
    
    response = FeatureFlagCreatedResponse(
        name=new_flag.name,
        enabled=new_flag.enabled,
        description=new_flag.description,
        created_at=new_flag.created_at
    )

    if cache_service:
        await cache_service.invalidate(CacheKeys.feature_flags()[0])
        await cache_service.invalidate(CacheKeys.feature_flag(new_flag.name)[0])

    return response


@router.put("/{feature_name}", response_model=FeatureFlagUpdatedResponse)
async def update_feature_flag(
    feature_name: str, 
    request: UpdateFeatureFlagRequest, 
    db: Session = Depends(get_db),
    cache_service: Optional[CacheService] = Depends(get_cache_service),
):
    """
    Update an existing feature flag.
    
    - **feature_name**: Name of the feature flag to update
    - **enabled**: New enabled state (optional)
    - **description**: New description (optional)
    
    Returns the updated feature flag information.
    """
    feature_flag = db.query(FeatureFlag).filter(FeatureFlag.name == feature_name).first()
    
    if not feature_flag:
        raise HTTPException(
            status_code=404,
            detail=f"Feature flag '{feature_name}' not found"
        )
    
    # Update only provided fields
    if request.enabled is not None:
        feature_flag.enabled = request.enabled
    if request.description is not None:
        feature_flag.description = request.description
    
    feature_flag.updated_at = datetime.utcnow()
    
    db.commit()
    db.refresh(feature_flag)
    
    response = FeatureFlagUpdatedResponse(
        name=feature_flag.name,
        enabled=feature_flag.enabled,
        description=feature_flag.description,
        updated_at=feature_flag.updated_at
    )

    if cache_service:
        await cache_service.invalidate(CacheKeys.feature_flags()[0])
        await cache_service.invalidate(CacheKeys.feature_flag(feature_flag.name)[0])

    return response
</file>

<file path="src/api/routes/v1/foods.py">
"""
Foods API routes: search and details via USDA.

Uses a lightweight singleton event bus to avoid re-initializing
heavy services (Cloudinary, Gemini, etc.) on every request.
"""
from fastapi import APIRouter, HTTPException, Query

from src.api.dependencies.event_bus import get_food_search_event_bus
from src.app.queries.food.get_food_details_query import GetFoodDetailsQuery
from src.app.queries.food.search_foods_query import SearchFoodsQuery

router = APIRouter(prefix="/v1/foods", tags=["Foods"])


@router.get("/search")
async def search_foods(
    q: str = Query(..., min_length=1),
    limit: int = Query(20, ge=1, le=50),
):
    """Search foods using lightweight singleton event bus."""
    try:
        event_bus = get_food_search_event_bus()
        query = SearchFoodsQuery(query=q, limit=limit)
        return await event_bus.send(query)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/{fdc_id}/details")
async def get_food_details(
    fdc_id: int,
):
    """Get food details using lightweight singleton event bus."""
    try:
        event_bus = get_food_search_event_bus()
        query = GetFoodDetailsQuery(fdc_id=fdc_id)
        return await event_bus.send(query)
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
</file>

<file path="src/api/routes/v1/ingredients.py">
"""
Ingredient recognition API endpoints.
"""
import logging

from fastapi import APIRouter, Depends

from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request import IngredientRecognitionRequest
from src.api.schemas.response import IngredientRecognitionResponse
from src.app.commands.ingredient import RecognizeIngredientCommand
from src.infra.event_bus import EventBus

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/v1/ingredients", tags=["Ingredients"])


@router.post("/recognize", response_model=IngredientRecognitionResponse)
async def recognize_ingredient(
    request: IngredientRecognitionRequest,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Recognize a food ingredient from an image.

    Takes a base64 encoded image and uses Gemini Vision AI to identify
    the primary food ingredient visible in the image.

    Returns:
    - name: Identified ingredient name in English (lowercase)
    - confidence: Confidence score between 0 and 1
    - category: Category (vegetable, fruit, protein, grain, dairy, seasoning, other)
    - success: Whether recognition was successful
    - message: Additional message (e.g., error details)
    """
    try:
        command = RecognizeIngredientCommand(
            image_data=request.image_data
        )
        result = await event_bus.send(command)
        return IngredientRecognitionResponse(**result)

    except Exception as e:
        logger.error(f"Ingredient recognition endpoint error: {e}")
        raise handle_exception(e)


@router.get("/health")
async def ingredients_health():
    """Check if ingredient recognition service is healthy."""
    return {
        "status": "healthy",
        "service": "ingredient_recognition",
        "features": [
            "photo_ingredient_identification",
            "gemini_vision_ai",
            "confidence_scoring"
        ]
    }
</file>

<file path="src/api/routes/v1/monitoring.py">
"""
Monitoring endpoints for cache metrics.
"""
from fastapi import APIRouter, Depends

from src.api.base_dependencies import get_cache_monitor
from src.infra.cache.metrics import CacheMonitor

router = APIRouter(prefix="/v1/monitoring", tags=["Monitoring"])


@router.get("/cache/metrics")
async def cache_metrics(cache_monitor: CacheMonitor = Depends(get_cache_monitor)):
    """Return cache hit/miss statistics."""
    return cache_monitor.snapshot()
</file>

<file path="src/api/schemas/common/meal_plan_enums.py">
from enum import Enum


class DietaryPreferenceSchema(str, Enum):
    vegan = "vegan"
    vegetarian = "vegetarian"
    pescatarian = "pescatarian"
    gluten_free = "gluten_free"
    keto = "keto"
    paleo = "paleo"
    low_carb = "low_carb"
    dairy_free = "dairy_free"
    none = "none"


class FitnessGoalSchema(str, Enum):
    cut = "cut"
    bulk = "bulk"
    recomp = "recomp"


class MealTypeSchema(str, Enum):
    breakfast = "breakfast"
    lunch = "lunch"
    dinner = "dinner"
    snack = "snack"


class PlanDurationSchema(str, Enum):
    daily = "daily"
    weekly = "weekly"


class ConversationStateSchema(str, Enum):
    greeting = "greeting"
    asking_dietary_preferences = "asking_dietary_preferences"
    asking_allergies = "asking_allergies"
    asking_fitness_goals = "asking_fitness_goals"
    asking_meal_count = "asking_meal_count"
    asking_plan_duration = "asking_plan_duration"
    asking_cooking_time = "asking_cooking_time"
    asking_cuisine_preferences = "asking_cuisine_preferences"
    confirming_preferences = "confirming_preferences"
    generating_plan = "generating_plan"
    showing_plan = "showing_plan"
    adjusting_meal = "adjusting_meal"
    completed = "completed"
</file>

<file path="src/api/schemas/common/meal_type_enum.py">
"""Meal type enum for simplified meal categorization."""

from enum import Enum


class MealTypeEnum(str, Enum):
    """Three meal types replacing 5 T-shirt sizes."""

    SNACK = "snack"  # Fixed ~150-300 kcal
    MAIN = "main"  # Calculated from TDEE ÷ meals_per_day
    OMAD = "omad"  # Full daily target (One Meal A Day)
</file>

<file path="src/api/schemas/request/chat_requests.py">
"""
Request schemas for chat endpoints.
"""
from typing import Optional, Dict, Any
from pydantic import BaseModel, Field


class CreateThreadRequest(BaseModel):
    """Request to create a new chat thread."""
    title: Optional[str] = Field(None, max_length=255, description="Thread title")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Optional metadata")


class SendMessageRequest(BaseModel):
    """Request to send a message in a thread."""
    content: str = Field(..., min_length=1, max_length=50000, description="Message content")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Optional metadata")
</file>

<file path="src/api/schemas/request/daily_meal_requests.py">
"""
Daily meal suggestion request DTOs.
"""
from enum import Enum
from typing import List, Optional

from pydantic import BaseModel, Field


class MealTypeEnum(str, Enum):
    """Enum for meal types."""
    breakfast = "breakfast"
    lunch = "lunch"
    dinner = "dinner"
    snack = "snack"


class UserPreferencesRequest(BaseModel):
    """Request DTO for user preferences from onboarding data."""
    age: int = Field(..., ge=13, le=120, description="User age")
    gender: str = Field(..., pattern="^(male|female|other)$", description="User gender")
    height: float = Field(..., gt=0, le=300, description="Height in cm")
    weight: float = Field(..., gt=0, le=500, description="Weight in kg")
    activity_level: str = Field(
        ..., 
        pattern="^(sedentary|lightly_active|moderately_active|very_active|extra_active)$",
        description="Activity level"
    )
    goal: str = Field(
        ...,
        pattern="^(cut|bulk|recomp)$",
        description="Fitness goal"
    )
    dietary_preferences: Optional[List[str]] = Field(
        default_factory=list, 
        description="Dietary preferences/restrictions (vegetarian, vegan, etc.)"
    )
    health_conditions: Optional[List[str]] = Field(
        default_factory=list, 
        description="Health conditions (diabetes, hypertension, etc.)"
    )
    target_calories: Optional[float] = Field(
        None, 
        ge=1000, 
        le=5000,
        description="Daily calorie target (will be calculated if not provided)"
    )
    target_protein: Optional[float] = Field(None, ge=0, description="Target protein in grams")
    target_carbs: Optional[float] = Field(None, ge=0, description="Target carbs in grams")
    target_fat: Optional[float] = Field(None, ge=0, description="Target fat in grams")
    
    class Config:
        json_schema_extra = {
            "example": {
                "age": 25,
                "gender": "male",
                "height": 180.0,
                "weight": 75.0,
                "activity_level": "moderately_active",
                "goal": "bulk",
                "dietary_preferences": ["vegetarian"],
                "health_conditions": [],
                "target_calories": 2800
            }
        }


class MealSuggestionFilterRequest(BaseModel):
    """Request DTO for filtering meal suggestions."""
    meal_types: Optional[List[MealTypeEnum]] = Field(
        default_factory=list,
        description="Filter by meal types"
    )
    cuisine_types: Optional[List[str]] = Field(
        default_factory=list,
        description="Filter by cuisine types"
    )
    max_prep_time: Optional[int] = Field(
        None,
        ge=0,
        le=180,
        description="Maximum preparation time in minutes"
    )
    exclude_ingredients: Optional[List[str]] = Field(
        default_factory=list,
        description="Ingredients to exclude"
    )
</file>

<file path="src/api/schemas/request/ingredient_recognition_requests.py">
"""
Ingredient recognition request DTOs.
"""
from pydantic import BaseModel, Field


class IngredientRecognitionRequest(BaseModel):
    """Request to recognize an ingredient from an image."""

    image_data: str = Field(
        ...,
        description="Base64 encoded image data (JPEG or PNG)",
        min_length=1
    )

    class Config:
        json_schema_extra = {
            "example": {
                "image_data": "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mNk+M9QDwADhgGAWjR9awAAAABJRU5ErkJggg=="
            }
        }
</file>

<file path="src/api/schemas/request/meal_requests.py">
"""
Meal-related request DTOs.
"""
from typing import Optional, Literal

from pydantic import BaseModel, Field


class MacrosRequest(BaseModel):
    """Request DTO for macronutrient information."""
    protein: float = Field(..., ge=0, description="Protein in grams")
    carbs: float = Field(..., ge=0, description="Carbohydrates in grams") 
    fat: float = Field(..., ge=0, description="Fat in grams")


class CreateMealRequest(BaseModel):
    """Request DTO for creating a meal manually."""
    name: str = Field(..., min_length=1, max_length=200, description="Meal name")
    description: Optional[str] = Field(None, max_length=500, description="Meal description")
    weight_grams: Optional[float] = Field(None, gt=0, le=5000, description="Weight in grams")
    calories_per_100g: Optional[float] = Field(None, ge=0, description="Calories per 100g")
    macros_per_100g: Optional[MacrosRequest] = Field(None, description="Macros per 100g")
    
    class Config:
        json_schema_extra = {
            "example": {
                "name": "Grilled Chicken Breast",
                "description": "Seasoned with herbs and olive oil",
                "weight_grams": 150,
                "calories_per_100g": 165,
                "macros_per_100g": {
                    "protein": 31.0,
                    "carbs": 0,
                    "fat": 3.6
                }
            }
        }


class UpdateMealRequest(BaseModel):
    """Request DTO for updating meal information."""
    name: Optional[str] = Field(None, min_length=1, max_length=200, description="Meal name")
    description: Optional[str] = Field(None, max_length=500, description="Meal description")
    weight_grams: Optional[float] = Field(None, gt=0, le=5000, description="Weight in grams")
    calories_per_100g: Optional[float] = Field(None, ge=0, description="Calories per 100g")
    macros_per_100g: Optional[MacrosRequest] = Field(None, description="Macros per 100g")


class UpdateMealMacrosRequest(BaseModel):
    """Request DTO for updating meal portion size."""
    weight_grams: float = Field(
        ..., 
        gt=0, 
        le=5000, 
        description="Weight of the meal portion in grams"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "weight_grams": 250.0
            }
        }


class MealSearchRequest(BaseModel):
    """Request DTO for searching meals."""
    query: str = Field(..., min_length=1, max_length=200, description="Search query")
    limit: int = Field(10, ge=1, le=100, description="Maximum results to return")
    include_ingredients: bool = Field(False, description="Include ingredients in search")
    
    class Config:
        json_schema_extra = {
            "example": {
                "query": "chicken",
                "limit": 20,
                "include_ingredients": True
            }
        }


class AnalyzeMealImageRequest(BaseModel):
    """Request DTO for meal image analysis options."""
    immediate_analysis: bool = Field(
        False, 
        description="Perform immediate analysis (synchronous)"
    )
    portion_size_grams: Optional[float] = Field(
        None,
        gt=0,
        le=5000,
        description="Known portion size in grams"
    )
    context: Optional[str] = Field(
        None,
        max_length=500,
        description="Additional context for analysis"
    )


# Food database manual meal creation requests
class ManualMealItemRequest(BaseModel):
    """Single selected food item with portion to create a manual meal."""
    fdc_id: int = Field(..., description="USDA FDC ID")
    quantity: float = Field(..., gt=0, description="Amount relative to serving unit (e.g., grams)")
    unit: str = Field("g", min_length=1, max_length=20, description="Unit, default grams")


class CreateManualMealFromFoodsRequest(BaseModel):
    """Create a manual meal from selected USDA foods with portions."""
    dish_name: str = Field(..., min_length=1, max_length=200)
    items: list[ManualMealItemRequest] = Field(..., min_items=1)
    meal_type: Optional[str] = Field(None, description="Meal type: breakfast, lunch, dinner, or snack")
    target_date: Optional[str] = Field(None, description="Target date in YYYY-MM-DD format for meal association")


# Meal Edit Feature Requests
class FoodItemChangeRequest(BaseModel):
    """Request DTO for a single food item change in meal editing."""
    action: Literal["add", "update", "remove"] = Field(..., description="Action to perform: 'add', 'update', or 'remove'")
    id: Optional[str] = Field(None, description="ID of existing food item (required for update/remove)")
    fdc_id: Optional[int] = Field(None, description="USDA FDC ID for new ingredients")
    name: Optional[str] = Field(None, min_length=1, max_length=200, description="Ingredient name")
    quantity: Optional[float] = Field(None, gt=0, le=10000, description="Quantity amount")
    unit: Optional[str] = Field(None, min_length=1, max_length=20, description="Unit of measurement")
    custom_nutrition: Optional["CustomNutritionRequest"] = Field(None, description="Custom nutrition data for non-USDA ingredients")

    class Config:
        json_schema_extra = {
            "example": {
                "action": "update",
                "id": "123",
                "quantity": 150.0,
                "unit": "g"
            }
        }


class CustomNutritionRequest(BaseModel):
    """Request DTO for custom nutrition data."""
    calories_per_100g: float = Field(..., ge=0, le=1000, description="Calories per 100g")
    protein_per_100g: float = Field(..., ge=0, le=100, description="Protein per 100g in grams")
    carbs_per_100g: float = Field(..., ge=0, le=100, description="Carbohydrates per 100g in grams")
    fat_per_100g: float = Field(..., ge=0, le=100, description="Fat per 100g in grams")

    class Config:
        json_schema_extra = {
            "example": {
                "calories_per_100g": 165.0,
                "protein_per_100g": 31.0,
                "carbs_per_100g": 0.0,
                "fat_per_100g": 3.6,
            }
        }


class EditMealIngredientsRequest(BaseModel):
    """Request DTO for editing meal ingredients."""
    dish_name: Optional[str] = Field(None, min_length=1, max_length=200, description="Updated meal name")
    food_item_changes: list[FoodItemChangeRequest] = Field(..., min_items=1, description="List of ingredient changes")

    class Config:
        json_schema_extra = {
            "example": {
                "dish_name": "Updated Grilled Chicken Salad",
                "food_item_changes": [
                    {
                        "action": "update",
                        "id": "existing-uuid",
                        "quantity": 200.0,
                        "unit": "g"
                    },
                    {
                        "action": "add",
                        "fdc_id": 168462,
                        "name": "Mixed Greens",
                        "quantity": 100.0,
                        "unit": "g"
                    }
                ]
            }
        }


class AddCustomIngredientRequest(BaseModel):
    """Request DTO for adding custom ingredient to meal."""
    name: str = Field(..., min_length=1, max_length=200, description="Custom ingredient name")
    quantity: float = Field(..., gt=0, le=10000, description="Quantity amount")
    unit: str = Field(..., min_length=1, max_length=20, description="Unit of measurement")
    nutrition: CustomNutritionRequest = Field(..., description="Nutrition data per 100g")

    class Config:
        json_schema_extra = {
            "example": {
                "name": "Homemade Vinaigrette",
                "quantity": 30.0,
                "unit": "ml",
                "nutrition": {
                    "calories_per_100g": 400.0,
                    "protein_per_100g": 0.5,
                    "carbs_per_100g": 2.0,
                    "fat_per_100g": 44.0
                }
            }
        }
</file>

<file path="src/api/schemas/request/onboarding_requests.py">
from typing import Optional, List

from pydantic import BaseModel, Field


class OnboardingCompleteRequest(BaseModel):
    """Complete onboarding data request for saving to database."""
    # Personal info - REQUIRED
    age: int = Field(..., ge=13, le=120)
    gender: str = Field(..., description="male/female")
    height: float = Field(..., gt=0, description="Height in cm")
    weight: float = Field(..., gt=0, description="Weight in kg")
    body_fat_percentage: Optional[float] = Field(None, ge=0, le=100)

    # Activity and goals - REQUIRED
    activity_level: str = Field(..., description="sedentary/light/moderate/active/very_active")
    goal: str = Field(..., description="bulk/cut/maintain/recomp")

    # User experience - REQUIRED (at least one item each)
    pain_points: List[str] = Field(..., min_items=1, description="User pain points")
    dietary_preferences: List[str] = Field(..., min_items=1, description="Dietary preferences")

    # Meal preferences - REQUIRED
    meals_per_day: int = Field(..., ge=1, le=10)
</file>

<file path="src/api/schemas/response/daily_meal_responses.py">
"""
Daily meal suggestion response DTOs.
"""
from enum import Enum
from typing import List, Optional, Dict

from pydantic import BaseModel, Field


class MealTypeEnum(str, Enum):
    """Enum for meal types."""
    breakfast = "breakfast"
    lunch = "lunch"
    dinner = "dinner"
    snack = "snack"


class NutritionTotalsResponse(BaseModel):
    """Response DTO for nutrition totals."""
    calories: float = Field(..., ge=0, description="Total calories")
    protein: float = Field(..., ge=0, description="Protein in grams")
    carbs: float = Field(..., ge=0, description="Carbohydrates in grams")
    fat: float = Field(..., ge=0, description="Fat in grams")
    
    class Config:
        json_schema_extra = {
            "example": {
                "calories": 2500.0,
                "protein": 125.0,
                "carbs": 300.0,
                "fat": 83.0
            }
        }


class SuggestedMealResponse(BaseModel):
    """Response DTO for a suggested meal."""
    meal_id: str = Field(..., description="Unique meal identifier")
    meal_type: MealTypeEnum = Field(..., description="Type of meal")
    name: str = Field(..., description="Meal name")
    description: str = Field(..., description="Meal description")
    
    # Time information
    prep_time: int = Field(..., ge=0, description="Preparation time in minutes")
    cook_time: int = Field(..., ge=0, description="Cooking time in minutes")
    total_time: int = Field(..., ge=0, description="Total time in minutes")
    
    # Nutrition information
    calories: float = Field(..., ge=0, description="Calories")
    protein: float = Field(..., ge=0, description="Protein in grams")
    carbs: float = Field(..., ge=0, description="Carbohydrates in grams")
    fat: float = Field(..., ge=0, description="Fat in grams")
    
    # Recipe information
    ingredients: List[str] = Field(..., min_items=1, description="List of ingredients")
    instructions: List[str] = Field(..., min_items=1, description="Cooking instructions")
    
    # Dietary information
    is_vegetarian: bool = Field(..., description="Is vegetarian")
    is_vegan: bool = Field(..., description="Is vegan")
    is_gluten_free: bool = Field(..., description="Is gluten-free")
    cuisine_type: Optional[str] = Field(None, description="Cuisine type")
    
    class Config:
        json_schema_extra = {
            "example": {
                "meal_id": "123e4567-e89b-12d3-a456-426614174000",
                "meal_type": "breakfast",
                "name": "Protein-Packed Oatmeal",
                "description": "High-protein oatmeal with berries and nuts",
                "prep_time": 5,
                "cook_time": 10,
                "total_time": 15,
                "calories": 450.0,
                "protein": 25.0,
                "carbs": 55.0,
                "fat": 15.0,
                "ingredients": [
                    "1 cup rolled oats",
                    "1 scoop protein powder",
                    "1/2 cup mixed berries",
                    "2 tablespoons almond butter"
                ],
                "instructions": [
                    "Cook oats according to package directions",
                    "Stir in protein powder",
                    "Top with berries and almond butter"
                ],
                "is_vegetarian": True,
                "is_vegan": False,
                "is_gluten_free": False,
                "cuisine_type": "American"
            }
        }


class DailyMealSuggestionsResponse(BaseModel):
    """Response DTO for daily meal suggestions."""
    date: str = Field(..., description="Date for the suggestions (ISO format)")
    meal_count: int = Field(..., ge=0, description="Number of meals suggested")
    meals: List[SuggestedMealResponse] = Field(..., description="List of suggested meals")
    daily_totals: NutritionTotalsResponse = Field(..., description="Total nutrition for all suggested meals")
    target_totals: NutritionTotalsResponse = Field(..., description="Target nutrition based on user goals")
    
    class Config:
        json_schema_extra = {
            "example": {
                "date": "2024-01-15",
                "meal_count": 4,
                "meals": [],  # Would contain SuggestedMealResponse objects
                "daily_totals": {
                    "calories": 2450.0,
                    "protein": 122.0,
                    "carbs": 295.0,
                    "fat": 82.0
                },
                "target_totals": {
                    "calories": 2500.0,
                    "protein": 125.0,
                    "carbs": 300.0,
                    "fat": 83.0
                }
            }
        }


class SingleMealSuggestionResponse(BaseModel):
    """Response DTO for a single meal suggestion."""
    meal: SuggestedMealResponse = Field(..., description="Suggested meal details")


class MealSuggestionErrorResponse(BaseModel):
    """Response DTO for meal suggestion errors."""
    error: str = Field(..., description="Error type")
    message: str = Field(..., description="Error message")
    details: Optional[Dict] = Field(None, description="Additional error details")


class UserMealPlanSummaryResponse(BaseModel):
    """Response DTO for user meal plan summary."""
    user_profile_id: str = Field(..., description="User profile ID")
    total_suggestions_generated: int = Field(..., ge=0, description="Total suggestions generated")
    average_daily_calories: float = Field(..., ge=0, description="Average daily calories")
    preferred_meal_types: List[str] = Field(..., description="Most suggested meal types")
    common_ingredients: List[str] = Field(..., description="Most common ingredients")
    dietary_compliance: Dict[str, bool] = Field(..., description="Dietary preference compliance")


class QuickMealIdeaResponse(BaseModel):
    """Response DTO for a quick meal idea with enriched data."""
    meal_id: str = Field(..., description="Unique meal identifier")
    name: str = Field(..., description="Meal name")
    description: str = Field(..., description="Short tagline (10 words max)")
    time_minutes: int = Field(..., ge=0, description="Total cooking time in minutes")
    calories: int = Field(..., ge=0, description="Estimated calories")
    protein_g: float = Field(..., ge=0, description="Protein in grams")
    carbs_g: float = Field(..., ge=0, description="Carbohydrates in grams")
    fat_g: float = Field(..., ge=0, description="Fat in grams")
    pairs_with: List[str] = Field(
        default_factory=list,
        description="3-5 complementary ingredients"
    )
    quick_recipe: List[str] = Field(
        default_factory=list,
        description="4-6 simple cooking steps"
    )
    tags: List[str] = Field(
        default_factory=list,
        description="Tags like 'quick', 'high-protein'"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "meal_id": "123e4567-e89b-12d3-a456-426614174000",
                "name": "Chicken Stir-Fry",
                "description": "Quick, flavorful, pairs with rice",
                "time_minutes": 15,
                "calories": 420,
                "protein_g": 35.0,
                "carbs_g": 25.0,
                "fat_g": 18.0,
                "pairs_with": ["avocado", "lemon", "cherry tomatoes", "feta cheese"],
                "quick_recipe": [
                    "Season chicken with salt and pepper",
                    "Heat pan with olive oil over high heat",
                    "Stir-fry chicken until golden (5 min)",
                    "Add vegetables and sauce",
                    "Serve immediately"
                ],
                "tags": ["quick", "high-protein", "low-carb"]
            }
        }


class QuickMealSuggestionsResponse(BaseModel):
    """Response DTO for quick meal suggestions."""
    success: bool = Field(True, description="Whether generation was successful")
    meal_type: str = Field(..., description="Type of meal requested")
    ingredients: List[str] = Field(..., description="Ingredients used in search")
    time_filter: Optional[str] = Field(None, description="Time filter applied")
    meals: List[QuickMealIdeaResponse] = Field(..., description="List of meal ideas")
    displayed_count: int = Field(..., ge=0, description="Number of meals currently displayed")
    total_count: int = Field(..., ge=0, description="Total number of meals available")
    has_more: bool = Field(False, description="Whether more meals are available")

    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "meal_type": "lunch",
                "ingredients": ["chicken"],
                "time_filter": "quick",
                "meals": [],
                "displayed_count": 3,
                "total_count": 6,
                "has_more": True
            }
        }
</file>

<file path="src/api/schemas/response/ingredient_recognition_responses.py">
"""
Ingredient recognition response DTOs.
"""
from typing import Optional
from enum import Enum

from pydantic import BaseModel, Field


class IngredientCategoryEnum(str, Enum):
    """Category of identified ingredient."""
    VEGETABLE = "vegetable"
    FRUIT = "fruit"
    PROTEIN = "protein"
    GRAIN = "grain"
    DAIRY = "dairy"
    SEASONING = "seasoning"
    OTHER = "other"


class IngredientRecognitionResponse(BaseModel):
    """Response from ingredient recognition."""

    name: Optional[str] = Field(
        None,
        description="Identified ingredient name in English (lowercase)"
    )
    confidence: float = Field(
        0.0,
        ge=0.0,
        le=1.0,
        description="Confidence score between 0 and 1"
    )
    category: Optional[IngredientCategoryEnum] = Field(
        None,
        description="Category of the identified ingredient"
    )
    success: bool = Field(
        True,
        description="Whether recognition was successful"
    )
    message: Optional[str] = Field(
        None,
        description="Additional message (e.g., error details)"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "name": "chicken breast",
                "confidence": 0.92,
                "category": "protein",
                "success": True,
                "message": None
            }
        }
</file>

<file path="src/api/schemas/response/meal_responses.py">
"""
Meal-related response DTOs.
"""
from datetime import datetime
from enum import Enum
from typing import Optional, List, Union

from pydantic import BaseModel, Field


class MealStatusEnum(str, Enum):
    """Enum for meal processing status."""
    pending = "pending"
    analyzing = "analyzing"
    ready = "ready"
    failed = "failed"




class MacrosResponse(BaseModel):
    """Response DTO for macronutrient information."""
    protein: float = Field(..., ge=0, description="Protein in grams")
    carbs: float = Field(..., ge=0, description="Carbohydrates in grams") 
    fat: float = Field(..., ge=0, description="Fat in grams")


class NutritionResponse(BaseModel):
    """Response DTO for nutrition information."""
    nutrition_id: str = Field(..., description="Nutrition record ID")
    calories: float = Field(..., ge=0, description="Calories")
    protein_g: float = Field(..., ge=0, description="Protein in grams")
    carbs_g: float = Field(..., ge=0, description="Carbohydrates in grams")
    fat_g: float = Field(..., ge=0, description="Fat in grams")


class CustomNutritionResponse(BaseModel):
    """Response DTO for custom nutrition per 100g."""
    calories_per_100g: float = Field(..., description="Calories per 100g")
    protein_per_100g: float = Field(..., description="Protein per 100g")
    carbs_per_100g: float = Field(..., description="Carbs per 100g")
    fat_per_100g: float = Field(..., description="Fat per 100g")


class FoodItemResponse(BaseModel):
    """Response DTO for food item information."""
    id: str = Field(..., description="Food item ID")
    name: str = Field(..., description="Food item name")
    category: Optional[str] = Field(None, description="Food category")
    quantity: float = Field(..., description="Quantity")
    unit: str = Field(..., description="Unit of measurement")
    description: Optional[str] = Field(None, description="Description")
    nutrition: Optional[NutritionResponse] = Field(None, description="Nutrition information")
    custom_nutrition: Optional[CustomNutritionResponse] = Field(None, description="Custom nutrition per 100g for custom ingredients")
    fdc_id: Optional[int] = Field(None, description="USDA FDC ID if available")
    is_custom: bool = Field(False, description="Whether this is a custom ingredient")


class SimpleMealResponse(BaseModel):
    """Response DTO for basic meal information."""
    meal_id: str = Field(..., description="Meal ID")
    status: MealStatusEnum = Field(..., description="Processing status")
    dish_name: Optional[str] = Field(None, description="Identified dish name")
    ready_at: Optional[datetime] = Field(None, description="When analysis completed")
    error_message: Optional[str] = Field(None, description="Error message if failed")
    created_at: datetime = Field(..., description="Creation timestamp")
    updated_at: Optional[datetime] = Field(None, description="Last update timestamp")


class DetailedMealResponse(SimpleMealResponse):
    """Response DTO for detailed meal information with nutrition."""
    food_items: List[FoodItemResponse] = Field(
        default_factory=list, 
        description="Food items in the meal"
    )
    image_url: Optional[str] = Field(None, description="Meal image URL")
    total_calories: Optional[float] = Field(None, ge=0, description="Total calories")
    total_weight_grams: Optional[float] = Field(None, gt=0, description="Total weight")
    total_nutrition: Optional[MacrosResponse] = Field(None, description="Total macros")


class MealListResponse(BaseModel):
    """Response DTO for paginated meal list."""
    meals: List[Union[SimpleMealResponse, DetailedMealResponse]] = Field(
        ..., 
        description="List of meals"
    )
    total: int = Field(..., ge=0, description="Total number of meals")
    page: int = Field(..., ge=1, description="Current page")
    page_size: int = Field(..., ge=1, le=100, description="Items per page")
    total_pages: int = Field(..., ge=0, description="Total pages")


class MealPhotoAnalysisResponse(BaseModel):
    """Response DTO for meal photo analysis."""
    meal_id: str = Field(..., description="ID of the analyzed meal")
    status: MealStatusEnum = Field(..., description="Analysis status")
    message: str = Field(..., description="Status message")
    estimated_completion_seconds: Optional[int] = Field(
        None, 
        description="Estimated seconds until completion"
    )


class MealSearchResponse(BaseModel):
    """Response DTO for meal search results."""
    results: List[SimpleMealResponse] = Field(..., description="Search results")
    query: str = Field(..., description="Original search query")
    total_results: int = Field(..., ge=0, description="Total matching results")


class NutritionSummaryResponse(BaseModel):
    """Response DTO for simplified nutrition summary."""
    meal_name: str = Field(..., description="Identified meal name")
    total_calories: float = Field(..., ge=0, description="Total calories")
    total_weight_grams: float = Field(..., gt=0, description="Total weight in grams")
    calories_per_100g: float = Field(..., ge=0, description="Calories per 100g")
    macros_per_100g: MacrosResponse = Field(..., description="Macronutrients per 100g")
    total_macros: MacrosResponse = Field(..., description="Total macronutrients")
    confidence_score: float = Field(..., ge=0, le=1, description="AI analysis confidence")


class ManualMealCreationResponse(BaseModel):
    """Response DTO for manual meal creation."""
    meal_id: str = Field(..., description="Created meal ID")
    status: str = Field(..., description="Creation status")
    message: str = Field(..., description="Success message")
    created_at: datetime = Field(..., description="Creation timestamp")
</file>

<file path="src/api/schemas/response/tdee_responses.py">
"""
TDEE calculation response DTOs.
"""
from typing import Optional, List, Dict

from pydantic import BaseModel, Field

from src.api.schemas.request.tdee_requests import GoalEnum


class MacroTargetsResponse(BaseModel):
    """Response DTO for macro targets matching Flutter MacroTargets."""
    calories: float = Field(..., ge=0, description="Daily calorie target")
    protein: float = Field(..., ge=0, description="Protein in grams per day")
    fat: float = Field(..., ge=0, description="Fat in grams per day")
    carbs: float = Field(..., ge=0, description="Carbohydrates in grams per day")
    
    class Config:
        json_schema_extra = {
            "example": {
                "calories": 2500.0,
                "protein": 125.0,
                "fat": 83.3,
                "carbs": 300.0
            }
        }


class TdeeCalculationResponse(BaseModel):
    """Response DTO for TDEE calculation matching Flutter TdeeResult."""
    bmr: float = Field(..., gt=0, description="Basal Metabolic Rate")
    tdee: float = Field(..., gt=0, description="Total Daily Energy Expenditure")
    macros: MacroTargetsResponse = Field(..., description="Macro targets for the goal")
    goal: GoalEnum = Field(..., description="Goal used for calculation")
    
    # Additional useful information
    activity_multiplier: Optional[float] = Field(
        None, 
        description="Activity level multiplier used"
    )
    formula_used: Optional[str] = Field(
        None, 
        description="Formula used (Mifflin-St Jeor or Katch-McArdle)"
    )
    
    class Config:
        json_schema_extra = {
            "example": {
                "bmr": 1750.0,
                "tdee": 2450.0,
                "macros": {
                    "calories": 2450.0,
                    "protein": 122.5,
                    "fat": 81.7,
                    "carbs": 294.0
                },
                "goal": "recomp",
                "activity_multiplier": 1.4,
                "formula_used": "Mifflin-St Jeor"
            }
        }


class BatchTdeeCalculationResponse(BaseModel):
    """Response DTO for batch TDEE calculations."""
    results: List[TdeeCalculationResponse] = Field(
        ..., 
        description="List of TDEE calculation results"
    )
    total_calculations: int = Field(..., ge=0, description="Total calculations performed")


class TdeeComparisonResponse(BaseModel):
    """Response DTO for comparing TDEE calculations."""
    current: TdeeCalculationResponse = Field(..., description="Current TDEE calculation")
    previous: Optional[TdeeCalculationResponse] = Field(
        None, 
        description="Previous TDEE calculation for comparison"
    )
    changes: Optional[Dict] = Field(
        None,
        description="Changes between calculations"
    )


class TdeeHistoryResponse(BaseModel):
    """Response DTO for TDEE calculation history."""
    user_id: str = Field(..., description="User ID")
    calculations: List[Dict] = Field(..., description="List of historical calculations")
    total_count: int = Field(..., ge=0, description="Total number of calculations")


class TdeeErrorResponse(BaseModel):
    """Response DTO for TDEE calculation errors."""
    error: str = Field(..., description="Error type")
    message: str = Field(..., description="Error message")
    field: Optional[str] = Field(None, description="Field that caused the error")
</file>

<file path="src/api/schemas/response/weekly_meal_plan_responses.py">
"""
Response schemas for weekly meal plan generation.
"""
from typing import Dict, List, Optional

from pydantic import BaseModel, Field


class WeeklyMealResponse(BaseModel):
    """Response for a single meal in the weekly plan."""
    day: str = Field(..., description="Day of the week (Monday, Tuesday, etc.)")
    meal_type: str = Field(..., description="Type of meal (breakfast, lunch, dinner, snack)")
    name: str = Field(..., description="Name of the meal")
    description: str = Field(..., description="Brief description of the meal")
    prep_time: int = Field(..., description="Preparation time in minutes")
    cook_time: int = Field(..., description="Cooking time in minutes")
    calories: int = Field(..., description="Calories per serving")
    protein: float = Field(..., description="Protein content in grams")
    carbs: float = Field(..., description="Carbohydrate content in grams")
    fat: float = Field(..., description="Fat content in grams")
    ingredients: List[str] = Field(..., description="List of ingredients")
    instructions: List[str] = Field(..., description="Cooking instructions")
    is_vegetarian: bool = Field(..., description="Whether the meal is vegetarian")
    is_vegan: bool = Field(..., description="Whether the meal is vegan")
    is_gluten_free: bool = Field(..., description="Whether the meal is gluten-free")
    cuisine_type: str = Field(..., description="Type of cuisine")


class NutritionInfo(BaseModel):
    """Nutrition information."""
    calories: int = Field(..., description="Total calories")
    protein: float = Field(..., description="Total protein in grams")
    carbs: float = Field(..., description="Total carbohydrates in grams")
    fat: float = Field(..., description="Total fat in grams")


class UserPreferencesResponse(BaseModel):
    """User preferences used for meal planning."""
    dietary_preferences: List[str] = Field(..., description="Dietary restrictions and preferences")
    health_conditions: List[str] = Field(..., description="Health conditions")
    allergies: List[str] = Field(..., description="Food allergies")
    activity_level: str = Field(..., description="Activity level")
    fitness_goal: str = Field(..., description="Fitness goal")
    meals_per_day: int = Field(..., description="Number of meals per day")
    snacks_per_day: int = Field(..., description="Number of snacks per day")


class WeeklyMealPlanResponse(BaseModel):
    """Response for weekly meal plan generation."""
    user_id: str = Field(..., description="User ID")
    plan_type: str = Field(..., description="Type of plan (weekly)")
    start_date: str = Field(..., description="Start date of the plan (Monday)")
    end_date: str = Field(..., description="End date of the plan (Sunday)")
    days: Dict[str, List[WeeklyMealResponse]] = Field(..., description="Meals organized by day")
    meals: List[WeeklyMealResponse] = Field(..., description="All meals in the plan")
    total_nutrition: NutritionInfo = Field(..., description="Total nutrition for the entire week")
    daily_average_nutrition: NutritionInfo = Field(..., description="Average daily nutrition")
    target_nutrition: NutritionInfo = Field(..., description="Target nutrition goals")
    user_preferences: UserPreferencesResponse = Field(..., description="User preferences used")
    plan_id: Optional[str] = Field(None, description="Database plan ID if saved")

    class Config:
        json_schema_extra = {
            "example": {
                "user_id": "user123",
                "plan_type": "weekly",
                "start_date": "2024-01-15",
                "end_date": "2024-01-21",
                "days": {
                    "Monday": [
                        {
                            "day": "Monday",
                            "meal_type": "breakfast",
                            "name": "Protein Oatmeal Bowl",
                            "description": "Hearty oatmeal with protein powder and fruits",
                            "prep_time": 5,
                            "cook_time": 5,
                            "calories": 450,
                            "protein": 25.0,
                            "carbs": 55.0,
                            "fat": 15.0,
                            "ingredients": ["60g rolled oats", "30g protein powder", "1 medium banana"],
                            "instructions": ["Cook oats with water", "Stir in protein powder"],
                            "is_vegetarian": True,
                            "is_vegan": False,
                            "is_gluten_free": False,
                            "cuisine_type": "International"
                        }
                    ]
                },
                "meals": [],
                "total_nutrition": {
                    "calories": 14000,
                    "protein": 875.0,
                    "carbs": 1750.0,
                    "fat": 490.0
                },
                "daily_average_nutrition": {
                    "calories": 2000,
                    "protein": 125.0,
                    "carbs": 250.0,
                    "fat": 70.0
                },
                "target_nutrition": {
                    "calories": 2000,
                    "protein": 150.0,
                    "carbs": 250.0,
                    "fat": 70.0
                },
                "user_preferences": {
                    "dietary_preferences": ["vegetarian"],
                    "health_conditions": [],
                    "allergies": ["nuts"],
                    "activity_level": "moderate",
                    "fitness_goal": "recomp",
                    "meals_per_day": 3,
                    "snacks_per_day": 1
                }
            }
        }
</file>

<file path="src/app/commands/chat/__init__.py">
"""Chat commands."""
from .create_thread_command import CreateThreadCommand
from .send_message_command import SendMessageCommand
from .delete_thread_command import DeleteThreadCommand

__all__ = [
    "CreateThreadCommand",
    "SendMessageCommand",
    "DeleteThreadCommand",
]
</file>

<file path="src/app/commands/chat/create_thread_command.py">
"""
Command to create a new chat thread.
"""
from dataclasses import dataclass
from typing import Optional, Dict, Any

from src.app.events.base import Command


@dataclass
class CreateThreadCommand(Command):
    """Command to create a new chat thread."""
    user_id: str
    title: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None
</file>

<file path="src/app/commands/chat/delete_thread_command.py">
"""
Command to delete a chat thread.
"""
from dataclasses import dataclass

from src.app.events.base import Command


@dataclass
class DeleteThreadCommand(Command):
    """Command to delete a chat thread (soft delete)."""
    thread_id: str
    user_id: str  # For authorization
</file>

<file path="src/app/commands/chat/send_message_command.py">
"""
Command to send a message in a chat thread.
"""
from dataclasses import dataclass
from typing import Optional, Dict, Any

from src.app.events.base import Command


@dataclass
class SendMessageCommand(Command):
    """Command to send a message in a thread."""
    thread_id: str
    user_id: str  # For authorization
    content: str
    metadata: Optional[Dict[str, Any]] = None
</file>

<file path="src/app/commands/ingredient/__init__.py">
"""
Ingredient commands.
"""
from .recognize_ingredient_command import RecognizeIngredientCommand

__all__ = [
    "RecognizeIngredientCommand",
]
</file>

<file path="src/app/commands/ingredient/recognize_ingredient_command.py">
"""
Command for recognizing an ingredient from an image.
"""
from dataclasses import dataclass

from src.app.events.base import Command


@dataclass
class RecognizeIngredientCommand(Command):
    """
    Command to recognize an ingredient from an image.

    Uses Gemini Vision AI to identify the primary food ingredient
    in the provided image data.
    """

    image_data: str  # Base64 encoded image
</file>

<file path="src/app/commands/meal/create_manual_meal_command.py">
"""
Command to create a manual meal from a list of USDA FDC items with portions.
"""
from dataclasses import dataclass
from datetime import date
from typing import List, Optional

from src.app.events.base import Command


@dataclass
class ManualMealItem:
    fdc_id: int
    quantity: float  # in grams or unit-specified grams base
    unit: str        # unit name, e.g., "g"


@dataclass
class CreateManualMealCommand(Command):
    user_id: str
    items: List[ManualMealItem]
    dish_name: str
    meal_type: Optional[str] = None
    target_date: Optional[date] = None
</file>

<file path="src/app/commands/meal_suggestion/accept_suggestion_command.py">
"""Accept suggestion command."""
from dataclasses import dataclass
from datetime import datetime
from typing import Optional


@dataclass
class AcceptSuggestionCommand:
    """Command to accept suggestion with portion multiplier."""

    user_id: str
    suggestion_id: str
    portion_multiplier: int
    consumed_at: Optional[datetime]
</file>

<file path="src/app/commands/meal_suggestion/discard_session_command.py">
"""Discard session command."""
from dataclasses import dataclass


@dataclass
class DiscardSessionCommand:
    """Command to discard entire suggestion session."""

    user_id: str
    session_id: str
</file>

<file path="src/app/commands/meal_suggestion/regenerate_suggestions_command.py">
"""Regenerate suggestions command."""
from dataclasses import dataclass
from typing import List


@dataclass
class RegenerateSuggestionsCommand:
    """Command to regenerate 3 NEW suggestions (excludes shown)."""

    user_id: str
    session_id: str
    exclude_ids: List[str]
</file>

<file path="src/app/commands/meal_suggestion/reject_suggestion_command.py">
"""Reject suggestion command."""
from dataclasses import dataclass
from typing import Optional


@dataclass
class RejectSuggestionCommand:
    """Command to reject suggestion with optional feedback."""

    user_id: str
    suggestion_id: str
    feedback: Optional[str]
</file>

<file path="src/app/commands/notification/__init__.py">
"""
Notification commands package.
"""
from .delete_fcm_token_command import DeleteFcmTokenCommand
from .register_fcm_token_command import RegisterFcmTokenCommand
from .update_notification_preferences_command import UpdateNotificationPreferencesCommand

__all__ = [
    'RegisterFcmTokenCommand',
    'DeleteFcmTokenCommand',
    'UpdateNotificationPreferencesCommand',
]
</file>

<file path="src/app/commands/notification/delete_fcm_token_command.py">
"""
Command to delete an FCM token.
"""
from dataclasses import dataclass

from src.app.events.base import Command


@dataclass
class DeleteFcmTokenCommand(Command):
    """Command to delete an FCM token."""
    user_id: str
    fcm_token: str
</file>

<file path="src/app/commands/notification/update_notification_preferences_command.py">
"""
Command to update notification preferences.
"""
from dataclasses import dataclass
from typing import Optional

from src.app.events.base import Command


@dataclass
class UpdateNotificationPreferencesCommand(Command):
    """Command to update notification preferences."""
    user_id: str
    meal_reminders_enabled: Optional[bool] = None
    water_reminders_enabled: Optional[bool] = None
    sleep_reminders_enabled: Optional[bool] = None
    progress_notifications_enabled: Optional[bool] = None
    reengagement_notifications_enabled: Optional[bool] = None
    breakfast_time_minutes: Optional[int] = None
    lunch_time_minutes: Optional[int] = None
    dinner_time_minutes: Optional[int] = None
    water_reminder_interval_hours: Optional[int] = None
    sleep_reminder_time_minutes: Optional[int] = None
</file>

<file path="src/app/commands/user/__init__.py">
"""User commands."""
from .complete_onboarding_command import CompleteOnboardingCommand
from .delete_user_command import DeleteUserCommand
from .save_user_onboarding_command import SaveUserOnboardingCommand

__all__ = [
    "SaveUserOnboardingCommand",
    "CompleteOnboardingCommand",
    "DeleteUserCommand",
]
</file>

<file path="src/app/commands/user/delete_user_command.py">
"""Delete user account command."""
from dataclasses import dataclass


@dataclass
class DeleteUserCommand:
    """Command to delete a user account (soft delete in DB, hard delete in Firebase)."""

    firebase_uid: str
</file>

<file path="src/app/commands/user/save_user_onboarding_command.py">
"""
Save user onboarding command.
"""
from dataclasses import dataclass
from typing import Optional, List

from src.app.events.base import Command


@dataclass
class SaveUserOnboardingCommand(Command):
    """Command to save user onboarding data."""
    user_id: str
    # Personal info
    age: int
    gender: str
    height_cm: float
    weight_kg: float

    # Goals
    activity_level: str
    fitness_goal: str

    # Preferences - REQUIRED
    pain_points: List[str]
    dietary_preferences: List[str]

    # Meal preferences
    meals_per_day: int = 3

    # Optional fields
    body_fat_percentage: Optional[float] = None
</file>

<file path="src/app/commands/__init__.py">
"""
Command definitions for CQRS pattern.
"""
# Import from daily_meal module
from .daily_meal import (
    GenerateDailyMealSuggestionsCommand,
    GenerateSingleMealCommand,
)

# Import from meal_plan module
from .meal_plan import (
    GenerateWeeklyIngredientBasedMealPlanCommand,
)

# Import from meal_suggestion module
from .meal_suggestion import (
    GenerateMealSuggestionsCommand,
    SaveMealSuggestionCommand,
)
# TDEE commands removed - not used in API
# Import from user module
from .user import (
    SaveUserOnboardingCommand,
)

__all__ = [
    # Daily meal commands
    "GenerateDailyMealSuggestionsCommand",
    "GenerateSingleMealCommand",
    # User commands
    "SaveUserOnboardingCommand",
    # Meal plan commands
    "GenerateWeeklyIngredientBasedMealPlanCommand",
    # Meal suggestion commands
    "GenerateMealSuggestionsCommand",
    "SaveMealSuggestionCommand",
]
</file>

<file path="src/app/events/chat_events.py">
"""
Domain events for chat feature.
"""
from dataclasses import dataclass
from typing import Dict, Any

from src.app.events.base import DomainEvent


@dataclass
class MessageSentEvent(DomainEvent):
    """Event fired when a message is sent."""
    thread_id: str
    message_id: str
    user_id: str
    role: str
    content: str
    metadata: Dict[str, Any]


@dataclass
class ThreadCreatedEvent(DomainEvent):
    """Event fired when a thread is created."""
    thread_id: str
    user_id: str
    title: str


@dataclass
class ThreadDeletedEvent(DomainEvent):
    """Event fired when a thread is deleted."""
    thread_id: str
    user_id: str
</file>

<file path="src/app/handlers/command_handlers/chat/__init__.py">
"""Chat command handlers."""
from .create_thread_command_handler import CreateThreadCommandHandler
from .send_message_command_handler import SendMessageCommandHandler
from .delete_thread_command_handler import DeleteThreadCommandHandler

__all__ = [
    "CreateThreadCommandHandler",
    "SendMessageCommandHandler",
    "DeleteThreadCommandHandler",
]
</file>

<file path="src/app/handlers/command_handlers/chat/delete_thread_command_handler.py">
"""
Handler for deleting a chat thread.
"""
import logging
from typing import Dict, Any

from src.api.exceptions import ResourceNotFoundException, ValidationException
from src.app.commands.chat import DeleteThreadCommand
from src.app.events.base import EventHandler, handles
from src.domain.ports.chat_repository_port import ChatRepositoryPort

logger = logging.getLogger(__name__)


@handles(DeleteThreadCommand)
class DeleteThreadCommandHandler(EventHandler[DeleteThreadCommand, Dict[str, Any]]):
    """Handler for deleting chat threads."""
    
    def __init__(self, chat_repository: ChatRepositoryPort = None):
        self.chat_repository = chat_repository
    
    def set_dependencies(self, chat_repository: ChatRepositoryPort):
        """Set dependencies for dependency injection."""
        self.chat_repository = chat_repository
    
    async def handle(self, command: DeleteThreadCommand) -> Dict[str, Any]:
        """Delete a thread (soft delete)."""
        if not self.chat_repository:
            raise RuntimeError("Chat repository not configured")
        
        # Find thread
        thread = self.chat_repository.find_thread_by_id(command.thread_id)
        if not thread:
            raise ResourceNotFoundException(
                message="Thread not found",
                details={"thread_id": command.thread_id}
            )
        
        # Verify user owns thread
        if thread.user_id != command.user_id:
            raise ValidationException("User does not have access to this thread")
        
        # Delete thread
        success = self.chat_repository.delete_thread(command.thread_id)
        
        if success:
            logger.info(f"Deleted thread {command.thread_id} for user {command.user_id}")
        
        return {
            "success": success,
            "thread_id": command.thread_id
        }
</file>

<file path="src/app/handlers/command_handlers/accept_suggestion_handler.py">
"""Accept suggestion command handler."""
import logging
from typing import Any, Dict

from src.app.commands.meal_suggestion import AcceptSuggestionCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService

logger = logging.getLogger(__name__)


@handles(AcceptSuggestionCommand)
class AcceptSuggestionHandler(EventHandler[AcceptSuggestionCommand, Dict[str, Any]]):
    """Accept suggestion with portion multiplier."""

    def __init__(self, service: SuggestionOrchestrationService):
        self.service = service

    async def handle(self, command: AcceptSuggestionCommand) -> Dict[str, Any]:
        """Handle accept command."""
        result = await self.service.accept_suggestion(
            user_id=command.user_id,
            suggestion_id=command.suggestion_id,
            portion_multiplier=command.portion_multiplier,
            consumed_at=command.consumed_at,
        )
        return result
</file>

<file path="src/app/handlers/command_handlers/complete_onboarding_command_handler.py">
"""
CompleteOnboardingCommandHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from datetime import datetime
from typing import Dict, Any, Optional

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.commands.user import CompleteOnboardingCommand
from src.app.events.base import EventHandler, handles
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService
from src.infra.database.models.user import User

logger = logging.getLogger(__name__)


@handles(CompleteOnboardingCommand)
class CompleteOnboardingCommandHandler(EventHandler[CompleteOnboardingCommand, Dict[str, Any]]):
    """Handler for marking user onboarding as completed."""

    def __init__(self, db: Session = None, cache_service: Optional[CacheService] = None):
        self.db = db
        self.cache_service = cache_service

    def set_dependencies(self, db: Session, **kwargs):
        """Set dependencies for dependency injection."""
        self.db = db
        self.cache_service = kwargs.get("cache_service", self.cache_service)

    async def handle(self, command: CompleteOnboardingCommand) -> Dict[str, Any]:
        """Mark user onboarding as completed if not already completed."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        try:
            # Find user by firebase_uid
            user = self.db.query(User).filter(
                User.firebase_uid == command.firebase_uid
            ).first()

            if not user:
                raise ResourceNotFoundException(f"User with Firebase UID {command.firebase_uid} not found")

            # Check if onboarding is already completed
            if user.onboarding_completed:
                return {
                    "firebase_uid": command.firebase_uid,
                    "onboarding_completed": True,
                    "updated": False,
                    "message": "Onboarding already completed"
                }

            # Set onboarding as completed
            user.onboarding_completed = True
            user.last_accessed = datetime.utcnow()

            self.db.commit()
            await self._invalidate_user_profile(user.id)

            return {
                "firebase_uid": command.firebase_uid,
                "onboarding_completed": True,
                "updated": True,
                "message": "Onboarding marked as completed"
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error completing onboarding: {str(e)}")
            raise

    async def _invalidate_user_profile(self, user_id: str):
        if not self.cache_service:
            return
        cache_key, _ = CacheKeys.user_profile(user_id)
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/delete_fcm_token_command_handler.py">
"""
Handler for deleting FCM tokens.
"""
import logging
from typing import Any, Dict

from src.app.commands.notification import DeleteFcmTokenCommand
from src.app.events.base import EventHandler, handles
from src.domain.ports.notification_repository_port import NotificationRepositoryPort

logger = logging.getLogger(__name__)


@handles(DeleteFcmTokenCommand)
class DeleteFcmTokenCommandHandler(EventHandler[DeleteFcmTokenCommand, Dict[str, Any]]):
    """Handler for deleting FCM tokens."""
    
    def __init__(self, notification_repository: NotificationRepositoryPort = None):
        self.notification_repository = notification_repository
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.notification_repository = kwargs.get('notification_repository', self.notification_repository)
    
    async def handle(self, command: DeleteFcmTokenCommand) -> Dict[str, Any]:
        """Handle FCM token deletion."""
        if not self.notification_repository:
            raise RuntimeError("Notification repository not configured")
        
        try:
            # Check if token exists and belongs to user
            existing_token = self.notification_repository.find_fcm_token_by_token(command.fcm_token)
            
            if not existing_token:
                return {
                    "success": False,
                    "message": "Token not found"
                }
            
            if existing_token.user_id != command.user_id:
                return {
                    "success": False,
                    "message": "Token does not belong to user"
                }
            
            # Delete token
            deleted = self.notification_repository.delete_fcm_token(command.fcm_token)
            
            if deleted:
                logger.info(f"FCM token deleted for user {command.user_id}")
                return {
                    "success": True,
                    "message": "Token deleted successfully"
                }
            else:
                return {
                    "success": False,
                    "message": "Failed to delete token"
                }
        except Exception as e:
            logger.error(f"Error deleting FCM token: {e}")
            raise e
</file>

<file path="src/app/handlers/command_handlers/discard_session_handler.py">
"""Discard session command handler."""
import logging

from src.app.commands.meal_suggestion import DiscardSessionCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService

logger = logging.getLogger(__name__)


@handles(DiscardSessionCommand)
class DiscardSessionHandler(EventHandler[DiscardSessionCommand, None]):
    """Discard session."""

    def __init__(self, service: SuggestionOrchestrationService):
        self.service = service

    async def handle(self, command: DiscardSessionCommand) -> None:
        """Handle discard command."""
        await self.service.discard_session(
            user_id=command.user_id,
            session_id=command.session_id,
        )
</file>

<file path="src/app/handlers/command_handlers/generate_daily_meal_suggestions_command_handler.py">
"""
GenerateDailyMealSuggestionsCommandHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from datetime import date
from typing import Dict, Any
from uuid import uuid4

from src.api.exceptions import ValidationException
from src.app.commands.daily_meal import GenerateDailyMealSuggestionsCommand
from src.app.events.base import EventHandler, handles
from src.app.events.daily_meal import DailyMealsGeneratedEvent
from src.domain.mappers.activity_goal_mapper import ActivityGoalMapper
from src.domain.model.meal_planning import SimpleMacroTargets
from src.domain.model.user import TdeeRequest, Sex, UnitSystem
from src.domain.services.daily_meal_suggestion_service import DailyMealSuggestionService
from src.domain.services.tdee_service import TdeeCalculationService

logger = logging.getLogger(__name__)


@handles(GenerateDailyMealSuggestionsCommand)
class GenerateDailyMealSuggestionsCommandHandler(EventHandler[GenerateDailyMealSuggestionsCommand, Dict[str, Any]]):
    """Handler for generating daily meal suggestions."""

    def __init__(self, suggestion_service=None, tdee_service=None):
        self.suggestion_service = suggestion_service or DailyMealSuggestionService()
        self.tdee_service = tdee_service or TdeeCalculationService()

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        if 'suggestion_service' in kwargs:
            self.suggestion_service = kwargs['suggestion_service']
        if 'tdee_service' in kwargs:
            self.tdee_service = kwargs['tdee_service']

    async def handle(self, command: GenerateDailyMealSuggestionsCommand) -> Dict[str, Any]:
        """Generate daily meal suggestions based on user preferences."""
        # Validate input
        if command.age < 1 or command.age > 120:
            raise ValidationException("Age must be between 1 and 120")

        if command.height <= 0:
            raise ValidationException("Height must be greater than 0")

        if command.weight <= 0:
            raise ValidationException("Weight must be greater than 0")

        # Prepare user data
        user_data = {
            "age": command.age,
            "gender": command.gender,
            "height": command.height,
            "weight": command.weight,
            "activity_level": command.activity_level,
            "goal": command.goal,
            "dietary_preferences": command.dietary_preferences or [],
            "health_conditions": command.health_conditions or [],
        }

        # Calculate TDEE and macros if not provided
        if not command.target_calories or not command.target_macros:
            tdee_result = self._calculate_tdee_and_macros(command)
            user_data["target_calories"] = tdee_result["target_calories"]
            user_data["target_macros"] = SimpleMacroTargets(**tdee_result["macros"])
        else:
            user_data["target_calories"] = command.target_calories
            user_data["target_macros"] = SimpleMacroTargets(**command.target_macros) if command.target_macros else None

        # Generate meal suggestions
        suggested_meals = self.suggestion_service.generate_daily_suggestions(user_data)

        # Calculate totals
        total_calories = sum(meal.calories for meal in suggested_meals)
        total_protein = sum(meal.protein for meal in suggested_meals)
        total_carbs = sum(meal.carbs for meal in suggested_meals)
        total_fat = sum(meal.fat for meal in suggested_meals)

        # Format meals for response
        meals = []
        meal_ids = []
        for meal in suggested_meals:
            meal_dict = self._format_meal(meal)
            meals.append(meal_dict)
            meal_ids.append(meal.meal_id if hasattr(meal, 'meal_id') else meal.id)

        # Format meals for test compatibility
        suggestions = []
        for meal_dict in meals:
            suggestion = {
                "meal_type": meal_dict["meal_type"],
                "dish_name": meal_dict["name"],
                "calories": meal_dict["calories"],
                "macros": {
                    "protein": meal_dict["protein"],
                    "carbs": meal_dict["carbs"],
                    "fat": meal_dict["fat"]
                }
            }
            suggestions.append(suggestion)

        result = {
            "success": True,
            "date": date.today().isoformat(),
            "meal_count": len(meals),
            "meals": meals,
            "suggestions": suggestions,  # For test compatibility
            "total_calories": round(total_calories, 1),
            "total_macros": {
                "protein": round(total_protein, 1),
                "carbs": round(total_carbs, 1),
                "fat": round(total_fat, 1)
            },
            "daily_totals": {
                "calories": round(total_calories, 1),
                "protein": round(total_protein, 1),
                "carbs": round(total_carbs, 1),
                "fat": round(total_fat, 1)
            },
            "target_totals": {
                "calories": user_data["target_calories"],
                "protein": user_data["target_macros"].protein if user_data["target_macros"] else 0,
                "carbs": user_data["target_macros"].carbs if user_data["target_macros"] else 0,
                "fat": user_data["target_macros"].fat if user_data["target_macros"] else 0
            },
            "events": [
                DailyMealsGeneratedEvent(
                    aggregate_id=str(uuid4()),
                    user_id=str(uuid4()),
                    date=date.today().isoformat(),
                    meal_count=len(meals),
                    total_calories=total_calories,
                    meal_ids=meal_ids
                )
            ]
        }

        return result

    def _calculate_tdee_and_macros(self, command: GenerateDailyMealSuggestionsCommand) -> Dict[str, Any]:
        """Calculate TDEE and macros from command data."""
        # Map to TDEE enums
        sex = Sex.MALE if command.gender.lower() == "male" else Sex.FEMALE

        tdee_request = TdeeRequest(
            age=command.age,
            sex=sex,
            height=command.height,  # height is in cm since unit_system is METRIC
            weight=command.weight,  # weight is in kg since unit_system is METRIC
            activity_level=ActivityGoalMapper.map_activity_level(command.activity_level),
            goal=ActivityGoalMapper.map_goal(command.goal),
            body_fat_pct=None,
            unit_system=UnitSystem.METRIC
        )

        tdee_result = self.tdee_service.calculate_tdee(tdee_request)

        return {
            "target_calories": int(tdee_result.macros.calories),
            "macros": {
                "protein": tdee_result.macros.protein,
                "carbs": tdee_result.macros.carbs,
                "fat": tdee_result.macros.fat
            }
        }

    def _format_meal(self, meal) -> Dict[str, Any]:
        """Format meal for response."""
        # PlannedMeal has prep_time and cook_time attributes directly
        prep_time = meal.prep_time if hasattr(meal, 'prep_time') else 0
        cook_time = meal.cook_time if hasattr(meal, 'cook_time') else 0
        total_time = meal.total_time if hasattr(meal, 'total_time') else prep_time + cook_time

        # PlannedMeal has is_vegetarian, is_vegan, is_gluten_free as boolean attributes
        is_vegetarian = meal.is_vegetarian if hasattr(meal, 'is_vegetarian') else False
        is_vegan = meal.is_vegan if hasattr(meal, 'is_vegan') else False
        is_gluten_free = meal.is_gluten_free if hasattr(meal, 'is_gluten_free') else False

        # Extract cuisine type
        cuisine_type = meal.cuisine_type if hasattr(meal, 'cuisine_type') else None

        return {
            "meal_id": meal.meal_id if hasattr(meal, 'meal_id') else meal.id,
            "meal_type": meal.meal_type.value,
            "name": meal.name,
            "description": meal.description,
            "prep_time": prep_time,
            "cook_time": cook_time,
            "total_time": total_time,
            "calories": int(meal.calories),
            "protein": meal.protein,
            "carbs": meal.carbs,
            "fat": meal.fat,
            "ingredients": meal.ingredients,
            "instructions": meal.instructions if hasattr(meal, 'instructions') else [],
            "is_vegetarian": is_vegetarian,
            "is_vegan": is_vegan,
            "is_gluten_free": is_gluten_free,
            "cuisine_type": cuisine_type
        }
</file>

<file path="src/app/handlers/command_handlers/generate_single_meal_command_handler.py">
"""
GenerateSingleMealCommandHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from src.app.commands.daily_meal import GenerateSingleMealCommand
from src.app.events.base import EventHandler, handles
from src.app.handlers.command_handlers.generate_daily_meal_suggestions_command_handler import \
    GenerateDailyMealSuggestionsCommandHandler
from src.domain.model.meal_planning import SimpleMacroTargets
from src.domain.services.daily_meal_suggestion_service import DailyMealSuggestionService
from src.domain.services.tdee_service import TdeeCalculationService

logger = logging.getLogger(__name__)


@handles(GenerateSingleMealCommand)
class GenerateSingleMealCommandHandler(EventHandler[GenerateSingleMealCommand, Dict[str, Any]]):
    """Handler for generating a single meal suggestion."""

    def __init__(self):
        self.suggestion_service = DailyMealSuggestionService()
        self.tdee_service = TdeeCalculationService()

    def set_dependencies(self):
        """No external dependencies needed."""
        pass

    async def handle(self, command: GenerateSingleMealCommand) -> Dict[str, Any]:
        """Generate a single meal suggestion."""
        # Reuse the daily meal handler logic
        daily_handler = GenerateDailyMealSuggestionsCommandHandler()

        # Prepare user data
        user_data = {
            "age": command.age,
            "gender": command.gender,
            "height": command.height,
            "weight": command.weight,
            "activity_level": command.activity_level,
            "goal": command.goal,
            "dietary_preferences": command.dietary_preferences or [],
            "health_conditions": command.health_conditions or [],
        }

        # Calculate TDEE and macros if not provided
        if not command.target_calories or not command.target_macros:
            tdee_result = daily_handler._calculate_tdee_and_macros(command)
            user_data["target_calories"] = tdee_result["target_calories"]
            user_data["target_macros"] = SimpleMacroTargets(**tdee_result["macros"])
        else:
            user_data["target_calories"] = command.target_calories
            user_data["target_macros"] = SimpleMacroTargets(**command.target_macros) if command.target_macros else None

        # Generate suggestions and filter by meal type
        suggested_meals = self.suggestion_service.generate_daily_suggestions(user_data)

        # Find the requested meal type
        for meal in suggested_meals:
            if meal.meal_type.value.lower() == command.meal_type.lower():
                return {
                    "success": True,
                    "meal": daily_handler._format_meal(meal)
                }

        # If not found, generate a specific meal
        # This is a fallback - in reality, the service should handle this
        raise ValueError(f"No {command.meal_type} suggestion was generated")
</file>

<file path="src/app/handlers/command_handlers/get_session_suggestions_handler.py">
"""Get session suggestions query handler."""
import logging
from typing import List, Tuple

from src.app.queries.meal_suggestion import GetSessionSuggestionsQuery
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService
from src.domain.model.meal_suggestion import MealSuggestion, SuggestionSession

logger = logging.getLogger(__name__)


@handles(GetSessionSuggestionsQuery)
class GetSessionSuggestionsHandler(
    EventHandler[GetSessionSuggestionsQuery, Tuple[SuggestionSession, List[MealSuggestion]]]
):
    """Get current session suggestions."""

    def __init__(self, service: SuggestionOrchestrationService):
        self.service = service

    async def handle(
        self, query: GetSessionSuggestionsQuery
    ) -> Tuple[SuggestionSession, List[MealSuggestion]]:
        """Handle query."""
        return await self.service.get_session_suggestions(
            user_id=query.user_id,
            session_id=query.session_id,
        )
</file>

<file path="src/app/handlers/command_handlers/recognize_ingredient_command_handler.py">
"""
Handler for ingredient recognition command.
"""
import base64
import logging
from typing import Dict, Any, Optional

from src.app.commands.ingredient import RecognizeIngredientCommand
from src.app.events.base import EventHandler, handles
from src.domain.ports.vision_ai_service_port import VisionAIServicePort
from src.domain.strategies.meal_analysis_strategy import AnalysisStrategyFactory

logger = logging.getLogger(__name__)


@handles(RecognizeIngredientCommand)
class RecognizeIngredientCommandHandler(EventHandler[RecognizeIngredientCommand, Dict[str, Any]]):
    """Handler for recognizing ingredients from images."""

    def __init__(self, vision_service: VisionAIServicePort = None):
        self.vision_service = vision_service

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.vision_service = kwargs.get('vision_service', self.vision_service)

    async def handle(self, command: RecognizeIngredientCommand) -> Dict[str, Any]:
        """
        Handle ingredient recognition from image.

        Returns:
            Dictionary with:
            - name: Identified ingredient name (or None)
            - confidence: Confidence score (0-1)
            - category: Ingredient category
            - success: Whether recognition was successful
            - message: Optional error/info message
        """
        if not self.vision_service:
            raise RuntimeError("Vision service not configured")

        try:
            # Decode base64 image
            try:
                image_bytes = base64.b64decode(command.image_data)
            except Exception as e:
                logger.warning(f"Failed to decode image data: {e}")
                return {
                    "name": None,
                    "confidence": 0.0,
                    "category": None,
                    "success": False,
                    "message": "Invalid image data format"
                }

            # Validate image size (max 5MB)
            max_size_bytes = 5 * 1024 * 1024
            if len(image_bytes) > max_size_bytes:
                return {
                    "name": None,
                    "confidence": 0.0,
                    "category": None,
                    "success": False,
                    "message": "Image too large (max 5MB)"
                }

            # Use the ingredient identification strategy
            strategy = AnalysisStrategyFactory.create_ingredient_identification_strategy()
            result = self.vision_service.analyze_with_strategy(image_bytes, strategy)

            # Parse structured_data from response
            data = result.get("structured_data", {})
            name = data.get("name")
            confidence = data.get("confidence", 0.0)
            category = data.get("category")

            # Determine success
            success = name is not None and confidence > 0.3

            logger.info(
                f"Ingredient recognition completed: name={name}, "
                f"confidence={confidence:.2f}, category={category}"
            )

            return {
                "name": name,
                "confidence": confidence,
                "category": category,
                "success": success,
                "message": None if success else "Could not identify ingredient"
            }

        except Exception as e:
            logger.error(f"Ingredient recognition failed: {e}")
            return {
                "name": None,
                "confidence": 0.0,
                "category": None,
                "success": False,
                "message": f"Recognition failed: {str(e)}"
            }
</file>

<file path="src/app/handlers/command_handlers/regenerate_suggestions_handler.py">
"""Regenerate suggestions handler."""
import logging
from typing import List, Tuple

from src.app.commands.meal_suggestion import RegenerateSuggestionsCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService
from src.domain.model.meal_suggestion import MealSuggestion, SuggestionSession

logger = logging.getLogger(__name__)


@handles(RegenerateSuggestionsCommand)
class RegenerateSuggestionsHandler(
    EventHandler[RegenerateSuggestionsCommand, Tuple[SuggestionSession, List[MealSuggestion]]]
):
    """Regenerate 3 NEW suggestions excluding shown."""

    def __init__(self, service: SuggestionOrchestrationService):
        self.service = service

    async def handle(
        self, command: RegenerateSuggestionsCommand
    ) -> Tuple[SuggestionSession, List[MealSuggestion]]:
        """Handle regenerate command."""
        return await self.service.regenerate_suggestions(
            user_id=command.user_id,
            session_id=command.session_id,
            exclude_ids=command.exclude_ids,
        )
</file>

<file path="src/app/handlers/command_handlers/reject_suggestion_handler.py">
"""Reject suggestion command handler."""
import logging

from src.app.commands.meal_suggestion import RejectSuggestionCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService

logger = logging.getLogger(__name__)


@handles(RejectSuggestionCommand)
class RejectSuggestionHandler(EventHandler[RejectSuggestionCommand, None]):
    """Reject suggestion."""

    def __init__(self, service: SuggestionOrchestrationService):
        self.service = service

    async def handle(self, command: RejectSuggestionCommand) -> None:
        """Handle reject command."""
        await self.service.reject_suggestion(
            user_id=command.user_id,
            suggestion_id=command.suggestion_id,
            feedback=command.feedback,
        )
</file>

<file path="src/app/handlers/command_handlers/update_notification_preferences_command_handler.py">
"""
Handler for updating notification preferences.
"""
import logging
from typing import Any, Dict

from src.app.commands.notification import UpdateNotificationPreferencesCommand
from src.app.events.base import EventHandler, handles
from src.domain.model.notification import NotificationPreferences
from src.domain.ports.notification_repository_port import NotificationRepositoryPort

logger = logging.getLogger(__name__)


@handles(UpdateNotificationPreferencesCommand)
class UpdateNotificationPreferencesCommandHandler(EventHandler[UpdateNotificationPreferencesCommand, Dict[str, Any]]):
    """Handler for updating notification preferences."""
    
    def __init__(self, notification_repository: NotificationRepositoryPort = None):
        self.notification_repository = notification_repository
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.notification_repository = kwargs.get('notification_repository', self.notification_repository)
    
    async def handle(self, command: UpdateNotificationPreferencesCommand) -> Dict[str, Any]:
        """Handle notification preferences update."""
        if not self.notification_repository:
            raise RuntimeError("Notification repository not configured")
        
        try:
            # Get existing preferences or create default
            existing_prefs = self.notification_repository.find_notification_preferences_by_user(command.user_id)
            
            if not existing_prefs:
                # Create default preferences
                existing_prefs = NotificationPreferences.create_default(command.user_id)
                saved_prefs = self.notification_repository.save_notification_preferences(existing_prefs)
            else:
                saved_prefs = existing_prefs
            
            # Update preferences with new values
            updated_prefs = saved_prefs.update_preferences(
                meal_reminders_enabled=command.meal_reminders_enabled,
                water_reminders_enabled=command.water_reminders_enabled,
                sleep_reminders_enabled=command.sleep_reminders_enabled,
                progress_notifications_enabled=command.progress_notifications_enabled,
                reengagement_notifications_enabled=command.reengagement_notifications_enabled,
                breakfast_time_minutes=command.breakfast_time_minutes,
                lunch_time_minutes=command.lunch_time_minutes,
                dinner_time_minutes=command.dinner_time_minutes,
                water_reminder_interval_hours=command.water_reminder_interval_hours,
                sleep_reminder_time_minutes=command.sleep_reminder_time_minutes,
            )
            
            # Save updated preferences
            final_prefs = self.notification_repository.save_notification_preferences(updated_prefs)
            
            logger.info(f"Notification preferences updated for user {command.user_id}")
            
            return {
                "success": True,
                "preferences": final_prefs.to_dict()
            }
        except Exception as e:
            logger.error(f"Error updating notification preferences: {e}")
            raise e
</file>

<file path="src/app/handlers/event_handlers/meal_analysis_event_handler.py">
"""
Event handler for meal analysis events.
"""
import logging
from datetime import datetime

from src.app.events.base import EventHandler, handles
from src.app.events.meal import MealImageUploadedEvent
from src.domain.model.meal import MealStatus
from src.domain.parsers.gpt_response_parser import GPTResponseParser
from src.domain.ports.image_store_port import ImageStorePort
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.domain.ports.vision_ai_service_port import VisionAIServicePort
from src.infra.adapters.cloudinary_image_store import CloudinaryImageStore
from src.infra.adapters.vision_ai_service import VisionAIService
from src.infra.repositories.meal_repository import MealRepository

logger = logging.getLogger(__name__)


@handles(MealImageUploadedEvent)
class MealAnalysisEventHandler(EventHandler[MealImageUploadedEvent, None]):
    """Handler for meal analysis events."""
    
    def __init__(
        self,
        meal_repository: MealRepositoryPort = None,
        vision_service: VisionAIServicePort = None,
        gpt_parser: GPTResponseParser = None,
        image_store: ImageStorePort = None
    ):
        self.meal_repository = meal_repository or MealRepository()
        self.vision_service = vision_service or VisionAIService()
        self.gpt_parser = gpt_parser or GPTResponseParser()
        self.image_store = image_store or CloudinaryImageStore()
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.meal_repository = kwargs.get('meal_repository', self.meal_repository)
        self.vision_service = kwargs.get('vision_service', self.vision_service)
        self.gpt_parser = kwargs.get('gpt_parser', self.gpt_parser)
        self.image_store = kwargs.get('image_store', self.image_store)
    
    async def handle(self, event: MealImageUploadedEvent) -> None:
        """Handle meal image uploaded event by triggering background analysis."""
        logger.info(f"EVENT HANDLER CALLED: Received MealImageUploadedEvent for meal {event.meal_id}")
        try:
            logger.info(f"Starting background analysis for meal {event.meal_id}")
            
            # Get the meal from repository
            meal = self.meal_repository.find_by_id(event.meal_id)
            if not meal:
                logger.error(f"Meal {event.meal_id} not found for background analysis")
                return
            
            # Skip if already processed
            if meal.status != MealStatus.PROCESSING:
                logger.info(f"Meal {event.meal_id} already processed with status {meal.status}")
                return
            
            # Update status to ANALYZING
            meal.status = MealStatus.ANALYZING
            self.meal_repository.save(meal)
            logger.info(f"Updated meal {event.meal_id} status to ANALYZING")
            
            # Try to perform real analysis if we can get image contents
            # Otherwise fall back to mock analysis
            await self._perform_analysis(meal)
            
        except Exception as e:
            logger.error(f"Error processing meal image upload event for meal {event.meal_id}: {str(e)}")
            await self._mark_meal_as_failed(event.meal_id, str(e))
    
    async def _perform_analysis(self, meal):
        """Perform real AI analysis using the same logic as UploadMealImageImmediatelyHandler."""
        try:
            # Add small delay to simulate processing time
            import asyncio
            await asyncio.sleep(1)
            
            # Get image contents from the image store
            logger.info(f"Loading image contents for meal {meal.meal_id}")
            image_contents = self.image_store.load(meal.image.image_id)
            
            if not image_contents:
                raise Exception(f"Could not load image contents for image_id: {meal.image.image_id}")
            
            logger.info(f"Performing real AI analysis for meal {meal.meal_id}")
            
            # Perform AI analysis (same as UploadMealImageImmediatelyHandler)
            vision_result = self.vision_service.analyze(image_contents)
            
            # Parse the response (same as UploadMealImageImmediatelyHandler)
            nutrition = self.gpt_parser.parse_to_nutrition(vision_result)
            dish_name = self.gpt_parser.parse_dish_name(vision_result)
            
            # Update meal with analysis results (same as UploadMealImageImmediatelyHandler)
            meal.dish_name = dish_name or "Unknown dish"
            meal.status = MealStatus.READY
            meal.ready_at = datetime.now()
            meal.raw_gpt_json = self.gpt_parser.extract_raw_json(vision_result)
            
            # Use the parsed nutrition directly (same as UploadMealImageImmediatelyHandler)
            meal.nutrition = nutrition
            
            # Save the fully analyzed meal
            self.meal_repository.save(meal)
            logger.info(f"Real analysis completed for meal {meal.meal_id}")
            
        except Exception as e:
            logger.error(f"Analysis failed for meal {meal.meal_id}: {str(e)}")
            await self._mark_meal_as_failed(meal.meal_id, str(e))
    
    async def _mark_meal_as_failed(self, meal_id: str, error_message: str):
        """Mark a meal as failed with error message."""
        try:
            meal = self.meal_repository.find_by_id(meal_id)
            if meal:
                meal.status = MealStatus.FAILED
                meal.error_message = error_message
                self.meal_repository.save(meal)
                logger.info(f"Marked meal {meal_id} as failed")
        except Exception as save_error:
            logger.error(f"Failed to update meal status to failed: {str(save_error)}")
</file>

<file path="src/app/handlers/query_handlers/chat/__init__.py">
"""Chat query handlers."""
from .get_threads_query_handler import GetThreadsQueryHandler
from .get_thread_query_handler import GetThreadQueryHandler
from .get_messages_query_handler import GetMessagesQueryHandler

__all__ = [
    "GetThreadsQueryHandler",
    "GetThreadQueryHandler",
    "GetMessagesQueryHandler",
]
</file>

<file path="src/app/handlers/query_handlers/chat/get_messages_query_handler.py">
"""
Handler for getting messages from a thread.
"""
import logging
from typing import Dict, Any

from src.api.exceptions import ResourceNotFoundException, ValidationException
from src.app.events.base import EventHandler, handles
from src.app.queries.chat import GetMessagesQuery
from src.domain.ports.chat_repository_port import ChatRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetMessagesQuery)
class GetMessagesQueryHandler(EventHandler[GetMessagesQuery, Dict[str, Any]]):
    """Handler for getting messages from a thread."""
    
    def __init__(self, chat_repository: ChatRepositoryPort = None):
        self.chat_repository = chat_repository
    
    def set_dependencies(self, chat_repository: ChatRepositoryPort):
        """Set dependencies for dependency injection."""
        self.chat_repository = chat_repository
    
    async def handle(self, query: GetMessagesQuery) -> Dict[str, Any]:
        """Get messages from a thread."""
        if not self.chat_repository:
            raise RuntimeError("Chat repository not configured")
        
        # Find thread
        thread = self.chat_repository.find_thread_by_id(query.thread_id)
        if not thread:
            raise ResourceNotFoundException(
                message="Thread not found",
                details={"thread_id": query.thread_id}
            )
        
        # Verify user owns thread
        if thread.user_id != query.user_id:
            raise ValidationException("User does not have access to this thread")
        
        # Get messages
        messages = self.chat_repository.find_messages_by_thread(
            thread_id=query.thread_id,
            limit=query.limit,
            offset=query.offset
        )
        
        # Get total count
        total_count = self.chat_repository.count_thread_messages(query.thread_id)
        
        return {
            "messages": [msg.to_dict() for msg in messages],
            "total_count": total_count,
            "limit": query.limit,
            "offset": query.offset
        }
</file>

<file path="src/app/handlers/query_handlers/chat/get_thread_query_handler.py">
"""
Handler for getting a single thread by ID.
"""
import logging
from typing import Dict, Any

from src.api.exceptions import ResourceNotFoundException, ValidationException
from src.app.events.base import EventHandler, handles
from src.app.queries.chat import GetThreadQuery
from src.domain.ports.chat_repository_port import ChatRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetThreadQuery)
class GetThreadQueryHandler(EventHandler[GetThreadQuery, Dict[str, Any]]):
    """Handler for getting a single thread."""
    
    def __init__(self, chat_repository: ChatRepositoryPort = None):
        self.chat_repository = chat_repository
    
    def set_dependencies(self, chat_repository: ChatRepositoryPort):
        """Set dependencies for dependency injection."""
        self.chat_repository = chat_repository
    
    async def handle(self, query: GetThreadQuery) -> Dict[str, Any]:
        """Get a thread by ID."""
        if not self.chat_repository:
            raise RuntimeError("Chat repository not configured")
        
        # Find thread
        thread = self.chat_repository.find_thread_by_id(query.thread_id)
        if not thread:
            raise ResourceNotFoundException(
                message="Thread not found",
                details={"thread_id": query.thread_id}
            )
        
        # Verify user owns thread
        if thread.user_id != query.user_id:
            raise ValidationException("User does not have access to this thread")
        
        # Get messages
        messages = self.chat_repository.find_messages_by_thread(query.thread_id)
        
        return {
            "thread": thread.to_dict(),
            "messages": [msg.to_dict() for msg in messages],
            "message_count": len(messages)
        }
</file>

<file path="src/app/handlers/query_handlers/chat/get_threads_query_handler.py">
"""
Handler for getting list of threads for a user.
"""
import logging
from typing import Dict, Any

from src.app.events.base import EventHandler, handles
from src.app.queries.chat import GetThreadsQuery
from src.domain.ports.chat_repository_port import ChatRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetThreadsQuery)
class GetThreadsQueryHandler(EventHandler[GetThreadsQuery, Dict[str, Any]]):
    """Handler for getting user's threads."""
    
    def __init__(self, chat_repository: ChatRepositoryPort = None):
        self.chat_repository = chat_repository
    
    def set_dependencies(self, chat_repository: ChatRepositoryPort):
        """Set dependencies for dependency injection."""
        self.chat_repository = chat_repository
    
    async def handle(self, query: GetThreadsQuery) -> Dict[str, Any]:
        """Get threads for a user."""
        if not self.chat_repository:
            raise RuntimeError("Chat repository not configured")
        
        # Get threads
        threads = self.chat_repository.find_threads_by_user(
            user_id=query.user_id,
            include_deleted=query.include_deleted,
            limit=query.limit,
            offset=query.offset
        )
        
        # Get total count
        total_count = self.chat_repository.count_user_threads(
            user_id=query.user_id,
            include_deleted=query.include_deleted
        )
        
        return {
            "threads": [thread.to_dict() for thread in threads],
            "total_count": total_count,
            "limit": query.limit,
            "offset": query.offset
        }
</file>

<file path="src/app/handlers/query_handlers/get_daily_activities_query_handler.py">
"""
GetDailyActivitiesQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from datetime import datetime
from typing import List, Dict, Any

from src.app.events.base import EventHandler, handles
from src.app.queries.activity import GetDailyActivitiesQuery
from src.domain.model.meal import MealStatus
from src.domain.ports.meal_repository_port import MealRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetDailyActivitiesQuery)
class GetDailyActivitiesQueryHandler(EventHandler[GetDailyActivitiesQuery, List[Dict[str, Any]]]):
    """Handler for getting daily activities (meals and workouts)."""

    def __init__(self, meal_repository: MealRepositoryPort = None):
        self.meal_repository = meal_repository

    def set_dependencies(self, meal_repository: MealRepositoryPort):
        """Set dependencies for dependency injection."""
        self.meal_repository = meal_repository

    async def handle(self, query: GetDailyActivitiesQuery) -> List[Dict[str, Any]]:
        """Get all activities for the specified date."""
        if not self.meal_repository:
            raise RuntimeError("Meal repository not configured")

        activities = []

        # Get meal activities
        meal_activities = self._get_meal_activities(query.target_date, query.user_id)
        logger.info(f"Found {len(meal_activities)} meal activities for user {query.user_id} on date {query.target_date.strftime('%Y-%m-%d')}")
        activities.extend(meal_activities)

        # Get workout activities (placeholder for now)
        workout_activities = self._get_workout_activities(query.target_date, query.user_id)
        logger.info(f"Found {len(workout_activities)} workout activities for user {query.user_id} on date {query.target_date.strftime('%Y-%m-%d')}")
        activities.extend(workout_activities)

        # Sort by timestamp (newest first)
        activities.sort(key=lambda x: x['timestamp'], reverse=True)

        logger.info(f"Retrieved {len(activities)} total activities")
        return activities

    def _get_meal_activities(self, target_date: datetime, user_id: str) -> List[Dict[str, Any]]:
        """Get meal activities for a specific date and user."""
        try:
            date_obj = target_date.date()
            meals = self.meal_repository.find_by_date(date_obj, user_id=user_id)

            meal_activities = []
            for meal in meals:
                # Only include meals with nutrition data and exclude INACTIVE
                if not meal.nutrition or meal.status not in [MealStatus.READY, MealStatus.ENRICHING]:
                    continue
                if meal.status == MealStatus.INACTIVE:
                    continue

                # Build activity from meal
                activity = self._build_meal_activity(meal, target_date)
                meal_activities.append(activity)

            return meal_activities

        except Exception as e:
            logger.error(f"Error getting meal activities: {str(e)}", exc_info=True)
            return []

    def _build_meal_activity(self, meal, target_date: datetime) -> Dict[str, Any]:
        """Build activity dictionary from meal."""
        # Use stored meal type if available, otherwise determine from time
        meal_type = meal.meal_type if hasattr(meal, 'meal_type') and meal.meal_type else self._determine_meal_type(meal.created_at)
        
        # Estimate weight
        estimated_weight = self._estimate_meal_weight(meal)

        # Get image URL
        image_url = None
        if hasattr(meal, 'image') and meal.image:
            image_url = meal.image.url

        # Build activity
        return {
            "id": meal.meal_id,
            "type": "meal",
            "timestamp": meal.created_at.isoformat() if meal.created_at else target_date.isoformat(),
            "title": meal.dish_name or "Unknown Meal",
            "meal_type": meal_type,
            "calories": round(meal.nutrition.calories, 1) if meal.nutrition else 0,
            "macros": {
                "protein": round(meal.nutrition.macros.protein, 1) if meal.nutrition else 0,
                "carbs": round(meal.nutrition.macros.carbs, 1) if meal.nutrition else 0,
                "fat": round(meal.nutrition.macros.fat, 1) if meal.nutrition else 0,
            },
            "quantity": estimated_weight,
            "status": meal.status.value if meal.status else "unknown",
            "image_url": image_url
        }

    def _estimate_meal_weight(self, meal) -> float:
        """Estimate meal weight from nutrition data."""
        # Default weight
        estimated_weight = 300.0

        # Check if meal has updated weight
        if hasattr(meal, 'weight_grams'):
            return meal.weight_grams

        # Try to get from food items
        if meal.nutrition and meal.nutrition.food_items:
            first_food = meal.nutrition.food_items[0]
            if first_food.unit and 'g' in first_food.unit.lower():
                estimated_weight = first_food.quantity
            elif first_food.quantity > 10:  # Assume grams if quantity is large
                estimated_weight = first_food.quantity

        return estimated_weight

    def _get_workout_activities(self, target_date: datetime, user_id: str) -> List[Dict[str, Any]]:
        """Get workout activities for a specific date and user."""
        # TODO: When workout service is implemented, fetch from there
        # For now, return empty list
        return []

    def _determine_meal_type(self, meal_time: datetime) -> str:
        """Determine meal type based on time of day."""
        if not meal_time:
            return "snack"

        hour = meal_time.hour
        if 5 <= hour < 11:
            return "breakfast"
        elif 11 <= hour < 16:
            return "lunch"
        elif 16 <= hour < 22:
            return "dinner"
        else:
            return "snack"
</file>

<file path="src/app/handlers/query_handlers/get_meals_by_date_query_handler.py">
"""
GetMealsByDateQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import List

from src.app.events.base import EventHandler, handles
from src.app.queries.meal_plan import GetMealsByDateQuery
from src.domain.model.meal import Meal
from src.domain.ports.meal_repository_port import MealRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetMealsByDateQuery)
class GetMealsByDateQueryHandler(EventHandler[GetMealsByDateQuery, List[Meal]]):
    """Handler for retrieving meals by date."""

    def __init__(self, meal_repository: MealRepositoryPort = None):
        self.meal_repository = meal_repository

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.meal_repository = kwargs.get('meal_repository', self.meal_repository)

    async def handle(self, event: GetMealsByDateQuery) -> List[Meal]:
        """Get meals for a specific date and user."""
        if not self.meal_repository:
            raise RuntimeError("Meal repository not configured")
        
        return self.meal_repository.find_by_date(event.meal_date, user_id=event.user_id)
</file>

<file path="src/app/handlers/query_handlers/get_meals_from_plan_by_date_query_handler.py">
"""
GetMealsFromPlanByDateQueryHandler - Handler for retrieving planned meals by date.
Handles GetMealsFromPlanByDateQuery to avoid conflict with GetMealsByDateQuery.
"""
import logging
from typing import Dict, Any

from src.app.events.base import EventHandler, handles
from src.app.queries.meal_plan import GetMealsFromPlanByDateQuery
from src.domain.model.conversation import MealsForDateResponse
from src.domain.model.meal_planning import PlannedMeal, MealType

logger = logging.getLogger(__name__)


@handles(GetMealsFromPlanByDateQuery)
class GetMealsFromPlanByDateQueryHandler(EventHandler[GetMealsFromPlanByDateQuery, Dict[str, Any]]):
    """Handler for getting meals by specific date."""

    def __init__(self, db=None):
        self.db = db

    def set_dependencies(self, db=None):
        """Set database dependency if available."""
        self.db = db

    async def handle(self, query: GetMealsFromPlanByDateQuery) -> Dict[str, Any]:
        """Get meals for a specific date."""
        try:
            if self.db:
                # Query database for meals on the specific date
                from src.infra.database.models.meal_planning.meal_plan import MealPlan as DBMealPlan
                from src.infra.database.models.meal_planning.meal_plan_day import MealPlanDay
                from src.infra.database.models.meal_planning.planned_meal import PlannedMeal as DBPlannedMeal

                # Find meal plan days that match the user and date
                meal_plan_days = self.db.query(MealPlanDay).join(DBMealPlan).filter(
                    DBMealPlan.user_id == query.user_id,
                    MealPlanDay.date == query.meal_date
                ).all()

                # Get all planned meals for those days and convert to domain models
                domain_meals = []
                for day in meal_plan_days:
                    db_planned_meals = self.db.query(DBPlannedMeal).filter(
                        DBPlannedMeal.day_id == day.id
                    ).all()

                    # Convert database models to domain models
                    for db_meal in db_planned_meals:
                        domain_meal = self._convert_db_meal_to_domain(db_meal)
                        domain_meals.append(domain_meal)

                # Create response using domain model
                response = MealsForDateResponse(
                    date=query.meal_date,
                    day_formatted=query.meal_date.strftime("%A, %B %d, %Y"),
                    meals=domain_meals,
                    total_meals=len(domain_meals),
                    user_id=query.user_id
                )

                return response.to_dict()

            # Fallback: return empty response when no database
            response = MealsForDateResponse.empty_response(query.user_id, query.meal_date)
            return response.to_dict()

        except Exception as e:
            logger.error(f"Error getting meals for date {query.meal_date}: {str(e)}")
            # Return empty results instead of failing
            response = MealsForDateResponse.empty_response(query.user_id, query.meal_date)
            return response.to_dict()

    def _convert_db_meal_to_domain(self, db_meal) -> PlannedMeal:
        """Convert database PlannedMeal model to domain PlannedMeal model."""
        return PlannedMeal(
            meal_id=str(db_meal.id),
            meal_type=MealType(db_meal.meal_type.value) if db_meal.meal_type else MealType.BREAKFAST,
            name=db_meal.name,
            description=db_meal.description or "",
            prep_time=db_meal.prep_time or 0,
            cook_time=db_meal.cook_time or 0,
            calories=db_meal.calories or 0,
            protein=db_meal.protein or 0.0,
            carbs=db_meal.carbs or 0.0,
            fat=db_meal.fat or 0.0,
            ingredients=db_meal.ingredients or [],
            seasonings=db_meal.seasonings or [],
            instructions=db_meal.instructions or [],
            is_vegetarian=db_meal.is_vegetarian or False,
            is_vegan=db_meal.is_vegan or False,
            is_gluten_free=db_meal.is_gluten_free or False,
            cuisine_type=db_meal.cuisine_type
        )
</file>

<file path="src/app/handlers/query_handlers/get_notification_preferences_query_handler.py">
"""
Handler for getting notification preferences.
"""
import logging
from typing import Any, Dict

from src.app.events.base import EventHandler, handles
from src.app.queries.notification import GetNotificationPreferencesQuery
from src.domain.model.notification import NotificationPreferences
from src.domain.ports.notification_repository_port import NotificationRepositoryPort

logger = logging.getLogger(__name__)


@handles(GetNotificationPreferencesQuery)
class GetNotificationPreferencesQueryHandler(EventHandler[GetNotificationPreferencesQuery, Dict[str, Any]]):
    """Handler for getting notification preferences."""
    
    def __init__(self, notification_repository: NotificationRepositoryPort = None):
        self.notification_repository = notification_repository
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.notification_repository = kwargs.get('notification_repository', self.notification_repository)
    
    async def handle(self, query: GetNotificationPreferencesQuery) -> Dict[str, Any]:
        """Handle notification preferences query."""
        if not self.notification_repository:
            raise RuntimeError("Notification repository not configured")
        
        try:
            # Get preferences for user
            preferences = self.notification_repository.find_notification_preferences_by_user(query.user_id)
            
            if not preferences:
                # Create and return default preferences
                default_prefs = NotificationPreferences.create_default(query.user_id)
                saved_prefs = self.notification_repository.save_notification_preferences(default_prefs)
                
                logger.info(f"Created default notification preferences for user {query.user_id}")
                return saved_prefs.to_dict()
            else:
                return preferences.to_dict()
        except Exception as e:
            logger.error(f"Error getting notification preferences: {e}")
            raise e
</file>

<file path="src/app/handlers/query_handlers/get_user_onboarding_status_query_handler.py">
"""
GetUserOnboardingStatusQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.user.get_user_onboarding_status_query import GetUserOnboardingStatusQuery
from src.infra.database.models.user import User

logger = logging.getLogger(__name__)


@handles(GetUserOnboardingStatusQuery)
class GetUserOnboardingStatusQueryHandler(EventHandler[GetUserOnboardingStatusQuery, Dict[str, Any]]):
    """Handler for getting user's onboarding status by Firebase UID."""

    def __init__(self, db: Session = None):
        self.db = db

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, query: GetUserOnboardingStatusQuery) -> Dict[str, Any]:
        """Get user's onboarding status by Firebase UID."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get user by firebase_uid
        user = self.db.query(User).filter(
            User.firebase_uid == query.firebase_uid
        ).first()

        if not user:
            raise ResourceNotFoundException(f"User with Firebase UID {query.firebase_uid} not found")

        return {
            "firebase_uid": user.firebase_uid,
            "onboarding_completed": user.onboarding_completed,
            "is_active": user.is_active,
            "last_accessed": user.last_accessed
        }
</file>

<file path="src/app/queries/chat/__init__.py">
"""Chat queries."""
from .get_threads_query import GetThreadsQuery
from .get_thread_query import GetThreadQuery
from .get_messages_query import GetMessagesQuery

__all__ = [
    "GetThreadsQuery",
    "GetThreadQuery",
    "GetMessagesQuery",
]
</file>

<file path="src/app/queries/chat/get_messages_query.py">
"""
Query to get messages from a thread.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetMessagesQuery(Query):
    """Query to get messages from a thread."""
    thread_id: str
    user_id: str  # For authorization
    limit: int = 100
    offset: int = 0
</file>

<file path="src/app/queries/chat/get_thread_query.py">
"""
Query to get a single thread by ID.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetThreadQuery(Query):
    """Query to get a single thread with messages."""
    thread_id: str
    user_id: str  # For authorization
</file>

<file path="src/app/queries/chat/get_threads_query.py">
"""
Query to get list of threads for a user.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetThreadsQuery(Query):
    """Query to get threads for a user."""
    user_id: str
    limit: int = 50
    offset: int = 0
    include_deleted: bool = False
</file>

<file path="src/app/queries/meal_plan/__init__.py">
"""Meal plan queries."""
from .get_meal_plan_query import GetMealPlanQuery
from .get_meals_by_date_query import GetMealsByDateQuery
from .get_meals_from_plan_by_date_query import GetMealsFromPlanByDateQuery

__all__ = [
    "GetMealPlanQuery",
    "GetMealsByDateQuery",
    "GetMealsFromPlanByDateQuery",
]
</file>

<file path="src/app/queries/meal_plan/get_meals_from_plan_by_date_query.py">
"""
GetMealsFromPlanByDateQuery - Query for retrieving planned meals by date.
This is distinct from GetMealsByDateQuery which retrieves actual meals.
"""
from dataclasses import dataclass
from datetime import date


@dataclass
class GetMealsFromPlanByDateQuery:
    """Query to get meals from a meal plan for a specific date."""
    user_id: str
    meal_date: date
</file>

<file path="src/app/queries/meal_suggestion/__init__.py">
"""Meal suggestion queries."""
from .get_session_suggestions_query import GetSessionSuggestionsQuery

__all__ = ["GetSessionSuggestionsQuery"]
</file>

<file path="src/app/queries/meal_suggestion/get_session_suggestions_query.py">
"""Get session suggestions query."""
from dataclasses import dataclass


@dataclass
class GetSessionSuggestionsQuery:
    """Query to get current session's suggestions."""

    user_id: str
    session_id: str
</file>

<file path="src/app/queries/notification/__init__.py">
"""
Notification queries package.
"""
from .get_notification_preferences_query import GetNotificationPreferencesQuery

__all__ = [
    'GetNotificationPreferencesQuery',
]
</file>

<file path="src/app/queries/notification/get_notification_preferences_query.py">
"""
Query to get notification preferences for a user.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetNotificationPreferencesQuery(Query):
    """Query to get notification preferences for a user."""
    user_id: str
</file>

<file path="src/app/queries/user/get_user_by_firebase_uid_query.py">
"""
Query to get user by Firebase UID.
"""
from dataclasses import dataclass


@dataclass
class GetUserByFirebaseUidQuery:
    """Query to get user by Firebase UID."""
    firebase_uid: str
</file>

<file path="src/app/queries/user/get_user_metrics_query.py">
"""
Query to get user's current metrics for settings display.
"""
from dataclasses import dataclass

from src.app.events.base import Query


@dataclass
class GetUserMetricsQuery(Query):
    """Query to get user's current metrics."""
    user_id: str
</file>

<file path="src/app/queries/user/get_user_onboarding_status_query.py">
"""
Query to get user's onboarding status.
"""
from dataclasses import dataclass


@dataclass
class GetUserOnboardingStatusQuery:
    """Query to get user's onboarding status by Firebase UID."""
    firebase_uid: str
</file>

<file path="src/app/services/chat/__init__.py">
"""Chat application services."""
from .chat_notification_service import ChatNotificationService
from .ai_response_coordinator import AIResponseCoordinator
from .message_orchestration_service import MessageOrchestrationService

__all__ = [
    "ChatNotificationService",
    "AIResponseCoordinator",
    "MessageOrchestrationService",
]
</file>

<file path="src/app/services/chat/ai_response_coordinator.py">
"""
AI response coordinator for handling streaming AI responses.
Coordinates AI generation, streaming, and notification.
"""
import logging
from typing import Dict, Any, List, Optional

from src.domain.ports.ai_chat_service_port import AIChatServicePort
from src.infra.services.ai.parsers import AIResponseParser
from .chat_notification_service import ChatNotificationService

logger = logging.getLogger(__name__)


class AIResponseCoordinator:
    """
    Coordinates AI response generation with streaming and notifications.

    Responsibilities:
    - Generate streaming AI responses
    - Broadcast chunks via notifications
    - Parse final structured response
    - Handle errors gracefully
    """

    def __init__(
        self,
        ai_service: AIChatServicePort,
        notification_service: ChatNotificationService,
        parser: Optional[AIResponseParser] = None
    ):
        """
        Initialize coordinator.

        Args:
            ai_service: AI chat service for generating responses
            notification_service: Service for broadcasting notifications
            parser: Parser for AI responses (uses default if None)
        """
        self.ai_service = ai_service
        self.notification_service = notification_service
        self.parser = parser or AIResponseParser()

    async def generate_streaming_response(
        self,
        thread_id: str,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7
    ) -> Dict[str, Any]:
        """
        Generate streaming AI response with real-time notifications.

        Args:
            thread_id: Thread ID for notifications
            messages: Conversation history
            system_prompt: Optional custom system prompt
            temperature: AI temperature parameter

        Returns:
            Dictionary with:
            - content: Full response content
            - message: Parsed display message
            - follow_ups: Parsed follow-up questions
            - structured_data: Parsed structured data
            - metadata: Response metadata

        Raises:
            RuntimeError: If AI generation fails
        """
        # Start typing indicator
        await self.notification_service.notify_typing_indicator(thread_id, True)

        try:
            full_content = ""
            metadata = {}

            # Stream response chunks
            async for chunk_data in self.ai_service.generate_streaming_response(
                messages=messages,
                system_prompt=system_prompt,
                temperature=temperature
            ):
                chunk = chunk_data.get("chunk", "")
                metadata = chunk_data.get("metadata", {})

                if chunk:
                    full_content += chunk

                    # Broadcast chunk
                    await self.notification_service.notify_message_chunk(
                        thread_id,
                        chunk,
                        metadata
                    )

            # Stop typing indicator
            await self.notification_service.notify_typing_indicator(thread_id, False)

            # Parse complete response
            parsed_response = self.parser.parse_response(full_content.strip())

            return {
                "content": full_content.strip(),
                "message": parsed_response.get("message", full_content.strip()),
                "follow_ups": parsed_response.get("follow_ups", []),
                "structured_data": parsed_response.get("structured_data"),
                "metadata": metadata
            }

        except Exception as e:
            # Stop typing indicator on error
            await self.notification_service.notify_typing_indicator(thread_id, False)

            # Notify about error
            await self.notification_service.notify_error(
                thread_id,
                "Failed to generate AI response",
                type(e).__name__
            )

            logger.error(f"Error generating AI response: {e}", exc_info=True)
            raise RuntimeError(f"Failed to generate AI response: {str(e)}")

    async def generate_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7
    ) -> Dict[str, Any]:
        """
        Generate non-streaming AI response (for testing or batch operations).

        Args:
            messages: Conversation history
            system_prompt: Optional custom system prompt
            temperature: AI temperature parameter

        Returns:
            Dictionary with parsed response data

        Raises:
            RuntimeError: If AI generation fails
        """
        try:
            response = await self.ai_service.generate_response(
                messages=messages,
                system_prompt=system_prompt,
                temperature=temperature
            )

            content = response.get("content", "")
            parsed_response = self.parser.parse_response(content)

            return {
                "content": content,
                "message": parsed_response.get("message", content),
                "follow_ups": parsed_response.get("follow_ups", []),
                "structured_data": parsed_response.get("structured_data"),
                "metadata": response.get("metadata", {})
            }

        except Exception as e:
            logger.error(f"Error generating AI response: {e}", exc_info=True)
            raise RuntimeError(f"Failed to generate AI response: {str(e)}")
</file>

<file path="src/app/services/chat/chat_notification_service.py">
"""
Chat notification service for broadcasting messages via WebSocket.
Abstracts notification logic from command handlers.
"""
import logging
from typing import Dict, Any, Optional

logger = logging.getLogger(__name__)


class ChatNotificationService:
    """
    Handles all chat-related notifications via WebSocket.

    This service abstracts WebSocket broadcasting from command handlers,
    making it easier to:
    - Add alternative notification channels (push notifications, email, etc.)
    - Handle broadcast failures gracefully
    - Test handlers without WebSocket dependencies
    """

    def __init__(self):
        """Initialize notification service with optional WebSocket manager."""
        self.websocket_manager = None
        self._websocket_available = False

        # Try to import WebSocket manager
        try:
            from src.infra.websocket import chat_connection_manager
            self.websocket_manager = chat_connection_manager
            self._websocket_available = True
            logger.info("WebSocket notifications enabled")
        except ImportError:
            logger.warning("WebSocket connection manager not available")

    def is_websocket_available(self) -> bool:
        """Check if WebSocket notifications are available."""
        return self._websocket_available

    async def notify_message_sent(
        self,
        thread_id: str,
        message: Dict[str, Any]
    ) -> None:
        """
        Notify subscribers that a message was sent.

        Args:
            thread_id: Thread ID
            message: Message data dictionary
        """
        if not self._websocket_available:
            return

        try:
            await self.websocket_manager.broadcast_message_complete(
                thread_id,
                message
            )
        except Exception as e:
            logger.error(f"Failed to broadcast message notification: {e}")

    async def notify_typing_indicator(
        self,
        thread_id: str,
        is_typing: bool
    ) -> None:
        """
        Notify subscribers of typing indicator status.

        Args:
            thread_id: Thread ID
            is_typing: Whether assistant is typing
        """
        if not self._websocket_available:
            return

        try:
            await self.websocket_manager.broadcast_typing_indicator(
                thread_id,
                is_typing
            )
        except Exception as e:
            logger.error(f"Failed to broadcast typing indicator: {e}")

    async def notify_message_chunk(
        self,
        thread_id: str,
        chunk: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> None:
        """
        Notify subscribers of a streaming message chunk.

        Args:
            thread_id: Thread ID
            chunk: Text chunk
            metadata: Optional chunk metadata
        """
        if not self._websocket_available:
            return

        try:
            await self.websocket_manager.broadcast_message_chunk(
                thread_id,
                chunk,
                metadata or {}
            )
        except Exception as e:
            logger.error(f"Failed to broadcast message chunk: {e}")

    async def notify_error(
        self,
        thread_id: str,
        error_message: str,
        error_type: Optional[str] = None
    ) -> None:
        """
        Notify subscribers of an error.

        Args:
            thread_id: Thread ID
            error_message: Error message
            error_type: Optional error type
        """
        if not self._websocket_available:
            return

        try:
            await self.websocket_manager.send_to_thread(thread_id, {
                "type": "error",
                "thread_id": thread_id,
                "message": error_message,
                "error_type": error_type
            })
        except Exception as e:
            logger.error(f"Failed to broadcast error notification: {e}")
</file>

<file path="src/app/services/chat/message_orchestration_service.py">
"""
Message orchestration service for coordinating the send message flow.
Handles validation, persistence, AI response, and notifications.
"""
import logging
from typing import Dict, Any, Optional

from src.api.exceptions import ResourceNotFoundException, ValidationException
from src.domain.model.chat import Message, ThreadStatus
from src.domain.ports.chat_repository_port import ChatRepositoryPort
from src.domain.ports.ai_chat_service_port import AIChatServicePort
from .ai_response_coordinator import AIResponseCoordinator
from .chat_notification_service import ChatNotificationService

logger = logging.getLogger(__name__)


class MessageOrchestrationService:
    """
    Orchestrates the complete send message flow.

    Responsibilities:
    - Validate thread and user access
    - Save user message
    - Coordinate AI response generation
    - Save assistant message
    - Handle notifications
    - Manage errors
    """

    def __init__(
        self,
        chat_repository: ChatRepositoryPort,
        ai_service: Optional[AIChatServicePort] = None
    ):
        """
        Initialize orchestration service.

        Args:
            chat_repository: Repository for chat operations
            ai_service: Optional AI service for generating responses
        """
        self.chat_repository = chat_repository
        self.ai_service = ai_service

        # Initialize supporting services
        self.notification_service = ChatNotificationService()
        self.ai_coordinator = None

        if ai_service:
            self.ai_coordinator = AIResponseCoordinator(
                ai_service=ai_service,
                notification_service=self.notification_service
            )

    async def send_message(
        self,
        thread_id: str,
        user_id: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Send a message and get AI response.

        Args:
            thread_id: Thread ID
            user_id: User ID
            content: Message content
            metadata: Optional message metadata

        Returns:
            Dictionary with:
            - success: Boolean indicating success
            - user_message: Saved user message data
            - assistant_message: Saved assistant message data (if AI available)
            - ai_error: Error information if AI failed

        Raises:
            ResourceNotFoundException: If thread not found
            ValidationException: If validation fails
        """
        # Validate thread and user access
        thread = self._validate_thread_access(thread_id, user_id)

        # Create and save user message
        user_message = self._save_user_message(thread_id, content, metadata)

        # Notify about user message
        await self.notification_service.notify_message_sent(
            thread_id,
            user_message.to_dict()
        )

        # Generate AI response if service is available
        assistant_message = None
        ai_error = None

        if self.ai_coordinator:
            assistant_message, ai_error = await self._generate_ai_response(
                thread_id,
                user_message
            )

        return {
            "success": True,
            "user_message": user_message.to_dict(),
            "assistant_message": assistant_message.to_dict() if assistant_message else None,
            "ai_error": ai_error
        }

    def _validate_thread_access(self, thread_id: str, user_id: str):
        """
        Validate thread exists and user has access.

        Args:
            thread_id: Thread ID to validate
            user_id: User ID to validate

        Returns:
            Thread domain object

        Raises:
            ResourceNotFoundException: If thread not found
            ValidationException: If user doesn't have access or thread inactive
        """
        # Find thread
        thread = self.chat_repository.find_thread_by_id(thread_id)
        if not thread:
            raise ResourceNotFoundException(
                message="Thread not found",
                details={"thread_id": thread_id}
            )

        # Verify user owns thread
        if thread.user_id != user_id:
            raise ValidationException("User does not have access to this thread")

        # Check thread is active
        if thread.status != ThreadStatus.ACTIVE:
            raise ValidationException("Cannot send message to inactive thread")

        return thread

    def _save_user_message(
        self,
        thread_id: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> Message:
        """
        Create and save user message.

        Args:
            thread_id: Thread ID
            content: Message content
            metadata: Optional metadata

        Returns:
            Saved Message domain object
        """
        # Create user message
        user_message = Message.create_user_message(
            thread_id=thread_id,
            content=content,
            metadata=metadata
        )

        # Save message
        saved_message = self.chat_repository.save_message(user_message)
        logger.info(
            f"Saved user message {saved_message.message_id} to thread {thread_id}"
        )

        return saved_message

    async def _generate_ai_response(
        self,
        thread_id: str,
        user_message: Message
    ) -> tuple[Optional[Message], Optional[Dict[str, Any]]]:
        """
        Generate and save AI response.

        Args:
            thread_id: Thread ID
            user_message: User message that triggered the response

        Returns:
            Tuple of (assistant_message, error_info)
            - assistant_message: Saved assistant message or None if failed
            - error_info: Error dictionary or None if successful
        """
        try:
            # Get conversation history
            messages = self.chat_repository.find_messages_by_thread(thread_id)

            # Format for AI service
            formatted_messages = [
                {"role": str(msg.role), "content": msg.content}
                for msg in messages
            ]

            # Generate streaming response
            ai_response = await self.ai_coordinator.generate_streaming_response(
                thread_id=thread_id,
                messages=formatted_messages
            )

            # Create assistant message with structured data
            assistant_message = Message.create_assistant_message(
                thread_id=thread_id,
                content=ai_response["message"],
                metadata={
                    **ai_response.get("metadata", {}),
                    "follow_ups": ai_response.get("follow_ups", []),
                    "structured_data": ai_response.get("structured_data")
                }
            )

            # Save assistant message
            saved_message = self.chat_repository.save_message(assistant_message)
            logger.info(
                f"Saved AI response {saved_message.message_id} to thread {thread_id}"
            )

            # Notify about complete message
            await self.notification_service.notify_message_sent(
                thread_id,
                saved_message.to_dict()
            )

            return saved_message, None

        except Exception as e:
            error_info = {
                "message": "Failed to generate AI response",
                "error": str(e),
                "error_type": type(e).__name__
            }

            logger.error(f"Error generating AI response: {e}", exc_info=True)
            return None, error_info
</file>

<file path="src/app/services/__init__.py">
"""Application services."""
</file>

<file path="src/domain/model/chat/__init__.py">
"""Chat domain models."""
from .chat_enums import MessageRole, ThreadStatus
from .message import Message
from .thread import Thread

__all__ = [
    "MessageRole",
    "ThreadStatus",
    "Message",
    "Thread",
]
</file>

<file path="src/domain/model/chat/chat_enums.py">
"""
Enums for chat domain models.
"""
from enum import Enum


class MessageRole(str, Enum):
    """Role of message sender in a conversation."""
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"  # For system prompts/instructions
    
    def __str__(self):
        return self.value


class ThreadStatus(str, Enum):
    """Status of a conversation thread."""
    ACTIVE = "active"
    ARCHIVED = "archived"
    DELETED = "deleted"
    
    def __str__(self):
        return self.value
</file>

<file path="src/domain/model/chat/message.py">
"""
Message domain model for chat conversations.
"""
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Any, Optional

from .chat_enums import MessageRole


@dataclass
class Message:
    """
    Value object representing a single message in a conversation.
    Messages are immutable once created.
    """
    message_id: str  # UUID as string
    thread_id: str  # UUID as string
    role: MessageRole
    content: str
    created_at: datetime
    metadata: Optional[Dict[str, Any]] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.message_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for message_id: {self.message_id}")
        
        try:
            uuid.UUID(self.thread_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for thread_id: {self.thread_id}")
        
        # Validate content
        if not self.content or not self.content.strip():
            raise ValueError("Message content cannot be empty")
        
        if len(self.content) > 50000:  # 50K characters limit
            raise ValueError(f"Message content too long (max 50000 chars): {len(self.content)}")
        
        # Validate role
        if not isinstance(self.role, MessageRole):
            raise ValueError(f"Invalid message role: {self.role}")
    
    @classmethod
    def create_user_message(
        cls,
        thread_id: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'Message':
        """Factory method to create a user message."""
        return cls(
            message_id=str(uuid.uuid4()),
            thread_id=thread_id,
            role=MessageRole.USER,
            content=content,
            created_at=datetime.utcnow(),
            metadata=metadata or {}
        )
    
    @classmethod
    def create_assistant_message(
        cls,
        thread_id: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'Message':
        """Factory method to create an assistant message."""
        return cls(
            message_id=str(uuid.uuid4()),
            thread_id=thread_id,
            role=MessageRole.ASSISTANT,
            content=content,
            created_at=datetime.utcnow(),
            metadata=metadata or {}
        )
    
    @classmethod
    def create_system_message(
        cls,
        thread_id: str,
        content: str,
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'Message':
        """Factory method to create a system message."""
        return cls(
            message_id=str(uuid.uuid4()),
            thread_id=thread_id,
            role=MessageRole.SYSTEM,
            content=content,
            created_at=datetime.utcnow(),
            metadata=metadata or {}
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary format."""
        return {
            "message_id": self.message_id,
            "thread_id": self.thread_id,
            "role": str(self.role),
            "content": self.content,
            "created_at": self.created_at.isoformat(),
            "metadata": self.metadata or {}
        }
</file>

<file path="src/domain/model/chat/thread.py">
"""
Thread domain model for chat conversations.
"""
import uuid
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, Any, Optional, List

from .chat_enums import ThreadStatus
from .message import Message


@dataclass
class Thread:
    """
    Aggregate root representing a conversation thread.
    A thread contains multiple messages between user and assistant.
    """
    thread_id: str  # UUID as string
    user_id: str  # UUID as string
    title: Optional[str]
    status: ThreadStatus
    created_at: datetime
    updated_at: datetime
    metadata: Optional[Dict[str, Any]] = None
    messages: List[Message] = field(default_factory=list)
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.thread_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for thread_id: {self.thread_id}")
        
        try:
            uuid.UUID(self.user_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
        
        # Validate title
        if self.title and len(self.title) > 255:
            raise ValueError(f"Title too long (max 255 chars): {len(self.title)}")
        
        # Validate status
        if not isinstance(self.status, ThreadStatus):
            raise ValueError(f"Invalid thread status: {self.status}")
    
    @classmethod
    def create_new(
        cls,
        user_id: str,
        title: Optional[str] = None,
        metadata: Optional[Dict[str, Any]] = None
    ) -> 'Thread':
        """Factory method to create a new thread."""
        now = datetime.utcnow()
        return cls(
            thread_id=str(uuid.uuid4()),
            user_id=user_id,
            title=title or "New Conversation",
            status=ThreadStatus.ACTIVE,
            created_at=now,
            updated_at=now,
            metadata=metadata or {},
            messages=[]
        )
    
    def add_message(self, message: Message) -> 'Thread':
        """Add a message to the thread and return updated thread."""
        if message.thread_id != self.thread_id:
            raise ValueError(f"Message thread_id {message.thread_id} does not match thread {self.thread_id}")
        
        # Create new thread with updated messages
        updated_messages = self.messages + [message]
        
        return Thread(
            thread_id=self.thread_id,
            user_id=self.user_id,
            title=self.title,
            status=self.status,
            created_at=self.created_at,
            updated_at=datetime.utcnow(),
            metadata=self.metadata,
            messages=updated_messages
        )
    
    def archive(self) -> 'Thread':
        """Archive the thread."""
        return Thread(
            thread_id=self.thread_id,
            user_id=self.user_id,
            title=self.title,
            status=ThreadStatus.ARCHIVED,
            created_at=self.created_at,
            updated_at=datetime.utcnow(),
            metadata=self.metadata,
            messages=self.messages
        )
    
    def delete(self) -> 'Thread':
        """Soft delete the thread."""
        return Thread(
            thread_id=self.thread_id,
            user_id=self.user_id,
            title=self.title,
            status=ThreadStatus.DELETED,
            created_at=self.created_at,
            updated_at=datetime.utcnow(),
            metadata=self.metadata,
            messages=self.messages
        )
    
    def update_title(self, title: str) -> 'Thread':
        """Update thread title."""
        if len(title) > 255:
            raise ValueError(f"Title too long (max 255 chars): {len(title)}")
        
        return Thread(
            thread_id=self.thread_id,
            user_id=self.user_id,
            title=title,
            status=self.status,
            created_at=self.created_at,
            updated_at=datetime.utcnow(),
            metadata=self.metadata,
            messages=self.messages
        )
    
    def get_message_count(self) -> int:
        """Get the number of messages in this thread."""
        # Check for cached message count (set by repository to avoid N+1 queries)
        if hasattr(self, '_cached_message_count'):
            return self._cached_message_count
        return len(self.messages)
    
    def get_last_message(self) -> Optional[Message]:
        """Get the most recent message in the thread."""
        return self.messages[-1] if self.messages else None
    
    def to_dict(self, include_messages: bool = False) -> Dict[str, Any]:
        """Convert to dictionary format."""
        result = {
            "thread_id": self.thread_id,
            "user_id": self.user_id,
            "title": self.title,
            "status": str(self.status),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat(),
            "metadata": self.metadata or {},
            "message_count": self.get_message_count()
        }
        
        last_message = self.get_last_message()
        if last_message:
            result["last_message_at"] = last_message.created_at.isoformat()
        
        if include_messages:
            result["messages"] = [msg.to_dict() for msg in self.messages]
        
        return result
</file>

<file path="src/domain/model/meal_planning/meal_suggestion.py">
"""
Domain entities for meal suggestion system.
"""
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import List, Optional


class MealType(str, Enum):
    """Types of meals."""
    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    DINNER = "dinner"
    SNACK = "snack"


class MealSize(str, Enum):
    """T-shirt sizing for meal portions (percentage of daily TDEE)."""
    S = "S"      # 10% of daily TDEE
    M = "M"      # 20%
    L = "L"      # 40%
    XL = "XL"    # 60%
    OMAD = "OMAD"  # 100% (One Meal A Day)


# Mapping meal sizes to TDEE percentages
MEAL_SIZE_PERCENTAGES = {
    MealSize.S: 0.10,
    MealSize.M: 0.20,
    MealSize.L: 0.40,
    MealSize.XL: 0.60,
    MealSize.OMAD: 1.00,
}


class SuggestionStatus(str, Enum):
    """Status of a meal suggestion."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"


@dataclass
class Ingredient:
    """Value object representing an ingredient."""
    name: str
    amount: float
    unit: str


@dataclass
class RecipeStep:
    """Value object representing a recipe instruction step."""
    step: int
    instruction: str
    duration_minutes: Optional[int] = None


@dataclass
class MacroEstimate:
    """Value object for macro estimates with portion multiplication."""
    calories: int
    protein: float
    carbs: float
    fat: float

    def multiply(self, factor: int) -> "MacroEstimate":
        """Apply portion multiplier (1x, 2x, 3x, 4x)."""
        return MacroEstimate(
            calories=int(self.calories * factor),
            protein=round(self.protein * factor, 1),
            carbs=round(self.carbs * factor, 1),
            fat=round(self.fat * factor, 1),
        )


@dataclass
class MealSuggestion:
    """Domain entity representing a generated meal suggestion."""
    id: str
    session_id: str
    user_id: str
    meal_name: str
    description: str
    meal_type: MealType
    macros: MacroEstimate
    ingredients: List[Ingredient]
    recipe_steps: List[RecipeStep]
    prep_time_minutes: int
    confidence_score: float = 0.9
    status: SuggestionStatus = SuggestionStatus.PENDING
    generated_at: datetime = field(default_factory=datetime.utcnow)
</file>

<file path="src/domain/model/meal_planning/suggestion_session.py">
"""
Session tracking for meal suggestion system.
"""
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Optional

from src.domain.model.meal_planning.meal_suggestion import MealType, MealSize


@dataclass
class SuggestionSession:
    """
    Domain entity tracking a meal suggestion session.

    Sessions expire after 4 hours and track shown suggestions
    to prevent duplicates on regeneration.
    """
    id: str
    user_id: str
    meal_type: MealType
    meal_size: MealSize
    target_calories: int
    ingredients: List[str]
    ingredient_image_url: Optional[str]
    cooking_time_minutes: int
    shown_suggestion_ids: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None

    def __post_init__(self) -> None:
        """Set expiration to 4 hours from creation if not provided."""
        if self.expires_at is None:
            self.expires_at = self.created_at + timedelta(hours=4)

    def add_shown_ids(self, ids: List[str]) -> None:
        """Track newly shown suggestion IDs to exclude on regenerate."""
        self.shown_suggestion_ids.extend(ids)

    def is_expired(self) -> bool:
        """Check if session has expired."""
        return datetime.utcnow() > self.expires_at
</file>

<file path="src/domain/model/meal_suggestion/__init__.py">
"""Meal suggestion domain models."""
from .meal_suggestion import (
    MealSuggestion,
    MealType,
    MealSize,
    SuggestionStatus,
    Ingredient,
    RecipeStep,
    MacroEstimate,
    MEAL_SIZE_PERCENTAGES,
)
from .portion_target import PortionTarget
from .suggestion_session import SuggestionSession

__all__ = [
    "MealSuggestion",
    "MealType",
    "MealSize",
    "SuggestionStatus",
    "Ingredient",
    "RecipeStep",
    "MacroEstimate",
    "MEAL_SIZE_PERCENTAGES",
    "PortionTarget",
    "SuggestionSession",
]
</file>

<file path="src/domain/model/meal_suggestion/meal_suggestion.py">
"""Meal suggestion domain entities."""
from dataclasses import dataclass, field
from datetime import datetime
from typing import List, Optional
from enum import Enum


class MealType(str, Enum):
    """Meal type enumeration."""
    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    DINNER = "dinner"
    SNACK = "snack"


class MealSize(str, Enum):
    """T-shirt sizing for meal portions (% of daily TDEE)."""
    S = "S"      # 10% of daily TDEE
    M = "M"      # 20%
    L = "L"      # 40%
    XL = "XL"    # 60%
    OMAD = "OMAD"  # 100%


MEAL_SIZE_PERCENTAGES = {
    MealSize.S: 0.10,
    MealSize.M: 0.20,
    MealSize.L: 0.40,
    MealSize.XL: 0.60,
    MealSize.OMAD: 1.00,
}


class SuggestionStatus(str, Enum):
    """Suggestion lifecycle status."""
    PENDING = "pending"
    ACCEPTED = "accepted"
    REJECTED = "rejected"


@dataclass
class Ingredient:
    """Ingredient with quantity."""
    name: str
    amount: float
    unit: str


@dataclass
class RecipeStep:
    """Single recipe step."""
    step: int
    instruction: str
    duration_minutes: Optional[int] = None


@dataclass
class MacroEstimate:
    """Macronutrient estimates."""
    calories: int
    protein: float
    carbs: float
    fat: float

    def multiply(self, factor: int) -> "MacroEstimate":
        """Apply portion multiplier."""
        return MacroEstimate(
            calories=int(self.calories * factor),
            protein=round(self.protein * factor, 1),
            carbs=round(self.carbs * factor, 1),
            fat=round(self.fat * factor, 1),
        )


@dataclass
class MealSuggestion:
    """AI-generated meal suggestion with full recipe."""
    id: str
    session_id: str
    user_id: str
    meal_name: str
    description: str
    meal_type: MealType
    macros: MacroEstimate
    ingredients: List[Ingredient]
    recipe_steps: List[RecipeStep]
    prep_time_minutes: int
    confidence_score: float
    status: SuggestionStatus = SuggestionStatus.PENDING
    generated_at: datetime = field(default_factory=datetime.utcnow)
</file>

<file path="src/domain/model/meal_suggestion/portion_target.py">
"""Portion target value object."""

from dataclasses import dataclass


@dataclass(frozen=True)
class PortionTarget:
    """Immutable portion target for meal generation."""

    target_calories: int
    min_calories: int
    max_calories: int
    meals_per_day: int

    def __post_init__(self) -> None:
        """Validate constraints."""
        if self.target_calories < 0:
            raise ValueError("target_calories must be positive")
        if self.min_calories > self.target_calories:
            raise ValueError("min_calories cannot exceed target_calories")
        if self.max_calories < self.target_calories:
            raise ValueError("max_calories cannot be less than target_calories")
</file>

<file path="src/domain/parsers/gpt_response_parser.py">
import json
import uuid
from typing import Dict, Any, List, Optional

from src.domain.model.nutrition import Macros
from src.domain.model.nutrition import Nutrition, FoodItem


class GPTResponseParsingError(Exception):
    """Exception raised for errors in parsing GPT responses."""
    pass

class GPTResponseParser:
    """
    Service for parsing GPT Vision API responses into domain models.
    
    This class implements US-2.2 - Parse the GPT response to structured food list and macros.
    """
    
    def parse_to_nutrition(self, gpt_response: Dict[str, Any]) -> Nutrition:
        """
        Parse GPT response into Nutrition domain model.
        
        Args:
            gpt_response: Response from the OpenAI Vision API
            
        Returns:
            Nutrition object with food items and macros
            
        Raises:
            GPTResponseParsingError: If parsing fails due to invalid format
        """
        try:
            # Get the structured data part
            data = gpt_response.get("structured_data")
            if not data:
                raise GPTResponseParsingError("No structured data found in GPT response")
            
            # Parse food items
            food_items = self._parse_food_items(data)
            
            # Get total macros
            total_macros = self._calculate_total_macros(data, food_items)
            
            # Get total calories
            total_calories = self._calculate_total_calories(data, food_items, total_macros)
            
            # Get confidence score
            confidence_score = float(data.get("confidence", 0.5))
            confidence_score = min(max(0.0, confidence_score), 1.0)
            
            # Create Nutrition object
            nutrition = Nutrition(
                calories=total_calories,
                macros=total_macros,
                micros=None,  # No micros from GPT
                food_items=food_items if food_items else None,
                confidence_score=confidence_score
            )
            
            return nutrition
            
        except (KeyError, ValueError, TypeError) as e:
            raise GPTResponseParsingError(f"Failed to parse GPT response: {str(e)}")
    
    def _parse_food_items(self, data: Dict[str, Any]) -> List[FoodItem]:
        """Parse food items from GPT response data."""
        food_items = []
        if "foods" in data:
            for food_data in data["foods"]:
                # Validate required fields
                required_fields = ["name", "quantity", "unit", "calories", "macros"]
                for field in required_fields:
                    if field not in food_data:
                        raise GPTResponseParsingError(f"Missing required field '{field}' in food item")
                
                # Create Macros object
                macros_data = food_data["macros"]
                macros = Macros(
                    protein=float(macros_data.get("protein", 0)),
                    carbs=float(macros_data.get("carbs", 0)),
                    fat=float(macros_data.get("fat", 0)),
                )
                
                # Create FoodItem with confidence score
                confidence = 1.0  # Default confidence
                if "confidence" in food_data:
                    confidence = min(max(0.0, float(food_data["confidence"])), 1.0)
                
                food_item = FoodItem(
                    id=uuid.uuid4(),  # Generate UUID for editing support
                    name=food_data["name"],
                    quantity=float(food_data["quantity"]),
                    unit=food_data["unit"],
                    calories=float(food_data["calories"]),
                    macros=macros,
                    micros=None,  # GPT doesn't provide micros yet
                    confidence=confidence
                )
                
                food_items.append(food_item)
        
        return food_items
    
    def _calculate_total_macros(self, data: Dict[str, Any], food_items: List[FoodItem]) -> Macros:
        """Calculate total macros based on food items and top-level macros if available."""
        if food_items:
            total_protein = sum(item.macros.protein for item in food_items)
            total_carbs = sum(item.macros.carbs for item in food_items)
            total_fat = sum(item.macros.fat for item in food_items)
            
            total_macros = Macros(
                protein=total_protein,
                carbs=total_carbs,
                fat=total_fat,
            )
        else:
            # If no food items, use top-level macros if available
            if "macros" in data:
                total_macros = Macros(
                    protein=float(data["macros"].get("protein", 0)),
                    carbs=float(data["macros"].get("carbs", 0)),
                    fat=float(data["macros"].get("fat", 0)),
                )
            else:
                # Default empty macros
                total_macros = Macros(protein=0.0, carbs=0.0, fat=0.0)
        
        return total_macros
    
    def _calculate_total_calories(self, data: Dict[str, Any], food_items: List[FoodItem], total_macros: Macros) -> float:
        """Calculate total calories based on food items and top-level calories if available."""
        if "total_calories" in data:
            return float(data["total_calories"])
        else:
            # Calculate from food items if available
            total_calories = sum(item.calories for item in food_items) if food_items else total_macros.total_calories
            return total_calories
    
    def parse_dish_name(self, gpt_response: Dict[str, Any]) -> Optional[str]:
        """
        Parse dish name from GPT response.
        
        Args:
            gpt_response: Response from the OpenAI Vision API
            
        Returns:
            Dish name string or None if not found
        """
        try:
            structured_data = gpt_response.get("structured_data", {})
            return structured_data.get("dish_name")
        except (KeyError, TypeError):
            return None
    
    def extract_raw_json(self, gpt_response: Dict[str, Any]) -> str:
        """
        Extract the raw JSON from GPT response as a string.
        
        Args:
            gpt_response: Response from the OpenAI Vision API
            
        Returns:
            JSON string representation
        """
        try:
            # If raw_response exists, we prefer that for storage
            if "raw_response" in gpt_response:
                return gpt_response["raw_response"]
            
            # Otherwise, just stringify the structured data
            return json.dumps(gpt_response["structured_data"])
        except (KeyError, TypeError):
            return json.dumps(gpt_response)
</file>

<file path="src/domain/ports/ai_chat_service_port.py">
"""
Port (interface) for AI chat service.
Defines the contract for AI chat implementations (OpenAI, Claude, etc.).
"""
from abc import ABC, abstractmethod
from typing import List, Dict, Any, Optional, AsyncIterator


class AIChatServicePort(ABC):
    """Port for AI chat completion services."""
    
    @abstractmethod
    async def generate_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Generate AI response based on conversation history.
        
        Args:
            messages: List of message dicts with 'role' and 'content'
            system_prompt: Optional system prompt to set context
            temperature: Randomness of response (0-1)
            max_tokens: Maximum tokens in response
            
        Returns:
            Dict with 'content' (response text) and 'metadata' (model info, tokens, etc.)
        """
        pass
    
    @abstractmethod
    async def generate_streaming_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None
    ) -> AsyncIterator[Dict[str, Any]]:
        """
        Generate AI response with streaming chunks.
        
        Args:
            messages: List of message dicts with 'role' and 'content'
            system_prompt: Optional system prompt to set context
            temperature: Randomness of response (0-1)
            max_tokens: Maximum tokens in response
            
        Yields:
            Dict with 'chunk' (text chunk) and optional 'metadata'
        """
        pass
</file>

<file path="src/domain/ports/chat_repository_port.py">
"""
Port (interface) for chat repository.
Defines the contract that chat storage implementations must follow.
"""
from abc import ABC, abstractmethod
from typing import List, Optional

from src.domain.model.chat import Thread, Message


class ChatRepositoryPort(ABC):
    """Port for chat data persistence."""
    
    @abstractmethod
    def save_thread(self, thread: Thread) -> Thread:
        """Save a thread and return the saved thread."""
        pass
    
    @abstractmethod
    def find_thread_by_id(self, thread_id: str) -> Optional[Thread]:
        """Find a thread by its ID."""
        pass
    
    @abstractmethod
    def find_threads_by_user(
        self,
        user_id: str,
        include_deleted: bool = False,
        limit: int = 50,
        offset: int = 0
    ) -> List[Thread]:
        """Find all threads for a user with pagination."""
        pass
    
    @abstractmethod
    def delete_thread(self, thread_id: str) -> bool:
        """Delete a thread (soft delete)."""
        pass
    
    @abstractmethod
    def save_message(self, message: Message) -> Message:
        """Save a message and return the saved message."""
        pass
    
    @abstractmethod
    def find_messages_by_thread(
        self,
        thread_id: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[Message]:
        """Find all messages for a thread with pagination."""
        pass
    
    @abstractmethod
    def count_user_threads(self, user_id: str, include_deleted: bool = False) -> int:
        """Count total threads for a user."""
        pass
    
    @abstractmethod
    def count_thread_messages(self, thread_id: str) -> int:
        """Count total messages in a thread."""
        pass
</file>

<file path="src/domain/ports/meal_plan_repository_port.py">
"""
MealPlanRepositoryPort - Interface for meal plan repository operations.
"""
from abc import ABC, abstractmethod
from typing import Optional, List
from datetime import date

from src.domain.model.meal_planning import MealPlan, DailyMeal, PlannedMeal


class MealPlanRepositoryPort(ABC):
    """Interface for meal plan repository operations."""
    
    @abstractmethod
    def save(self, meal_plan: MealPlan) -> MealPlan:
        """Save or update a meal plan."""
        pass
    
    @abstractmethod
    def find_by_id(self, meal_plan_id: str) -> Optional[MealPlan]:
        """Find a meal plan by ID."""
        pass
    
    @abstractmethod
    def find_by_user_id(self, user_id: str) -> List[MealPlan]:
        """Find all meal plans for a user."""
        pass
    
    @abstractmethod
    def find_active_by_user_id(self, user_id: str) -> Optional[MealPlan]:
        """Find the active meal plan for a user."""
        pass
    
    @abstractmethod
    def find_by_date_range(
        self, 
        user_id: str, 
        start_date: date, 
        end_date: date
    ) -> List[MealPlan]:
        """Find meal plans within a date range."""
        pass
    
    @abstractmethod
    def delete(self, meal_plan_id: str) -> bool:
        """Delete a meal plan by ID."""
        pass
    
    @abstractmethod
    def get_daily_meals(
        self, 
        user_id: str, 
        meal_date: date
    ) -> List[DailyMeal]:
        """Get daily meals for a specific date."""
        pass
    
    @abstractmethod
    def save_daily_meal(self, daily_meal: DailyMeal) -> DailyMeal:
        """Save or update a daily meal."""
        pass
    
    @abstractmethod
    def get_planned_meals(
        self,
        meal_plan_id: str,
        meal_date: date
    ) -> List[PlannedMeal]:
        """Get planned meals for a specific date within a meal plan."""
        pass
</file>

<file path="src/domain/ports/meal_suggestion_repository_port.py">
"""Repository port for meal suggestion domain."""
from abc import ABC, abstractmethod
from typing import List, Optional

from src.domain.model.meal_suggestion import MealSuggestion, SuggestionSession


class MealSuggestionRepositoryPort(ABC):
    """Port for meal suggestion data access."""

    @abstractmethod
    async def save_session(self, session: SuggestionSession) -> None:
        """Save suggestion session with 4-hour TTL."""
        pass

    @abstractmethod
    async def get_session(self, session_id: str) -> Optional[SuggestionSession]:
        """Retrieve session by ID."""
        pass

    @abstractmethod
    async def update_session(self, session: SuggestionSession) -> None:
        """Update existing session (maintains remaining TTL)."""
        pass

    @abstractmethod
    async def delete_session(self, session_id: str) -> None:
        """Delete session and all associated suggestions."""
        pass

    @abstractmethod
    async def save_suggestions(self, suggestions: List[MealSuggestion]) -> None:
        """Save batch of suggestions with 4-hour TTL."""
        pass

    @abstractmethod
    async def get_suggestion(self, suggestion_id: str) -> Optional[MealSuggestion]:
        """Retrieve single suggestion by ID."""
        pass

    @abstractmethod
    async def update_suggestion(self, suggestion: MealSuggestion) -> None:
        """Update suggestion (e.g., status change)."""
        pass

    @abstractmethod
    async def get_session_suggestions(
        self, session_id: str
    ) -> List[MealSuggestion]:
        """Get all suggestions for a session."""
        pass
</file>

<file path="src/domain/ports/subscription_repository_port.py">
"""
SubscriptionRepositoryPort - Interface for subscription repository operations.
"""
from abc import ABC, abstractmethod
from typing import Optional, List
from datetime import datetime

from src.domain.model.subscription import Subscription


class SubscriptionRepositoryPort(ABC):
    """Interface for subscription repository operations."""
    
    @abstractmethod
    def save(self, subscription: Subscription) -> Subscription:
        """Save or update a subscription."""
        pass
    
    @abstractmethod
    def find_by_id(self, subscription_id: str) -> Optional[Subscription]:
        """Find a subscription by ID."""
        pass
    
    @abstractmethod
    def find_by_user_id(self, user_id: str) -> List[Subscription]:
        """Find all subscriptions for a user."""
        pass
    
    @abstractmethod
    def find_active_by_user_id(self, user_id: str) -> Optional[Subscription]:
        """Find the active subscription for a user."""
        pass
    
    @abstractmethod
    def find_expiring_soon(self, days_until_expiry: int = 7) -> List[Subscription]:
        """Find subscriptions expiring within specified days."""
        pass
    
    @abstractmethod
    def cancel(self, subscription_id: str, reason: str = None) -> bool:
        """Cancel a subscription."""
        pass
    
    @abstractmethod
    def reactivate(self, subscription_id: str) -> bool:
        """Reactivate a cancelled subscription."""
        pass
    
    @abstractmethod
    def update_payment_status(
        self, 
        subscription_id: str, 
        payment_status: str,
        payment_date: datetime = None
    ) -> bool:
        """Update payment status for a subscription."""
        pass
    
    @abstractmethod
    def extend_trial(self, subscription_id: str, days: int) -> bool:
        """Extend trial period for a subscription."""
        pass
</file>

<file path="src/domain/prompts/unified_meal_plan_prompt.py">
"""
Prompt templates for unified daily meal plan generation.
Generates all meals for a day in a single API call.
"""
from typing import Dict, Any

from src.domain.model.meal_planning import MealType
from src.domain.model.meal_planning import SimpleMacroTargets


def build_unified_meal_prompt(meal_distribution: Dict[MealType, float], user_preferences: Dict[str, Any]) -> str:
    """Build a unified prompt for generating all daily meals at once"""
    
    # Extract user data
    goal = user_preferences.get('goal', 'maintain_weight')
    dietary_prefs = user_preferences.get('dietary_preferences', [])
    health_conditions = user_preferences.get('health_conditions', [])
    target_macros = user_preferences.get('target_macros', {})
    activity_level = user_preferences.get('activity_level', 'moderately_active')
    target_calories = user_preferences.get('target_calories', 2000)
    
    # Build dietary restrictions string
    dietary_str = ", ".join(dietary_prefs) if dietary_prefs else "none"
    health_str = ", ".join(health_conditions) if health_conditions else "none"
    
    # Goal-specific guidance
    goal_guidance = {
        'lose_weight': "Focus on high-volume, low-calorie foods with plenty of fiber and protein for satiety",
        'gain_weight': "Include calorie-dense, nutritious foods with healthy fats and complex carbs",
        'build_muscle': "Emphasize high protein content with complete amino acids",
        'maintain_weight': "Create balanced meals with appropriate portions"
    }
    
    # Build meal targets string
    meal_targets = []
    for meal_type, calorie_target in meal_distribution.items():
        meal_percentage = calorie_target / target_calories
        
        # Handle both MacroTargets object and dict format
        if isinstance(target_macros, SimpleMacroTargets):
            protein_target = target_macros.protein * meal_percentage
            carbs_target = target_macros.carbs * meal_percentage
            fat_target = target_macros.fat * meal_percentage
        else:
            # Legacy dict format
            protein_target = target_macros.get('protein_grams', 50) * meal_percentage
            carbs_target = target_macros.get('carbs_grams', 250) * meal_percentage
            fat_target = target_macros.get('fat_grams', 65) * meal_percentage
        
        meal_targets.append(f"""
{meal_type.value.title()}:
- Calories: {int(calorie_target)} (±50 calories)
- Protein: {int(protein_target)}g
- Carbs: {int(carbs_target)}g
- Fat: {int(fat_target)}g""")
    
    meal_targets_str = "\n".join(meal_targets)
    
    return f"""Generate a complete daily meal plan with these requirements:

User Profile:
- Fitness Goal: {goal} - {goal_guidance.get(goal, 'balanced nutrition')}
- Activity Level: {activity_level}
- Dietary Restrictions: {dietary_str}
- Health Conditions: {health_str}
- Total Daily Calories: {int(target_calories)}

Nutritional Targets for each meal:
{meal_targets_str}

Requirements:
1. All meals should be practical and use common ingredients
2. Cooking times should be reasonable for each meal type
3. Must respect all dietary restrictions across all meals
4. Should support the user's fitness goal
5. Include variety and flavor across the day
6. Ensure meals complement each other for a balanced day

Return ONLY a JSON object with this structure:
{{
    "meals": [
        {{
            "meal_type": "breakfast",
            "name": "Meal name",
            "description": "Brief appealing description",
            "prep_time": 10,
            "cook_time": 20,
            "calories": 500,
            "protein": 25,
            "carbs": 60,
            "fat": 15,
            "ingredients": ["ingredient 1 with amount", "ingredient 2 with amount"],
            "instructions": ["Step 1", "Step 2"],
            "is_vegetarian": true/false,
            "is_vegan": true/false,
            "is_gluten_free": true/false,
            "cuisine_type": "cuisine type"
        }},
        // ... repeat for each meal type
    ]
}}"""


def get_system_message() -> str:
    """Get system message for unified meal planning."""
    return "You are a professional nutritionist creating personalized daily meal plans."
</file>

<file path="src/domain/schemas/meal_generation_schemas.py">
"""
Pydantic schemas for structured meal generation output.
Used with LangChain's with_structured_output() for guaranteed valid responses.
"""
from typing import List
from pydantic import BaseModel, Field


class MealNamesResponse(BaseModel):
    """Phase 1: Response containing 4 diverse meal names."""

    meal_names: List[str] = Field(
        description="List of exactly 4 diverse, concise meal names (max 60 chars each) with different cuisines and cooking styles",
        min_length=4,
        max_length=4
    )
    
    # B2 FIX: Validate each meal name is reasonably short
    @classmethod
    def __init_subclass__(cls):
        super().__init_subclass__()
    
    def __init__(self, **data):
        super().__init__(**data)
        # Validate individual meal name lengths
        for i, name in enumerate(self.meal_names):
            if len(name) > 60:
                self.meal_names[i] = name[:57] + "..."  # Truncate if too long


class IngredientItem(BaseModel):
    """Single ingredient with amount and unit."""
    
    name: str = Field(description="Ingredient name (e.g., 'chicken breast', 'broccoli')")
    amount: float = Field(description="Quantity amount (e.g., 200, 1.5)", gt=0)
    unit: str = Field(description="Unit of measurement (e.g., 'g', 'ml', 'tbsp', 'tsp', 'cup')")


class RecipeStepItem(BaseModel):
    """Single recipe step with instruction and duration."""
    
    step: int = Field(description="Step number (1, 2, 3, ...)", ge=1)
    instruction: str = Field(description="Clear, actionable instruction")
    duration_minutes: int = Field(description="Time in minutes for this step", ge=0)


class RecipeDetailsResponse(BaseModel):
    """Phase 2: Complete recipe details for a meal (description removed for performance)."""

    ingredients: List[IngredientItem] = Field(
        description="List of 3-8 ingredients with exact amounts",
        min_length=3,
        max_length=8
    )
    recipe_steps: List[RecipeStepItem] = Field(
        description="List of 2-6 recipe steps with instructions and durations",
        min_length=2,
        max_length=6
    )
    prep_time_minutes: int = Field(
        description="Total preparation and cooking time in minutes",
        ge=5,
        le=120
    )
</file>

<file path="src/domain/services/conversation/__init__.py">
"""Conversation service components."""
from src.domain.services.conversation.conversation_parser import ConversationParser
from src.domain.services.conversation.conversation_formatter import ConversationFormatter
from src.domain.services.conversation.conversation_handler import ConversationHandler

__all__ = [
    "ConversationParser",
    "ConversationFormatter",
    "ConversationHandler",
]
</file>

<file path="src/domain/services/conversation/conversation_formatter.py">
"""Conversation response formatting logic."""
from typing import List
from src.domain.model.conversation import ConversationContext
from src.domain.model.meal_planning import MealPlan, MealType, PlanDuration


class ConversationFormatter:
    """Formats conversation responses."""

    @staticmethod
    def format_list(items: List[str]) -> str:
        """Format a list for display."""
        if not items:
            return "none"
        elif len(items) == 1:
            return items[0]
        else:
            return ", ".join(items[:-1]) + f" and {items[-1]}"

    @staticmethod
    def build_preferences_summary(context: ConversationContext) -> str:
        """Build a summary of user preferences."""
        duration = "weekly" if context.plan_duration == PlanDuration.WEEKLY.value else "daily"
        dietary = ConversationFormatter.format_list(context.dietary_preferences or ["none"])

        summary = (f"You want a {duration}, {dietary} **meal plan** "
                  f"with {context.meals_per_day} meals")

        if context.snacks_per_day:
            summary += f" and {context.snacks_per_day} snacks"

        summary += f" per day. "

        if context.fitness_goal:
            summary += f"Your goal is {context.fitness_goal.replace('_', ' ')}. "

        summary += (f"You have ~{context.cooking_time_weekday} minutes to cook on weeknights, "
                   f"more on weekends.")

        if context.favorite_cuisines:
            summary += f" You enjoy {ConversationFormatter.format_list(context.favorite_cuisines)} foods"

        if context.disliked_ingredients:
            summary += f", and we'll avoid {ConversationFormatter.format_list(context.disliked_ingredients)}"

        if context.allergies:
            summary += f". You're allergic to {ConversationFormatter.format_list(context.allergies)}"

        summary += "."

        return summary

    @staticmethod
    def format_meal_plan_response(meal_plan: MealPlan) -> str:
        """Format meal plan for display."""
        response = "Here's your **meal plan for the week**. I've organized it by day, with each meal tailored to your preferences and goals:\n\n"

        for day in meal_plan.days[:2]:  # Show first 2 days as example
            response += f"**{day.date.strftime('%A')}**\n\n"

            for meal in day.meals:
                response += f"* **{meal.meal_type.value.capitalize()}:** {meal.name} – *{meal.description}*"
                if meal.meal_type != MealType.SNACK:
                    response += f" (prep time ~{meal.total_time} min)"
                response += ".\n"

            response += "\n"

        response += ("*(...and similar meal listings for the rest of the week, "
                    "each meeting your dietary requirements and fitness goals...)*\n\n")

        response += ("I've kept the recipes **simple for busy weekdays** and included some of your favorite flavors "
                    "throughout the week. Each meal is tailored to your requirements and goals. "
                    "Let me know if anything doesn't look right or if you'd like to **adjust any specific meal**! 😊")

        return response
</file>

<file path="src/domain/services/meal_plan/__init__.py">
"""Meal plan service components."""
from src.domain.services.meal_plan.meal_plan_validator import MealPlanValidator, ValidationResult
from src.domain.services.meal_plan.meal_plan_generator import MealPlanGenerator
from src.domain.services.meal_plan.meal_plan_formatter import MealPlanFormatter
from src.domain.services.meal_plan.request_builder import RequestBuilder

__all__ = [
    "MealPlanValidator",
    "ValidationResult",
    "MealPlanGenerator",
    "MealPlanFormatter",
    "RequestBuilder",
]
</file>

<file path="src/domain/services/meal_plan/meal_plan_formatter.py">
"""Meal plan formatting and response building logic."""
import logging
from typing import Dict, Any, List
from datetime import datetime, timedelta

from src.domain.model.meal_planning import MealGenerationRequest

logger = logging.getLogger(__name__)


class MealPlanFormatter:
    """Formats meal plans for API responses."""

    def flatten_week(self, week_block: List[Dict]) -> List[Dict]:
        """Flatten week structure to meal list."""
        meals = []
        for day in week_block:
            for meal in day["meals"]:
                meals.append({"day": day["day"], **meal})
        return meals

    def format_weekly_response(self, meals: List[Dict], request_data: Dict[str, Any]) -> Dict[str, Any]:
        """Format weekly response structure."""
        # Use provided start/end dates if available, otherwise calculate current week
        if "start_date_obj" in request_data and "end_date_obj" in request_data:
            start_date = request_data["start_date_obj"]
            end_date = request_data["end_date_obj"]
        else:
            # Fallback to current week calculation
            today = datetime.now().date()
            days_since_monday = today.weekday()  # Monday = 0
            start_date = today - timedelta(days=days_since_monday)
            end_date = start_date + timedelta(days=6)

        # Create day name to date mapping
        day_names = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        day_to_date = {}
        for i, day_name in enumerate(day_names):
            day_date = start_date + timedelta(days=i)
            day_to_date[day_name] = day_date

        # Ensure all meals have required dietary fields and add dates
        for meal in meals:
            meal.setdefault("is_vegetarian", False)
            meal.setdefault("is_vegan", False)
            meal.setdefault("is_gluten_free", False)
            meal.setdefault("cuisine_type", "International")
            meal.setdefault("seasonings", ["salt", "pepper"])  # Default seasonings if missing

            # Add actual date and formatted day string
            if meal["day"] in day_to_date:
                meal_date = day_to_date[meal["day"]]
                meal["date"] = meal_date.isoformat()
                meal["day_formatted"] = f"{meal['day']}, {meal_date.strftime('%B %d, %Y')}"
            else:
                # Fallback for unknown day names
                meal["date"] = start_date.isoformat()
                meal["day_formatted"] = meal["day"]

        total_cals = sum(m["calories"] for m in meals)
        total_prot = sum(m["protein"] for m in meals)
        total_carbs = sum(m["carbs"] for m in meals)
        total_fat = sum(m["fat"] for m in meals)

        # Group by day name - schema expects each day to map directly to a list of meals
        grouped = {}
        for m in meals:
            day_name = m["day"]
            if day_name not in grouped:
                grouped[day_name] = []
            grouped[day_name].append(m)

        return {
            "user_id": request_data.get("user_id", "unknown"),
            "plan_type": "weekly",
            "start_date": start_date.isoformat(),
            "end_date": end_date.isoformat(),
            "days": grouped,
            "meals": meals,
            "total_nutrition": {
                "calories": total_cals,
                "protein": round(total_prot, 1),
                "carbs": round(total_carbs, 1),
                "fat": round(total_fat, 1),
            },
            "daily_average_nutrition": {
                "calories": total_cals // 7,
                "protein": round(total_prot / 7, 1),
                "carbs": round(total_carbs / 7, 1),
                "fat": round(total_fat / 7, 1),
            },
            "target_nutrition": {
                "calories": request_data.get("target_calories", 1800),
                "protein": request_data.get("target_protein", 120.0),
                "carbs": request_data.get("target_carbs", 200.0),
                "fat": request_data.get("target_fat", 80.0),
            },
            "user_preferences": {
                "dietary_preferences": request_data.get("dietary_preferences", []),
                "health_conditions": request_data.get("health_conditions", []),
                "allergies": request_data.get("allergies", []),
                "activity_level": request_data.get("activity_level", "moderate"),
                "fitness_goal": request_data.get("fitness_goal", "maintenance"),
                "meals_per_day": request_data.get("meals_per_day", 3),
                "snacks_per_day": 1 if request_data.get("include_snacks", False) else 0,
            },
        }

    def calculate_nutrition_totals(self, meals: List[Dict]) -> Dict[str, float]:
        """Helper method to calculate nutrition totals from meals."""
        return {
            "calories": sum(meal["calories"] for meal in meals),
            "protein": sum(meal["protein"] for meal in meals),
            "carbs": sum(meal["carbs"] for meal in meals),
            "fat": sum(meal["fat"] for meal in meals)
        }

    def validate_and_adjust_weekly_nutrition(
        self,
        meals: List[Dict],
        generation_request: MealGenerationRequest
    ) -> List[Dict]:
        """Validate and adjust weekly nutrition to match targets."""
        target_nutrition = generation_request.nutrition_targets
        expected_weekly_totals = {
            "calories": target_nutrition.calories * 7,
            "protein": target_nutrition.protein * 7,
            "carbs": target_nutrition.carbs * 7,
            "fat": target_nutrition.fat * 7
        }

        # Calculate current totals using helper method
        current_totals = self.calculate_nutrition_totals(meals)

        # Check if adjustment is needed (allow 5% tolerance)
        tolerance = 0.05
        needs_adjustment = any(
            abs(current_totals[nutrient] - expected_weekly_totals[nutrient]) > expected_weekly_totals[nutrient] * tolerance
            for nutrient in expected_weekly_totals
        )

        if not needs_adjustment:
            logger.info("Weekly nutrition targets are within acceptable range")
            return meals

        logger.warning(f"Weekly nutrition adjustment needed. Current: {current_totals}")
        logger.warning(f"Expected: {expected_weekly_totals}")

        # Calculate adjustment factors
        adjustment_factors = {
            nutrient: expected_weekly_totals[nutrient] / current_totals[nutrient] if current_totals[nutrient] > 0 else 1
            for nutrient in expected_weekly_totals
        }

        # Apply adjustments proportionally
        adjusted_meals = []
        for meal in meals:
            adjusted_meal = meal.copy()
            adjusted_meal["calories"] = int(meal["calories"] * adjustment_factors["calories"])
            adjusted_meal["protein"] = round(meal["protein"] * adjustment_factors["protein"], 1)
            adjusted_meal["carbs"] = round(meal["carbs"] * adjustment_factors["carbs"], 1)
            adjusted_meal["fat"] = round(meal["fat"] * adjustment_factors["fat"], 1)
            adjusted_meals.append(adjusted_meal)

        # Verify final totals using helper method
        final_totals = self.calculate_nutrition_totals(adjusted_meals)
        logger.info(f"Adjusted weekly nutrition: {final_totals}")

        return adjusted_meals
</file>

<file path="src/domain/services/meal_plan/meal_plan_generator.py">
"""Meal plan generation logic."""
import logging
from typing import Dict, Any, List
from datetime import date, datetime, timedelta

from src.domain.model.meal_planning import (
    DailyMealPlan, GeneratedMeal, NutritionSummary, MealType,
    MealGenerationRequest, MealGenerationContext
)
from src.domain.ports.meal_generation_service_port import MealGenerationServicePort
from src.domain.services.fallback_meal_service import FallbackMealService
from src.domain.services.prompt_generation_service import PromptGenerationService

logger = logging.getLogger(__name__)


class MealPlanGenerator:
    """Generates meal plans using LLM and fallback strategies."""

    def __init__(
        self,
        meal_generation_service: MealGenerationServicePort,
        prompt_service: PromptGenerationService,
        fallback_service: FallbackMealService
    ):
        self.meal_generation_service = meal_generation_service
        self.prompt_service = prompt_service
        self.fallback_service = fallback_service

    def generate_daily_plan(
        self,
        generation_request: MealGenerationRequest,
        context: MealGenerationContext
    ) -> DailyMealPlan:
        """Generate daily meal plan with fallback."""
        generated_meals = []
        total_nutrition = NutritionSummary(calories=0, protein=0.0, carbs=0.0, fat=0.0)

        for meal_type in context.meal_types:
            calorie_target = context.calorie_distribution.get_calories_for_meal(meal_type)

            try:
                # Generate prompt for this specific meal
                prompt, system_message = self.prompt_service.generate_single_meal_prompt(
                    meal_type, calorie_target, context
                )

                # Generate using unified LLM service
                meal_data = self.meal_generation_service.generate_meal_plan(prompt, system_message, "json")

                # Convert to domain model
                generated_meal = self._convert_to_generated_meal(meal_data, meal_type)
                generated_meals.append(generated_meal)

                # Add to totals
                total_nutrition.calories += generated_meal.nutrition.calories
                total_nutrition.protein += generated_meal.nutrition.protein
                total_nutrition.carbs += generated_meal.nutrition.carbs
                total_nutrition.fat += generated_meal.nutrition.fat

            except Exception as e:
                logger.error(f"Error generating {meal_type.value} meal: {str(e)}")
                # Use fallback meal from domain service
                fallback_meal = self.fallback_service.get_fallback_meal(meal_type, calorie_target)
                generated_meals.append(fallback_meal)

                total_nutrition.calories += fallback_meal.nutrition.calories
                total_nutrition.protein += fallback_meal.nutrition.protein
                total_nutrition.carbs += fallback_meal.nutrition.carbs
                total_nutrition.fat += fallback_meal.nutrition.fat

        # Create daily meal plan domain model
        return DailyMealPlan(
            user_id=generation_request.user_profile.user_id,
            plan_date=date.today(),
            meals=generated_meals
        )

    def generate_weekly_fallback(
        self,
        context: MealGenerationContext,
        generation_request: MealGenerationRequest,
        request_data: Dict[str, Any] = None
    ) -> Dict[str, Any]:
        """Generate weekly plan using fallback meals when LLM generation fails."""
        days = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
        all_meals = []

        # Use provided start date if available, otherwise calculate current week
        if request_data and "start_date_obj" in request_data:
            start_date = request_data["start_date_obj"]
        else:
            # Fallback to current week calculation
            today = datetime.now().date()
            days_since_monday = today.weekday()
            start_date = today - timedelta(days=days_since_monday)

        # Generate meals for each day using fallback service
        for i, day_name in enumerate(days):
            for meal_type in context.meal_types:
                calorie_target = context.calorie_distribution.get_calories_for_meal(meal_type)
                fallback_meal = self.fallback_service.get_fallback_meal(meal_type, calorie_target)

                # Calculate date for this day
                day_date = start_date + timedelta(days=i)

                # Convert to dict format expected by weekly response
                meal_dict = {
                    "day": day_name,
                    "date": day_date.isoformat(),
                    "day_formatted": f"{day_name}, {day_date.strftime('%B %d, %Y')}",
                    "meal_type": fallback_meal.meal_type,
                    "name": fallback_meal.name,
                    "description": fallback_meal.description,
                    "calories": fallback_meal.nutrition.calories,
                    "protein": fallback_meal.nutrition.protein,
                    "carbs": fallback_meal.nutrition.carbs,
                    "fat": fallback_meal.nutrition.fat,
                    "prep_time": fallback_meal.prep_time,
                    "cook_time": fallback_meal.cook_time,
                    "ingredients": fallback_meal.ingredients,
                    "seasonings": fallback_meal.seasonings,
                    "instructions": fallback_meal.instructions,
                    "is_vegetarian": fallback_meal.is_vegetarian,
                    "is_vegan": fallback_meal.is_vegan,
                    "is_gluten_free": fallback_meal.is_gluten_free,
                    "cuisine_type": fallback_meal.cuisine_type
                }
                all_meals.append(meal_dict)

        return all_meals

    def _convert_to_generated_meal(self, meal_data: Dict[str, Any], meal_type: MealType) -> GeneratedMeal:
        """Convert LLM response to domain model."""
        nutrition = NutritionSummary(
            calories=int(meal_data.get("calories", 0)),
            protein=float(meal_data.get("protein", 0.0)),
            carbs=float(meal_data.get("carbs", 0.0)),
            fat=float(meal_data.get("fat", 0.0))
        )

        return GeneratedMeal(
            meal_id=f"meal_{meal_type.value}_{hash(str(meal_data)) % 10000}",
            meal_type=meal_type.value,
            name=meal_data.get("name", f"Simple {meal_type.value.title()}"),
            description=meal_data.get("description", f"A nutritious {meal_type.value}"),
            prep_time=meal_data.get("prep_time", 15),
            cook_time=meal_data.get("cook_time", 20),
            nutrition=nutrition,
            ingredients=meal_data.get("ingredients", ["Basic ingredients"]),
            seasonings=meal_data.get("seasonings", ["Basic seasonings"]),
            instructions=meal_data.get("instructions", ["Prepare and cook as desired"]),
            is_vegetarian=meal_data.get("is_vegetarian", False),
            is_vegan=meal_data.get("is_vegan", False),
            is_gluten_free=meal_data.get("is_gluten_free", False),
            cuisine_type=meal_data.get("cuisine_type", "International")
        )
</file>

<file path="src/domain/services/meal_plan/meal_plan_validator.py">
"""Meal plan validation logic."""
from dataclasses import dataclass
from typing import List, Dict, Any
import logging

logger = logging.getLogger(__name__)


@dataclass
class ValidationResult:
    """Result of validation operation."""
    is_valid: bool
    errors: List[str]


class MealPlanValidator:
    """Validates meal plan requests and responses."""

    def validate_weekly_response(self, data: Dict[str, Any], request: Dict[str, Any]) -> ValidationResult:
        """Validate weekly response structure."""
        errors = []

        week_data = data.get("week", [])
        if len(week_data) != 7:
            errors.append(f"Expected 7 days, got {len(week_data)}")

        required_fields = {
            "meal_type", "name", "calories", "protein", "carbs", "fat",
            "ingredients", "seasonings", "instructions", "is_vegetarian",
            "is_vegan", "is_gluten_free", "cuisine_type"
        }

        include_snacks = request.get("include_snacks", False)
        expected_meals_per_day = 3 + (1 if include_snacks else 0)

        for day in week_data:
            day_name = day.get("day", "")
            meals = day.get("meals", [])

            if len(meals) < expected_meals_per_day:
                logger.warning(f"{day_name}: Expected {expected_meals_per_day} meals, got {len(meals)}")

            for meal in meals:
                missing_fields = required_fields - meal.keys()
                if missing_fields:
                    logger.warning(f"{day_name} meal missing fields: {missing_fields}")

        return ValidationResult(is_valid=len(errors) == 0, errors=errors)
</file>

<file path="src/domain/services/meal_plan/request_builder.py">
"""Request and context building logic."""
from typing import Dict, Any, Optional

from src.domain.model.meal_planning import (
    MealGenerationRequest, MealGenerationType,
    UserDietaryProfile, UserNutritionTargets,
    IngredientConstraints, MealGenerationContext
)
from src.domain.services.meal_distribution_service import MealDistributionService
from src.domain.services.meal_type_determination_service import MealTypeDeterminationService


class RequestBuilder:
    """Builds generation requests and contexts from raw data."""

    def __init__(
        self,
        meal_distribution_service: MealDistributionService,
        meal_type_service: MealTypeDeterminationService
    ):
        self.meal_distribution_service = meal_distribution_service
        self.meal_type_service = meal_type_service

    def build_generation_request(
        self, request_data: Dict[str, Any], generation_type: MealGenerationType
    ) -> MealGenerationRequest:
        """Build domain model from request data."""
        # Build user profile
        user_profile = UserDietaryProfile(
            user_id=request_data.get("user_id", "unknown"),
            dietary_preferences=request_data.get("dietary_preferences", []),
            health_conditions=request_data.get("health_conditions", []),
            allergies=request_data.get("allergies", []),
            activity_level=request_data.get("activity_level", "moderate"),
            fitness_goal=request_data.get("fitness_goal", "maintenance"),
            meals_per_day=request_data.get("meals_per_day", 3),
            include_snacks=request_data.get("include_snacks", False)
        )

        # Build nutrition targets
        nutrition_targets = UserNutritionTargets(
            calories=request_data.get("target_calories", 1800),
            protein=request_data.get("target_protein", 120.0),
            carbs=request_data.get("target_carbs", 200.0),
            fat=request_data.get("target_fat", 80.0)
        )

        # Build ingredient constraints if applicable
        ingredient_constraints = None
        if "available_ingredients" in request_data or "available_seasonings" in request_data:
            ingredient_constraints = IngredientConstraints(
                available_ingredients=request_data.get("available_ingredients", []),
                available_seasonings=request_data.get("available_seasonings", [])
            )

        return MealGenerationRequest(
            generation_type=generation_type,
            user_profile=user_profile,
            nutrition_targets=nutrition_targets,
            ingredient_constraints=ingredient_constraints
        )

    def create_generation_context(
        self, generation_request: MealGenerationRequest, request_data: Optional[Dict[str, Any]] = None
    ) -> MealGenerationContext:
        """Create generation context from request."""
        # Determine meal types using domain service
        meal_types = self.meal_type_service.determine_meal_types(
            generation_request.user_profile.meals_per_day,
            generation_request.user_profile.include_snacks
        )

        # Calculate calorie distribution using domain service
        calorie_distribution = self.meal_distribution_service.calculate_distribution(
            meal_types, generation_request.nutrition_targets
        )

        # Extract dates if provided
        start_date = None
        end_date = None
        if request_data:
            start_date = request_data.get("start_date_obj")
            end_date = request_data.get("end_date_obj")

        return MealGenerationContext(
            request=generation_request,
            meal_types=meal_types,
            calorie_distribution=calorie_distribution,
            start_date=start_date,
            end_date=end_date
        )

    @staticmethod
    def convert_request_to_dict(
        generation_request: MealGenerationRequest, request_data: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """Convert generation_request back to request_data format for compatibility."""
        return {
            "user_id": generation_request.user_profile.user_id,
            "target_calories": generation_request.nutrition_targets.calories,
            "target_protein": generation_request.nutrition_targets.protein,
            "target_carbs": generation_request.nutrition_targets.carbs,
            "target_fat": generation_request.nutrition_targets.fat,
            "dietary_preferences": generation_request.user_profile.dietary_preferences,
            "health_conditions": generation_request.user_profile.health_conditions,
            "allergies": generation_request.user_profile.allergies,
            "activity_level": generation_request.user_profile.activity_level,
            "fitness_goal": generation_request.user_profile.fitness_goal,
            "meals_per_day": generation_request.user_profile.meals_per_day,
            "include_snacks": generation_request.user_profile.include_snacks,
            "start_date_obj": request_data.get("start_date_obj") if request_data else None,
            "end_date_obj": request_data.get("end_date_obj") if request_data else None
        }
</file>

<file path="src/domain/services/meal_suggestion/json_extractor.py">
"""JSON extraction utilities for meal suggestion responses."""
import json
import re
from typing import Dict


class JsonExtractor:
    """Extracts JSON from AI responses."""

    @staticmethod
    def extract_json(content: str) -> Dict:
        """Extract JSON from AI response."""
        try:
            # Try direct parsing
            return json.loads(content)
        except json.JSONDecodeError:
            # Try to find JSON in markdown code block
            json_match = re.search(r'```json(.*?)```', content, re.DOTALL)
            if json_match:
                return json.loads(json_match.group(1).strip())

            # Try to find any JSON-like structure
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            if json_match:
                return json.loads(json_match.group(0))

            raise ValueError("Could not extract JSON from response")

    @staticmethod
    def extract_unified_meals_json(content: str) -> Dict:
        """Extract JSON from unified meal response."""
        try:
            # Try direct parsing
            data = json.loads(content)

            # Validate structure
            if "meals" not in data or not isinstance(data["meals"], list):
                raise ValueError("Response missing 'meals' array")

            return data

        except json.JSONDecodeError:
            # Try to find JSON in markdown code block
            json_match = re.search(r'```json(.*?)```', content, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group(1).strip())
                if "meals" not in data or not isinstance(data["meals"], list):
                    raise ValueError("Response missing 'meals' array")
                return data

            # Try to find any JSON-like structure
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            if json_match:
                data = json.loads(json_match.group(0))
                if "meals" not in data or not isinstance(data["meals"], list):
                    raise ValueError("Response missing 'meals' array")
                return data

            raise ValueError("Could not extract unified meals JSON from response")
</file>

<file path="src/domain/services/meal_suggestion/suggestion_fallback_provider.py">
"""Fallback meal provider for suggestion service."""
from src.domain.model.meal_planning import PlannedMeal, MealType


class SuggestionFallbackProvider:
    """Provides fallback meals when AI generation fails."""

    @staticmethod
    def get_fallback_meal(meal_type: MealType, calorie_target: float) -> PlannedMeal:
        """Return a simple fallback meal if generation fails."""
        # Scale portions based on calorie target
        scale_factor = calorie_target / 400  # Base meals are ~400 calories

        fallback_meals = {
            MealType.BREAKFAST: {
                "name": "Protein Oatmeal Bowl",
                "description": "Hearty oatmeal with protein powder and fruits",
                "prep_time": 5,
                "cook_time": 5,
                "calories": int(400 * scale_factor),
                "protein": int(25 * scale_factor),
                "carbs": int(55 * scale_factor),
                "fat": int(10 * scale_factor),
                "ingredients": [
                    f"{int(60 * scale_factor)}g rolled oats",
                    f"{int(30 * scale_factor)}g protein powder",
                    "1 medium banana",
                    "1 tablespoon almond butter",
                    "Cinnamon to taste"
                ],
                "instructions": [
                    "Cook oats with water or milk",
                    "Stir in protein powder",
                    "Top with sliced banana and almond butter",
                    "Sprinkle with cinnamon"
                ],
                "is_vegetarian": True,
                "is_vegan": False,
                "is_gluten_free": False
            },
            MealType.LUNCH: {
                "name": "Grilled Chicken Salad Bowl",
                "description": "Fresh salad with grilled chicken and vegetables",
                "prep_time": 15,
                "cook_time": 15,
                "calories": int(450 * scale_factor),
                "protein": int(35 * scale_factor),
                "carbs": int(30 * scale_factor),
                "fat": int(20 * scale_factor),
                "ingredients": [
                    f"{int(150 * scale_factor)}g grilled chicken breast",
                    "Mixed greens",
                    "Cherry tomatoes",
                    "Cucumber",
                    "Avocado",
                    "Olive oil vinaigrette"
                ],
                "instructions": [
                    "Grill chicken breast",
                    "Prepare salad greens and vegetables",
                    "Slice grilled chicken",
                    "Assemble bowl and dress"
                ],
                "is_vegetarian": False,
                "is_vegan": False,
                "is_gluten_free": True
            },
            MealType.DINNER: {
                "name": "Baked Salmon with Vegetables",
                "description": "Omega-3 rich salmon with roasted vegetables",
                "prep_time": 10,
                "cook_time": 25,
                "calories": int(500 * scale_factor),
                "protein": int(40 * scale_factor),
                "carbs": int(35 * scale_factor),
                "fat": int(22 * scale_factor),
                "ingredients": [
                    f"{int(180 * scale_factor)}g salmon fillet",
                    "Broccoli",
                    "Sweet potato",
                    "Olive oil",
                    "Lemon",
                    "Herbs"
                ],
                "instructions": [
                    "Season salmon with herbs",
                    "Prepare vegetables",
                    "Bake everything at 400°F for 20-25 minutes",
                    "Serve with lemon"
                ],
                "is_vegetarian": False,
                "is_vegan": False,
                "is_gluten_free": True
            },
            MealType.SNACK: {
                "name": "Greek Yogurt with Berries",
                "description": "High-protein snack with antioxidants",
                "prep_time": 2,
                "cook_time": 0,
                "calories": int(200 * scale_factor),
                "protein": int(15 * scale_factor),
                "carbs": int(20 * scale_factor),
                "fat": int(5 * scale_factor),
                "ingredients": [
                    f"{int(170 * scale_factor)}g Greek yogurt",
                    "Mixed berries",
                    "Honey (optional)"
                ],
                "instructions": [
                    "Add berries to yogurt",
                    "Drizzle with honey if desired"
                ],
                "is_vegetarian": True,
                "is_vegan": False,
                "is_gluten_free": True
            }
        }

        meal_data = fallback_meals.get(meal_type, fallback_meals[MealType.LUNCH])
        return PlannedMeal(meal_type=meal_type, **meal_data)
</file>

<file path="src/domain/services/__init__.py">
from .conversation_service import ConversationService
from .daily_meal_suggestion_service import DailyMealSuggestionService
from .meal_plan_service import MealPlanService
from .nutrition_calculation_service import NutritionCalculationService, ScaledNutritionResult
from .portion_calculation_service import PortionCalculationService
from .tdee_service import TdeeCalculationService

__all__ = [
    "TdeeCalculationService",
    "MealPlanService",
    "ConversationService",
    "DailyMealSuggestionService",
    "NutritionCalculationService",
    "ScaledNutritionResult",
    "PortionCalculationService"
]
</file>

<file path="src/domain/services/fallback_meal_service.py">
"""
Domain service for providing fallback meals when generation fails.
"""
from typing import Dict

from src.domain.model.meal_planning import GeneratedMeal, NutritionSummary
from src.domain.model.meal_planning import MealType


class FallbackMealService:
    """Service for providing fallback meals when AI generation fails."""
    
    def get_fallback_meal(self, meal_type: MealType, calorie_target: int) -> GeneratedMeal:
        """Get a fallback meal for the specified type and calorie target."""
        # Scale portions based on calorie target
        scale_factor = calorie_target / 400  # Base meals are ~400 calories
        
        fallback_templates = self._get_fallback_templates()
        template = fallback_templates.get(meal_type, fallback_templates[MealType.LUNCH])
        
        # Scale nutrition and portions
        scaled_nutrition = NutritionSummary(
            calories=int(template["base_calories"] * scale_factor),
            protein=template["base_protein"] * scale_factor,
            carbs=template["base_carbs"] * scale_factor,
            fat=template["base_fat"] * scale_factor
        )
        
        # Scale ingredient portions
        scaled_ingredients = []
        for ingredient in template["ingredients"]:
            if "{portion}" in ingredient:
                portion = int(template.get("base_portion", 100) * scale_factor)
                scaled_ingredients.append(ingredient.format(portion=portion))
            else:
                scaled_ingredients.append(ingredient)
        
        return GeneratedMeal(
            meal_id=f"fallback_{meal_type.value}_{calorie_target}",
            meal_type=meal_type.value,
            name=template["name"],
            description=template["description"],
            prep_time=template["prep_time"],
            cook_time=template["cook_time"],
            nutrition=scaled_nutrition,
            ingredients=scaled_ingredients,
            seasonings=template["seasonings"],
            instructions=template["instructions"],
            is_vegetarian=template["is_vegetarian"],
            is_vegan=template["is_vegan"],
            is_gluten_free=template["is_gluten_free"],
            cuisine_type=template["cuisine_type"]
        )
    
    def _get_fallback_templates(self) -> Dict[MealType, Dict]:
        """Get fallback meal templates."""
        return {
            MealType.BREAKFAST: {
                "name": "Protein Oatmeal Bowl",
                "description": "Hearty oatmeal with protein powder and fruits",
                "prep_time": 5,
                "cook_time": 5,
                "base_calories": 400,
                "base_protein": 25.0,
                "base_carbs": 55.0,
                "base_fat": 10.0,
                "base_portion": 60,
                "ingredients": [
                    "{portion}g rolled oats",
                    "30g protein powder",
                    "1 medium banana",
                    "15ml almond butter"
                ],
                "seasonings": [
                    "1g ground cinnamon",
                    "0.5g salt",
                    "2ml vanilla extract"
                ],
                "instructions": [
                    "Cook oats with water or milk",
                    "Stir in protein powder",
                    "Top with sliced banana and almond butter"
                ],
                "is_vegetarian": True,
                "is_vegan": False,
                "is_gluten_free": False,
                "cuisine_type": "International"
            },
            MealType.LUNCH: {
                "name": "Grilled Chicken Salad Bowl",
                "description": "Fresh salad with grilled chicken and vegetables",
                "prep_time": 15,
                "cook_time": 15,
                "base_calories": 450,
                "base_protein": 35.0,
                "base_carbs": 30.0,
                "base_fat": 20.0,
                "base_portion": 150,
                "ingredients": [
                    "{portion}g grilled chicken breast",
                    "100g mixed greens",
                    "150g cherry tomatoes",
                    "100g diced cucumber",
                    "50g sliced avocado"
                ],
                "seasonings": [
                    "15ml olive oil",
                    "2g salt",
                    "1g black pepper",
                    "15ml lemon juice",
                    "2g garlic powder"
                ],
                "instructions": [
                    "Grill chicken breast",
                    "Prepare salad greens and vegetables",
                    "Slice grilled chicken",
                    "Assemble bowl and dress"
                ],
                "is_vegetarian": False,
                "is_vegan": False,
                "is_gluten_free": True,
                "cuisine_type": "International"
            },
            MealType.DINNER: {
                "name": "Baked Salmon with Vegetables",
                "description": "Omega-3 rich salmon with roasted vegetables",
                "prep_time": 10,
                "cook_time": 25,
                "base_calories": 500,
                "base_protein": 40.0,
                "base_carbs": 35.0,
                "base_fat": 22.0,
                "base_portion": 180,
                "ingredients": [
                    "{portion}g salmon fillet",
                    "200g broccoli florets",
                    "1 medium sweet potato",
                    "15ml olive oil",
                    "1 lemon"
                ],
                "seasonings": [
                    "3g dried dill",
                    "2g salt",
                    "1g black pepper",
                    "2g garlic powder",
                    "5g lemon zest"
                ],
                "instructions": [
                    "Season salmon with herbs",
                    "Prepare vegetables",
                    "Bake everything at 400°F for 20-25 minutes",
                    "Serve with lemon"
                ],
                "is_vegetarian": False,
                "is_vegan": False,
                "is_gluten_free": True,
                "cuisine_type": "International"
            },
            MealType.SNACK: {
                "name": "Greek Yogurt with Berries",
                "description": "High-protein snack with antioxidants",
                "prep_time": 2,
                "cook_time": 0,
                "base_calories": 200,
                "base_protein": 15.0,
                "base_carbs": 20.0,
                "base_fat": 5.0,
                "base_portion": 170,
                "ingredients": [
                    "{portion}g Greek yogurt",
                    "75g mixed berries",
                    "5ml honey (optional)"
                ],
                "seasonings": [
                    "2ml vanilla extract",
                    "1g ground cinnamon",
                    "0.5g salt"
                ],
                "instructions": [
                    "Add berries to yogurt",
                    "Drizzle with honey if desired"
                ],
                "is_vegetarian": True,
                "is_vegan": False,
                "is_gluten_free": True,
                "cuisine_type": "International"
            }
        }
</file>

<file path="src/domain/services/food_mapping_service.py">
"""
Maps USDA FDC responses into internal simplified structures and domain-friendly dictionaries.
Keeps logic flat and readable.
"""
from typing import Dict, Any, List

USDA_NUTRIENT_MAPPING = {
    1008: "calories",  # Energy (cal)
    1003: "protein",   # Protein (g)
    1005: "carbs",     # Carbohydrate (g)
    1004: "fat",       # Total lipid (fat) (g)
}


from src.domain.ports.food_mapping_service_port import FoodMappingServicePort


class FoodMappingService(FoodMappingServicePort):
    def map_search_item(self, item: Dict[str, Any]) -> Dict[str, Any]:
        # Extract nutrients from search results
        nutrients = self._extract_macros(item.get("foodNutrients") or [])
        
        return {
            "fdc_id": item.get("fdcId"),
            "name": item.get("description"),
            "brand": item.get("brandOwner"),
            "data_type": item.get("dataType"),
            "published_date": item.get("publishedDate"),
            "serving_size": item.get("servingSize"),
            "serving_unit": item.get("servingSizeUnit"),
            "calories": nutrients.get("calories"),
            "nutrients": {
                "protein": nutrients.get("protein"),
                "fat": nutrients.get("fat"),
                "carbs": nutrients.get("carbs"),
            },
        }

    def _extract_macros(self, nutrients: List[Dict[str, Any]]) -> Dict[str, float]:
        values: Dict[str, float] = {"calories": 0.0, "protein": 0.0, "carbs": 0.0, "fat": 0.0}
        for entry in nutrients or []:
            # Handle both search results format and details format
            if "nutrient" in entry:
                # Details format: nested structure
                nutrient = entry.get("nutrient") or {}
                nutrient_id = nutrient.get("id")
                amount = float(entry.get("amount") or 0.0)
            else:
                # Search results format: flat structure
                nutrient_id = entry.get("nutrientId")
                amount = float(entry.get("value") or 0.0)
            
            key = USDA_NUTRIENT_MAPPING.get(nutrient_id)
            if key:
                values[key] = amount
        return values

    def map_food_details(self, details: Dict[str, Any]) -> Dict[str, Any]:
        macros = self._extract_macros(details.get("foodNutrients") or [])
        return {
            "fdc_id": details.get("fdcId"),
            "name": details.get("description"),
            "brand": details.get("brandOwner"),
            "serving_size": details.get("servingSize"),
            "serving_unit": details.get("servingSizeUnit"),
            "calories": macros.get("calories"),
            "macros": {
                "protein": macros.get("protein"),
                "carbs": macros.get("carbs"),
                "fat": macros.get("fat"),
            },
            "portions": details.get("foodPortions") or [],
        }
</file>

<file path="src/domain/services/ingredient_based_meal_plan_service.py">
"""
Daily ingredient-based meal plan service.
Uses the unified orchestration service.
"""
import logging
from typing import Dict, Any

from src.domain.model.meal_planning import DailyMealPlan
from src.domain.services.meal_plan_orchestration_service import MealPlanOrchestrationService
from src.infra.adapters.meal_generation_service import MealGenerationService

logger = logging.getLogger(__name__)


class IngredientBasedMealPlanService:
    """Service for generating daily ingredient-based meal plans."""
    
    def __init__(self):
        meal_generation_service = MealGenerationService()
        self.orchestration_service = MealPlanOrchestrationService(meal_generation_service)
    
    def generate_ingredient_based_meal_plan(self, request_data: Dict[str, Any]) -> DailyMealPlan:
        """Generate daily ingredient-based meal plan using orchestration service."""
        return self.orchestration_service.generate_daily_ingredient_based_plan(request_data)
</file>

<file path="src/domain/services/meal_distribution_service.py">
"""
Domain service for calculating calorie distribution across meals.
"""
from typing import List

from src.domain.model.meal_planning import CalorieDistribution, UserNutritionTargets
from src.domain.model.meal_planning import MealType


class MealDistributionService:
    """Service for calculating calorie distribution across meal types."""
    
    # Standard distribution ratios
    BREAKFAST_RATIO = 0.25
    LUNCH_RATIO = 0.35
    DINNER_RATIO = 0.40
    SNACK_RATIO = 0.10
    
    def calculate_distribution(
        self, 
        meal_types: List[MealType], 
        nutrition_targets: UserNutritionTargets
    ) -> CalorieDistribution:
        """Calculate calorie distribution for given meal types."""
        target_calories = nutrition_targets.calories
        
        num_snacks = sum(1 for mt in meal_types if mt == MealType.SNACK)
        
        # Reserve calories for snacks
        snack_calories_per_snack = int(target_calories * self.SNACK_RATIO) if num_snacks > 0 else 0
        remaining_calories = target_calories - (num_snacks * snack_calories_per_snack)
        
        distribution = {}
        
        for meal_type in meal_types:
            if meal_type == MealType.SNACK:
                distribution[meal_type] = snack_calories_per_snack
            elif meal_type == MealType.BREAKFAST:
                distribution[meal_type] = int(remaining_calories * self.BREAKFAST_RATIO)
            elif meal_type == MealType.LUNCH:
                distribution[meal_type] = int(remaining_calories * self.LUNCH_RATIO)
            elif meal_type == MealType.DINNER:
                distribution[meal_type] = int(remaining_calories * self.DINNER_RATIO)
            else:
                # Default for any other meal types
                distribution[meal_type] = int(remaining_calories / 3)
        
        return CalorieDistribution(distribution)
</file>

<file path="src/domain/services/meal_plan_persistence_service.py">
"""
Shared meal plan persistence service.
Handles conversion between domain models and ORM models.
"""
import logging
from datetime import datetime, timedelta
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.domain.model.meal_planning import UserPreferences
from src.infra.database.models.enums import (
    FitnessGoalEnum,
    PlanDurationEnum,
    MealTypeEnum,
)
from src.infra.database.models.meal_planning import (
    MealPlan as MealPlanORM,
    MealPlanDay as MealPlanDayORM,
    PlannedMeal as PlannedMealORM,
)

logger = logging.getLogger(__name__)


class MealPlanPersistenceService:
    """Shared service for meal plan persistence operations."""
    
    def __init__(self, db: Session):
        self.db = db
    
    def save_daily_meal_plan(self, meal_plan_data: Dict[str, Any], user_preferences: UserPreferences, user_id: str) -> str:
        """Save a daily meal plan and return the plan ID."""
        try:
            # Convert domain enums to database enums
            fitness_goal_orm = FitnessGoalEnum(user_preferences.fitness_goal.value)
            plan_duration_orm = PlanDurationEnum(user_preferences.plan_duration.value)
            
            # Create ORM meal plan
            meal_plan_orm = MealPlanORM(
                user_id=user_id,
                dietary_preferences=[pref.value for pref in user_preferences.dietary_preferences],
                allergies=user_preferences.allergies,
                fitness_goal=fitness_goal_orm,
                meals_per_day=user_preferences.meals_per_day,
                snacks_per_day=user_preferences.snacks_per_day,
                cooking_time_weekday=user_preferences.cooking_time_weekday,
                cooking_time_weekend=user_preferences.cooking_time_weekend,
                favorite_cuisines=user_preferences.favorite_cuisines,
                disliked_ingredients=user_preferences.disliked_ingredients,
                plan_duration=plan_duration_orm,
            )
            self.db.add(meal_plan_orm)
            self.db.flush()  # Get the meal plan ID
            
            # Create day plan for today
            day_plan_orm = MealPlanDayORM(
                meal_plan_id=meal_plan_orm.id,
                date=datetime.now().date()
            )
            self.db.add(day_plan_orm)
            self.db.flush()
            
            # Create planned meals
            for meal_data in meal_plan_data.get('meals', []):
                meal_orm_data = self._meal_dict_to_orm_data(meal_data)
                meal_orm = PlannedMealORM(
                    day_id=day_plan_orm.id,
                    **meal_orm_data
                )
                self.db.add(meal_orm)
            
            self.db.commit()
            return str(meal_plan_orm.id)
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to save daily meal plan: {e}")
            raise
    
    def save_weekly_meal_plan(self, plan_json: Dict[str, Any], user_preferences: UserPreferences, user_id: str) -> str:
        """Save a weekly meal plan and return the plan ID."""
        try:
            # Convert domain enums to database enums
            fitness_goal_orm = FitnessGoalEnum(user_preferences.fitness_goal.value)
            plan_duration_orm = PlanDurationEnum(user_preferences.plan_duration.value)
            
            # Create ORM meal plan
            meal_plan_orm = MealPlanORM(
                user_id=user_id,
                dietary_preferences=[pref.value for pref in user_preferences.dietary_preferences],
                allergies=user_preferences.allergies,
                fitness_goal=fitness_goal_orm,
                meals_per_day=user_preferences.meals_per_day,
                snacks_per_day=user_preferences.snacks_per_day,
                cooking_time_weekday=user_preferences.cooking_time_weekday,
                cooking_time_weekend=user_preferences.cooking_time_weekend,
                favorite_cuisines=user_preferences.favorite_cuisines,
                disliked_ingredients=user_preferences.disliked_ingredients,
                plan_duration=plan_duration_orm,
            )
            self.db.add(meal_plan_orm)
            self.db.flush()
            
            # Create day plans for the week
            today = datetime.now().date()
            weekday_index = {
                "monday": 0, "tuesday": 1, "wednesday": 2, "thursday": 3,
                "friday": 4, "saturday": 5, "sunday": 6,
            }
            
            for day_name, day_data in plan_json["days"].items():
                offset = weekday_index[day_name.lower()]
                day_date = today + timedelta(days=offset)
                
                # Create ORM MealPlanDay
                day_plan_orm = MealPlanDayORM(
                    meal_plan_id=meal_plan_orm.id,
                    date=day_date
                )
                self.db.add(day_plan_orm)
                self.db.flush()
                
                # Create planned meals for this day
                # day_data is now a list of meals directly (matching schema)
                meals_list = day_data if isinstance(day_data, list) else []
                for meal_json in meals_list:
                    meal_orm_data = self._meal_dict_to_orm_data(meal_json)
                    meal_orm = PlannedMealORM(
                        day_id=day_plan_orm.id,
                        **meal_orm_data
                    )
                    self.db.add(meal_orm)
            
            self.db.commit()
            return str(meal_plan_orm.id)
            
        except Exception as e:
            self.db.rollback()
            logger.error(f"Failed to save weekly meal plan: {e}")
            raise
    
    def _meal_dict_to_orm_data(self, meal_data: Dict[str, Any]) -> Dict[str, Any]:
        """Convert meal dictionary to ORM PlannedMeal data."""
        try:
            meal_type = MealTypeEnum(meal_data["meal_type"].lower())
        except (KeyError, ValueError):
            logger.warning("Unknown or missing meal_type – defaulting to breakfast")
            meal_type = MealTypeEnum.breakfast

        return {
            "meal_type": meal_type,
            "name": meal_data.get("name", "Unnamed meal"),
            "description": meal_data.get("description", ""),
            "prep_time": meal_data.get("prep_time", 0),
            "cook_time": meal_data.get("cook_time", 0),
            "calories": meal_data.get("calories", 0),
            "protein": meal_data.get("protein", 0.0),
            "carbs": meal_data.get("carbs", 0.0),
            "fat": meal_data.get("fat", 0.0),
            "ingredients": meal_data.get("ingredients", []),
            "seasonings": meal_data.get("seasonings", []),
            "instructions": meal_data.get("instructions", []),
            "is_vegetarian": meal_data.get("is_vegetarian", False),
            "is_vegan": meal_data.get("is_vegan", False),
            "is_gluten_free": meal_data.get("is_gluten_free", False),
            "cuisine_type": meal_data.get("cuisine_type", "International"),
        }
</file>

<file path="src/domain/services/meal_type_determination_service.py">
"""
Domain service for determining required meal types based on user preferences.
"""
from typing import List

from src.domain.model.meal_planning import MealType


class MealTypeDeterminationService:
    """Service for determining what meal types to generate."""
    
    def determine_meal_types(self, meals_per_day: int, include_snacks: bool) -> List[MealType]:
        """Determine what meal types to generate based on user preferences."""
        meal_types = [MealType.BREAKFAST, MealType.LUNCH, MealType.DINNER]
        
        # Add additional meals if requested (beyond standard 3)
        if meals_per_day > 3:
            additional_meals = meals_per_day - 3
            for _ in range(additional_meals):
                meal_types.append(MealType.SNACK)
        
        # Add snacks if specifically requested and not already included
        if include_snacks and MealType.SNACK not in meal_types:
            meal_types.append(MealType.SNACK)
        
        return meal_types
</file>

<file path="src/domain/services/nutrition_calculation_service.py">
"""
Nutrition calculation service - domain service for nutrition-related operations.
Provides a unified interface for calculating nutrition from various sources.
"""
import logging
from dataclasses import dataclass
from typing import Optional, List

from src.domain.model.nutrition import FoodItem, Nutrition
from src.domain.model.nutrition import Macros

logger = logging.getLogger(__name__)


@dataclass
class ScaledNutritionResult:
    """Result of nutrition calculation for a specific quantity."""
    calories: float
    protein: float
    carbs: float
    fat: float


class NutritionCalculationService:
    """
    Domain service for calculating nutrition from various sources.

    Provides a single source of truth for nutrition calculations, with
    fallback mechanisms for robustness.
    """

    def __init__(self, pinecone_service=None, usda_service=None):
        """
        Initialize with optional services.

        Args:
            pinecone_service: Pinecone vector search service for ingredient lookup
            usda_service: USDA FoodData Central API service
        """
        self.pinecone_service = pinecone_service
        self.usda_service = usda_service

    def get_nutrition_for_ingredient(
        self,
        name: str,
        quantity: float,
        unit: str,
        fdc_id: Optional[int] = None
    ) -> Optional[ScaledNutritionResult]:
        """
        Get nutrition data for an ingredient from any available source.

        Priority:
        1. USDA FoodData Central (if fdc_id provided)
        2. Pinecone vector search (semantic matching)
        3. None if no source available

        Args:
            name: Ingredient name
            quantity: Amount of ingredient
            unit: Unit of measurement
            fdc_id: Optional USDA FDC ID for direct lookup

        Returns:
            ScaledNutritionResult or None if not found
        """
        # Priority 1: USDA direct lookup if FDC ID provided
        if fdc_id and self.usda_service:
            try:
                result = self._get_from_usda(fdc_id, quantity, unit)
                if result:
                    logger.info(f"Got nutrition for '{name}' from USDA (fdc_id={fdc_id})")
                    return result
            except Exception as e:
                logger.warning(f"USDA lookup failed for fdc_id={fdc_id}: {e}")

        # Priority 2: Pinecone semantic search
        if self.pinecone_service:
            try:
                result = self._get_from_pinecone(name, quantity, unit)
                if result:
                    logger.info(f"Got nutrition for '{name}' from Pinecone")
                    return result
            except Exception as e:
                logger.warning(f"Pinecone lookup failed for '{name}': {e}")

        logger.warning(f"Could not find nutrition data for '{name}'")
        return None

    def _get_from_pinecone(
        self,
        name: str,
        quantity: float,
        unit: str
    ) -> Optional[ScaledNutritionResult]:
        """Get nutrition from Pinecone service."""
        if not self.pinecone_service:
            return None

        scaled_nutrition = self.pinecone_service.get_scaled_nutrition(
            ingredient_name=name,
            quantity=quantity,
            unit=unit
        )

        if scaled_nutrition:
            return ScaledNutritionResult(
                calories=scaled_nutrition.calories,
                protein=scaled_nutrition.protein,
                carbs=scaled_nutrition.carbs,
                fat=scaled_nutrition.fat
            )

        return None

    def _get_from_usda(
        self,
        fdc_id: int,
        quantity: float,
        unit: str
    ) -> Optional[ScaledNutritionResult]:
        """Get nutrition from USDA service."""
        if not self.usda_service:
            return None

        # USDA service would need to be implemented
        # For now, return None as placeholder
        logger.debug(f"USDA service not yet fully implemented for fdc_id={fdc_id}")
        return None

    def calculate_meal_total(self, food_items: List[FoodItem]) -> Nutrition:
        """
        Calculate total nutrition from a list of food items.

        Args:
            food_items: List of food items in the meal

        Returns:
            Nutrition object with totals
        """
        if not food_items:
            return Nutrition(
                calories=0,
                macros=Macros(protein=0, carbs=0, fat=0),
                food_items=[],
                confidence_score=1.0
            )

        total_calories = sum(item.calories for item in food_items)
        total_protein = sum(item.macros.protein for item in food_items)
        total_carbs = sum(item.macros.carbs for item in food_items)
        total_fat = sum(item.macros.fat for item in food_items)

        # Calculate average confidence
        avg_confidence = sum(item.confidence for item in food_items) / len(food_items)

        return Nutrition(
            calories=total_calories,
            macros=Macros(
                protein=total_protein,
                carbs=total_carbs,
                fat=total_fat
            ),
            food_items=food_items,
            confidence_score=avg_confidence
        )

    def scale_nutrition(
        self,
        original_nutrition: ScaledNutritionResult,
        original_quantity: float,
        new_quantity: float
    ) -> ScaledNutritionResult:
        """
        Scale nutrition proportionally based on quantity change.

        Args:
            original_nutrition: Original nutrition values
            original_quantity: Original quantity
            new_quantity: New quantity

        Returns:
            Scaled nutrition values
        """
        if original_quantity <= 0:
            raise ValueError(f"Original quantity must be positive: {original_quantity}")

        scale_factor = new_quantity / original_quantity

        return ScaledNutritionResult(
            calories=original_nutrition.calories * scale_factor,
            protein=original_nutrition.protein * scale_factor,
            carbs=original_nutrition.carbs * scale_factor,
            fat=original_nutrition.fat * scale_factor
        )
</file>

<file path="src/domain/services/portion_calculation_service.py">
"""Service for calculating meal portion sizes based on user profile."""

from src.domain.model.meal_suggestion.portion_target import PortionTarget


class PortionCalculationService:
    """Calculate target calories based on meal type and user profile.

    All calculations are percentage-based from user's daily TDEE:
    - Snack: 10-15% of daily target (default 12%)
    - Main: ~33% of daily target (one of ~3 meals/day)
    - OMAD: 100% of daily target
    """

    # Percentage-based constants
    SNACK_MIN_PERCENT = 0.10  # 10% of daily
    SNACK_MAX_PERCENT = 0.15  # 15% of daily
    SNACK_DEFAULT_PERCENT = 0.12  # 12% of daily (midpoint)

    MAIN_MEAL_PERCENT = 0.33  # ~33% of daily (1/3)
    MAIN_VARIANCE_PERCENT = 0.15  # ±15% variance

    OMAD_PERCENT = 1.0  # 100% of daily
    OMAD_VARIANCE_PERCENT = 0.10  # ±10% variance

    def calculate_snack_target(self, daily_target: int) -> PortionTarget:
        """Snack = 10-15% of daily target."""
        target = int(daily_target * self.SNACK_DEFAULT_PERCENT)
        min_cal = int(daily_target * self.SNACK_MIN_PERCENT)
        max_cal = int(daily_target * self.SNACK_MAX_PERCENT)

        return PortionTarget(
            target_calories=target,
            min_calories=min_cal,
            max_calories=max_cal,
            meals_per_day=0,  # N/A for snacks
        )

    def calculate_main_meal_target(
        self, daily_target: int, meals_per_day: int = 3
    ) -> PortionTarget:
        """Main meal = ~33% of daily target (±15% variance)."""
        target = int(daily_target * self.MAIN_MEAL_PERCENT)
        variance = int(target * self.MAIN_VARIANCE_PERCENT)

        return PortionTarget(
            target_calories=target,
            min_calories=target - variance,
            max_calories=target + variance,
            meals_per_day=meals_per_day,
        )

    def calculate_omad_target(self, daily_target: int) -> PortionTarget:
        """OMAD = 100% of daily target (±10% variance)."""
        target = int(daily_target * self.OMAD_PERCENT)
        variance = int(target * self.OMAD_VARIANCE_PERCENT)

        return PortionTarget(
            target_calories=target,
            min_calories=target - variance,
            max_calories=target + variance,
            meals_per_day=1,
        )

    def get_target_for_meal_type(
        self, meal_type: str, daily_target: int, meals_per_day: int = 3
    ) -> PortionTarget:
        """Get portion target based on meal type (percentage-based)."""
        if meal_type == "snack":
            return self.calculate_snack_target(daily_target)
        elif meal_type == "main":
            return self.calculate_main_meal_target(daily_target, meals_per_day)
        elif meal_type == "omad":
            return self.calculate_omad_target(daily_target)
        else:
            # Fallback to main meal
            return self.calculate_main_meal_target(daily_target, meals_per_day)
</file>

<file path="src/domain/services/prompt_generation_service.py">
"""
Domain service for generating prompts for meal generation.
"""
from src.domain.model.conversation import PromptContext
from src.domain.model.meal_planning import MealGenerationContext, MealGenerationType
from src.domain.model.meal_planning import MealType


class PromptGenerationService:
    """Service for generating prompts based on meal generation context."""
    
    def generate_prompt_and_system_message(self, context: MealGenerationContext) -> tuple[str, str]:
        """Generate prompt and system message for the given context."""
        prompt_context = PromptContext(context)
        
        if context.request.generation_type == MealGenerationType.WEEKLY_INGREDIENT_BASED:
            return self._generate_weekly_ingredient_prompt(prompt_context)
        elif context.request.generation_type == MealGenerationType.DAILY_INGREDIENT_BASED:
            return self._generate_daily_ingredient_prompt(prompt_context)
        elif context.request.generation_type == MealGenerationType.DAILY_PROFILE_BASED:
            return self._generate_daily_profile_prompt(prompt_context)
        else:
            raise ValueError(f"Unsupported generation type: {context.request.generation_type}")
    
    def generate_single_meal_prompt(self, meal_type: MealType, calorie_target: int, context: MealGenerationContext) -> tuple[str, str]:
        """Generate prompt for a single meal."""
        prompt_context = PromptContext(context)
        
        if context.is_ingredient_based():
            return self._generate_single_ingredient_meal_prompt(meal_type, calorie_target, prompt_context)
        else:
            return self._generate_single_profile_meal_prompt(meal_type, calorie_target, prompt_context)
    
    def _generate_weekly_ingredient_prompt(self, context: PromptContext) -> tuple[str, str]:
        """Generate weekly ingredient-based meal plan prompt."""
        meals_per_day = len(context.generation_context.meal_types)
        
        # Create a more explicit schema with portions and seasonings
        schema = (
            '{\n'
            '  "week": [\n'
            '    {\n'
            '      "day": "Monday",\n'
            '      "meals": [\n'
            '        {\n'
            '          "meal_type": "breakfast",\n'
            '          "name": "Meal Name",\n'
            '          "description": "Brief description",\n'
            '          "calories": 400,\n'
            '          "protein": 25.0,\n'
            '          "carbs": 45.0,\n'
            '          "fat": 15.0,\n'
            '          "prep_time": 10,\n'
            '          "cook_time": 15,\n'
            '          "ingredients": ["300g brown rice", "450g chicken breast", "100g mixed greens", "150g cherry tomatoes", "15ml olive oil"],\n'
            '          "seasonings": ["2g salt", "1g black pepper", "3g dried oregano"],\n'
            '          "instructions": ["step1", "step2"],\n'
            '          "is_vegetarian": true,\n'
            '          "is_vegan": false,\n'
            '          "is_gluten_free": false,\n'
            '          "cuisine_type": "International"\n'
            '        }\n'
            '      ]\n'
            '    }\n'
            '  ]\n'
            '}'
        )
        
        snack_requirement = ""
        if context.generation_context.request.user_profile.include_snacks:
            snack_requirement = "\n6. Include 1 healthy snack per day."
        
        snack_text = " + 1 snack" if context.generation_context.request.user_profile.include_snacks else ""
        
        # Build detailed nutritional targets
        nutrition_targets = context.generation_context.request.nutrition_targets
        daily_targets = (
            f"DAILY NUTRITION TARGETS (must be met exactly each day):\n"
            f"- Calories: {nutrition_targets.calories}\n"
            f"- Protein: {nutrition_targets.protein}g\n"
            f"- Carbs: {nutrition_targets.carbs}g\n"
            f"- Fat: {nutrition_targets.fat}g\n"
        )
        
        # Build meal-specific targets
        meal_targets = []
        for meal_type in context.generation_context.meal_types:
            calorie_target = context.generation_context.calorie_distribution.get_calories_for_meal(meal_type)
            meal_percentage = calorie_target / nutrition_targets.calories
            protein_target = nutrition_targets.protein * meal_percentage
            carbs_target = nutrition_targets.carbs * meal_percentage
            fat_target = nutrition_targets.fat * meal_percentage
            
            meal_targets.append(
                f"- {meal_type.value.title()}: {calorie_target} cal, {protein_target:.1f}g protein, {carbs_target:.1f}g carbs, {fat_target:.1f}g fat"
            )
        
        meal_targets_text = "MEAL TARGETS PER DAY:\n" + "\n".join(meal_targets)
        
        week_dates = context.get_week_dates_text()
        prompt = (
            f"Generate a 7-day meal plan for {week_dates} using ONLY these ingredients.\n\n"
            f"Available Ingredients: {context.get_ingredients_text()}\n"
            f"Available Seasonings: {context.get_seasonings_text()}{context.get_dietary_requirements_text()}\n\n"
            f"{daily_targets}\n"
            f"{meal_targets_text}\n\n"
            f"CRITICAL REQUIREMENTS:\n"
            f"- Generate exactly {meals_per_day} meals per day: {context.get_meal_types_text()}\n"
            f"- Use ONLY the listed ingredients and seasonings above\n\n"
            f"INGREDIENT REQUIREMENTS (MANDATORY):\n"
            f"- EVERY SINGLE ingredient MUST include exact measurements and portions - NO EXCEPTIONS\n"
            f"- FORBIDDEN: Any ingredient without a specific amount (e.g., 'Mixed greens', 'Cherry tomatoes', 'Cucumber')\n"
            f"- REQUIRED: ALL ingredients with precise portions using WORLD-STANDARD units (grams, milliliters, pieces)\n"
            f"- Use INTERNATIONAL units: grams (g), milliliters (ml), pieces, slices, cloves - NOT region-specific cups/pounds/ounces\n"
            f"- Use precise portions: '300g brown rice', '450g chicken breast', '250g salmon fillet', '200g quinoa'\n"
            f"- ALL vegetables MUST have portions: '100g mixed greens', '150g cherry tomatoes', '100g diced cucumber', '50g sliced avocado'\n"
            f"- Common ingredient portions: proteins (400-600g), grains/starches (200-400g), vegetables (100-300g), oils (15-30ml)\n"
            f"- Example ingredients array: ['450g chicken breast', '300g brown rice', '150g broccoli florets', '15ml olive oil']\n"
            f"- Adjust ingredient amounts based on serving size and nutritional targets\n\n"
            f"SEASONINGS REQUIREMENTS (MANDATORY):\n"
            f"- EVERY meal MUST include seasonings with exact measurements using WORLD-STANDARD units\n"
            f"- Use INTERNATIONAL units: grams (g), milliliters (ml), pinches - NOT teaspoons/tablespoons\n"
            f"- Use precise portions: '2g salt', '1g black pepper', '3g dried oregano', '10ml olive oil'\n"
            f"- Common seasoning portions: salt (1-3g), pepper (0.5-1g), herbs/spices (2-5g), oils (5-15ml)\n"
            f"- Example seasonings array: ['2g salt', '1g black pepper', '3g dried oregano', '2g garlic powder']\n"
            f"- Adjust seasoning amounts based on serving size and meal type\n\n"
            f"NUTRITION TARGETS:\n"
            f"- Each day must total EXACTLY {nutrition_targets.calories} calories, {nutrition_targets.protein}g protein, {nutrition_targets.carbs}g carbs, {nutrition_targets.fat}g fat\n"
            f"- Each meal must match its target nutrition values above\n"
            f"- Keep meal descriptions under 20 words\n"
            f"- Keep instructions to 3 steps maximum{snack_requirement}\n\n"
            f"CRITICAL: Return ONLY valid JSON in this exact format:\n{schema}\n\n"
            f"Generate all 7 days with precise nutrition matching the targets above. CRITICAL: EVERY SINGLE ingredient and seasoning MUST have exact portions using WORLD-STANDARD units (grams, milliliters). FORBIDDEN: Ingredients like 'Mixed greens', 'Cherry tomatoes', 'Cucumber' without portions. REQUIRED: '100g mixed greens', '150g cherry tomatoes', '100g diced cucumber'!"
        )
        
        return prompt, "You are a meal planning assistant. Return only valid JSON without any markdown formatting or explanations."
    
    def _generate_daily_ingredient_prompt(self, context: PromptContext) -> tuple[str, str]:
        """Generate daily ingredient-based meal plan prompt."""
        meals_per_day = len(context.generation_context.meal_types)
        
        # Create schema for daily meal plan with portions and seasonings
        schema = (
            '{\\n'
            '  "meals": [\\n'
            '    {\\n'
            '      "meal_type": "breakfast",\\n'
            '      "name": "Meal Name",\\n'
            '      "description": "Brief description",\\n'
            '      "calories": 400,\\n'
            '      "protein": 25.0,\\n'
            '      "carbs": 45.0,\\n'
            '      "fat": 15.0,\\n'
            '      "prep_time": 10,\\n'
            '      "cook_time": 15,\\n'
            '      "ingredients": ["300g brown rice", "450g chicken breast", "100g mixed greens", "150g cherry tomatoes", "15ml olive oil"],\\n'
            '      "seasonings": ["2g salt", "1g black pepper", "3g dried oregano"],\\n'
            '      "instructions": ["step1", "step2"],\\n'
            '      "is_vegetarian": true,\\n'
            '      "is_vegan": false,\\n'
            '      "is_gluten_free": false,\\n'
            '      "cuisine_type": "International"\\n'
            '    }\\n'
            '  ]\\n'
            '}'
        )
        
        snack_requirement = ""
        if context.generation_context.request.user_profile.include_snacks:
            snack_requirement = "\\n6. Include 1 healthy snack for the day."
        
        # Build detailed nutritional targets
        nutrition_targets = context.generation_context.request.nutrition_targets
        daily_targets = (
            f"DAILY NUTRITION TARGETS (must be met exactly):\\n"
            f"- Calories: {nutrition_targets.calories}\\n"
            f"- Protein: {nutrition_targets.protein}g\\n"
            f"- Carbs: {nutrition_targets.carbs}g\\n"
            f"- Fat: {nutrition_targets.fat}g\\n"
        )
        
        # Build meal-specific targets
        meal_targets = []
        for meal_type in context.generation_context.meal_types:
            calorie_target = context.generation_context.calorie_distribution.get_calories_for_meal(meal_type)
            meal_percentage = calorie_target / nutrition_targets.calories
            protein_target = nutrition_targets.protein * meal_percentage
            carbs_target = nutrition_targets.carbs * meal_percentage
            fat_target = nutrition_targets.fat * meal_percentage
            
            meal_targets.append(
                f"- {meal_type.value.title()}: {calorie_target} cal, {protein_target:.1f}g protein, {carbs_target:.1f}g carbs, {fat_target:.1f}g fat"
            )
        
        meal_targets_text = "MEAL TARGETS FOR TODAY:\\n" + "\\n".join(meal_targets)
        
        prompt = (
            f"Generate a daily meal plan using ONLY these ingredients.\\n\\n"
            f"Available Ingredients: {context.get_ingredients_text()}\\n"
            f"Available Seasonings: {context.get_seasonings_text()}{context.get_dietary_requirements_text()}\\n\\n"
            f"{daily_targets}\\n"
            f"{meal_targets_text}\\n\\n"
            f"CRITICAL REQUIREMENTS:\\n"
            f"- Generate exactly {meals_per_day} meals: {context.get_meal_types_text()}\\n"
            f"- Use ONLY the listed ingredients and seasonings above\\n\\n"
            f"INGREDIENT REQUIREMENTS (MANDATORY):\\n"
            f"- EVERY SINGLE ingredient MUST include exact measurements and portions - NO EXCEPTIONS\\n"
            f"- FORBIDDEN: Any ingredient without a specific amount (e.g., 'Mixed greens', 'Cherry tomatoes', 'Cucumber')\\n"
            f"- REQUIRED: ALL ingredients with precise portions using WORLD-STANDARD units (grams, milliliters, pieces)\\n"
            f"- Use INTERNATIONAL units: grams (g), milliliters (ml), pieces, slices, cloves - NOT region-specific cups/pounds/ounces\\n"
            f"- Use precise portions: '300g brown rice', '450g chicken breast', '250g salmon fillet', '200g quinoa'\\n"
            f"- ALL vegetables MUST have portions: '100g mixed greens', '150g cherry tomatoes', '100g diced cucumber', '50g sliced avocado'\\n"
            f"- Common ingredient portions: proteins (400-600g), grains/starches (200-400g), vegetables (100-300g), oils (15-30ml)\\n"
            f"- Example ingredients array: ['450g chicken breast', '300g brown rice', '150g broccoli florets', '15ml olive oil']\\n"
            f"- Adjust ingredient amounts based on serving size and nutritional targets\\n\\n"
            f"SEASONINGS REQUIREMENTS (MANDATORY):\\n"
            f"- EVERY meal MUST include seasonings with exact measurements using WORLD-STANDARD units\\n"
            f"- Use INTERNATIONAL units: grams (g), milliliters (ml), pinches - NOT teaspoons/tablespoons\\n"
            f"- Use precise portions: '2g salt', '1g black pepper', '3g dried oregano', '10ml olive oil'\\n"
            f"- Common seasoning portions: salt (1-3g), pepper (0.5-1g), herbs/spices (2-5g), oils (5-15ml)\\n"
            f"- Example seasonings array: ['2g salt', '1g black pepper', '3g dried oregano', '2g garlic powder']\\n"
            f"- Adjust seasoning amounts based on serving size and meal type\\n\\n"
            f"NUTRITION TARGETS:\\n"
            f"- All meals must total EXACTLY {nutrition_targets.calories} calories, {nutrition_targets.protein}g protein, {nutrition_targets.carbs}g carbs, {nutrition_targets.fat}g fat\\n"
            f"- Each meal must match its target nutrition values above\\n"
            f"- Keep meal descriptions under 20 words\\n"
            f"- Keep instructions to 3 steps maximum{snack_requirement}\\n\\n"
            f"CRITICAL: Return ONLY valid JSON in this exact format:\\n{schema}\\n\\n"
            f"Generate all meals with precise nutrition matching the targets above. CRITICAL: EVERY SINGLE ingredient and seasoning MUST have exact portions using WORLD-STANDARD units (grams, milliliters). FORBIDDEN: Ingredients like 'Mixed greens', 'Cherry tomatoes', 'Cucumber' without portions. REQUIRED: '100g mixed greens', '150g cherry tomatoes', '100g diced cucumber'!"
        )
        
        return prompt, "You are a meal planning assistant. Return only valid JSON without any markdown formatting or explanations."
    
    def _generate_daily_profile_prompt(self, context: PromptContext) -> tuple[str, str]:
        """Generate daily profile-based meal plan prompt."""
        # Build meal targets string
        meal_targets = []
        for meal_type in context.generation_context.meal_types:
            calorie_target = context.generation_context.calorie_distribution.get_calories_for_meal(meal_type)
            meal_percentage = calorie_target / context.generation_context.request.nutrition_targets.calories
            
            # Calculate macro targets for this meal
            protein_target = context.generation_context.request.nutrition_targets.protein * meal_percentage
            carbs_target = context.generation_context.request.nutrition_targets.carbs * meal_percentage
            fat_target = context.generation_context.request.nutrition_targets.fat * meal_percentage
            
            meal_targets.append(f"""
{meal_type.value.title()}:
- Calories: {int(calorie_target)} (±50 calories)
- Protein: {int(protein_target)}g
- Carbs: {int(carbs_target)}g
- Fat: {int(fat_target)}g""")
        
        meal_targets_str = "\n".join(meal_targets)
        
        profile = context.generation_context.request.user_profile
        dietary_str = ", ".join(profile.dietary_preferences) if profile.dietary_preferences else "none"
        health_str = ", ".join(profile.health_conditions) if profile.health_conditions else "none"
        
        prompt = f"""Generate a complete daily meal plan with these requirements:

User Profile:
- Fitness Goal: {profile.fitness_goal} - {context.get_goal_guidance()}
- Activity Level: {profile.activity_level}
- Dietary Restrictions: {dietary_str}
- Health Conditions: {health_str}
- Total Daily Calories: {context.generation_context.request.nutrition_targets.calories}

Nutritional Targets for each meal:
{meal_targets_str}

Requirements:
1. All meals should be practical and use common ingredients
2. Cooking times should be reasonable for each meal type
3. Must respect all dietary restrictions across all meals
4. Should support the user's fitness goal
5. Include variety and flavor across the day
6. Ensure meals complement each other for a balanced day

Return ONLY a JSON object with this structure:
{{
    "meals": [
        {{
            "meal_type": "breakfast",
            "name": "Meal name",
            "description": "Brief appealing description",
            "prep_time": 10,
            "cook_time": 20,
            "calories": 500,
            "protein": 25,
            "carbs": 60,
            "fat": 15,
            "ingredients": ["ingredient 1 with amount", "ingredient 2 with amount"],
            "instructions": ["Step 1", "Step 2"],
            "is_vegetarian": true/false,
            "is_vegan": true/false,
            "is_gluten_free": true/false,
            "cuisine_type": "cuisine type"
        }},
        // ... repeat for each meal type
    ]
}}"""
        
        return prompt, "You are a professional nutritionist creating personalized daily meal plans."
    
    def _generate_single_ingredient_meal_prompt(self, meal_type: MealType, calorie_target: int, context: PromptContext) -> tuple[str, str]:
        """Generate prompt for a single ingredient-based meal."""
        prompt = f"""Create a {meal_type.value} recipe using these available ingredients: {context.get_ingredients_text()}
Available seasonings: {context.get_seasonings_text()}
Target calories: {calorie_target}

IMPORTANT: Only use the ingredients and seasonings listed above. Do not add any other ingredients.
{context.get_dietary_requirements_text()}{context.get_allergy_restrictions_text()}

Create a simple, practical recipe that:
- Uses ONLY the available ingredients and seasonings listed above

INGREDIENT REQUIREMENTS (MANDATORY):
- EVERY SINGLE ingredient MUST include exact measurements and portions - NO EXCEPTIONS
- FORBIDDEN: Any ingredient without a specific amount (e.g., 'Mixed greens', 'Cherry tomatoes', 'Cucumber')
- REQUIRED: ALL ingredients with precise portions using WORLD-STANDARD units (grams, milliliters, pieces)
- Use INTERNATIONAL units: grams (g), milliliters (ml), pieces, slices, cloves - NOT region-specific cups/pounds/ounces
- Use precise portions: '300g brown rice', '450g chicken breast', '250g salmon fillet', '200g quinoa'
- ALL vegetables MUST have portions: '100g mixed greens', '150g cherry tomatoes', '100g diced cucumber', '50g sliced avocado'
- Common ingredient portions: proteins (400-600g), grains/starches (200-400g), vegetables (100-300g), oils (15-30ml)
- Example ingredients array: ['450g chicken breast', '300g brown rice', '150g broccoli florets', '15ml olive oil']

SEASONINGS REQUIREMENTS (MANDATORY):
- MUST include seasonings with exact measurements using WORLD-STANDARD units in separate array
- Use INTERNATIONAL units: grams (g), milliliters (ml), pinches - NOT teaspoons/tablespoons
- Use precise portions: '2g salt', '1g black pepper', '3g dried oregano', '10ml olive oil'
- Common seasoning portions: salt (1-3g), pepper (0.5-1g), herbs/spices (2-5g), oils (5-15ml)
- Seasonings array cannot be empty

Additional requirements:
- Creates a balanced and nutritious {meal_type.value}
- Is easy to prepare
- CRITICAL: NEVER use any ingredients that match the allergies listed above

Respond with valid JSON only:
{{
    "name": "Recipe Name",
    "description": "Brief description",
    "calories": {calorie_target},
    "protein": 25.0,
    "carbs": 35.0,
    "fat": 15.0,
    "prep_time": 15,
    "cook_time": 20,
    "ingredients": ["300g brown rice", "450g chicken breast", "100g mixed greens", "150g cherry tomatoes", "15ml olive oil"],
    "seasonings": ["2g salt", "1g black pepper", "3g dried oregano"],
    "instructions": ["step 1", "step 2"],
    "is_vegetarian": false,
    "is_vegan": false,
    "is_gluten_free": true,
    "cuisine_type": "International"
}}"""
        
        return prompt, "You are a professional nutritionist creating personalized meal suggestions."
    
    def _generate_single_profile_meal_prompt(self, meal_type: MealType, calorie_target: int, context: PromptContext) -> tuple[str, str]:
        """Generate prompt for a single profile-based meal."""
        profile = context.generation_context.request.user_profile
        
        # Calculate macro targets for this meal
        meal_percentage = calorie_target / context.generation_context.request.nutrition_targets.calories
        protein_target = context.generation_context.request.nutrition_targets.protein * meal_percentage
        carbs_target = context.generation_context.request.nutrition_targets.carbs * meal_percentage
        fat_target = context.generation_context.request.nutrition_targets.fat * meal_percentage
        
        dietary_str = ", ".join(profile.dietary_preferences) if profile.dietary_preferences else "none"
        health_str = ", ".join(profile.health_conditions) if profile.health_conditions else "none"
        
        prompt = f"""Generate a {meal_type.value} meal suggestion with these requirements:

User Profile:
- Fitness Goal: {profile.fitness_goal} - {context.get_goal_guidance()}
- Activity Level: {profile.activity_level}
- Dietary Restrictions: {dietary_str}
- Health Conditions: {health_str}

Nutritional Targets for this meal:
- Calories: {int(calorie_target)} (±50 calories)
- Protein: {int(protein_target)}g
- Carbs: {int(carbs_target)}g
- Fat: {int(fat_target)}g

Requirements:
1. The meal should be practical and use common ingredients
2. Cooking time should be reasonable for {meal_type.value}
3. Must respect all dietary restrictions
4. Should support the user's fitness goal
5. Include variety and flavor

Return ONLY a JSON object with this structure:
{{
    "name": "Meal name",
    "description": "Brief appealing description",
    "prep_time": 10,
    "cook_time": 20,
    "calories": {int(calorie_target)},
    "protein": {int(protein_target)},
    "carbs": {int(carbs_target)},
    "fat": {int(fat_target)},
    "ingredients": ["ingredient 1 with amount", "ingredient 2 with amount"],
    "instructions": ["Step 1", "Step 2"],
    "is_vegetarian": true/false,
    "is_vegan": true/false,
    "is_gluten_free": true/false,
    "cuisine_type": "cuisine type"
}}"""
        
        return prompt, "You are a professional nutritionist creating personalized meal suggestions."
</file>

<file path="src/domain/services/timezone_utils.py">
"""Timezone utilities for notification scheduling."""
import logging
from datetime import datetime
from zoneinfo import ZoneInfo, ZoneInfoNotFoundError

logger = logging.getLogger(__name__)

# Default timezone
DEFAULT_TIMEZONE = "UTC"

# Default quiet hours (for water reminders)
DEFAULT_SLEEP_TIME_MINUTES = 1320  # 10:00 PM
DEFAULT_BREAKFAST_TIME_MINUTES = 480  # 8:00 AM


def get_zone_info(timezone_str: str) -> ZoneInfo:
    """
    Get ZoneInfo for timezone string with fallback to UTC.

    Args:
        timezone_str: IANA timezone identifier (e.g., "America/Los_Angeles")

    Returns:
        ZoneInfo object, defaults to UTC if timezone invalid
    """
    if not timezone_str:
        return ZoneInfo(DEFAULT_TIMEZONE)

    try:
        return ZoneInfo(timezone_str)
    except ZoneInfoNotFoundError:
        logger.warning(f"Invalid timezone '{timezone_str}', falling back to UTC")
        return ZoneInfo(DEFAULT_TIMEZONE)


def utc_to_local_minutes(utc_time: datetime, timezone_str: str) -> int:
    """
    Convert UTC datetime to local time minutes from midnight.

    Args:
        utc_time: UTC datetime (must be timezone-aware)
        timezone_str: IANA timezone identifier

    Returns:
        Minutes from midnight in user's local time (0-1439)
    """
    zone_info = get_zone_info(timezone_str)
    local_time = utc_time.astimezone(zone_info)
    return local_time.hour * 60 + local_time.minute


def is_valid_timezone(timezone_str: str) -> bool:
    """
    Check if timezone string is valid IANA identifier.

    Args:
        timezone_str: Timezone string to validate

    Returns:
        True if valid IANA timezone
    """
    if not timezone_str:
        return False

    try:
        ZoneInfo(timezone_str)
        return True
    except ZoneInfoNotFoundError:
        return False


def is_in_quiet_hours(
    local_minutes: int,
    quiet_start: int | None,
    quiet_end: int | None
) -> bool:
    """
    Check if local_minutes falls within quiet hours window.

    Handles midnight crossing (quiet_start > quiet_end).
    Uses defaults if values are None.

    Args:
        local_minutes: Current local time in minutes (0-1439)
        quiet_start: Quiet hours start (sleep time) in minutes, or None
        quiet_end: Quiet hours end (breakfast time) in minutes, or None

    Returns:
        True if in quiet hours, False otherwise
    """
    start = quiet_start if quiet_start is not None else DEFAULT_SLEEP_TIME_MINUTES
    end = quiet_end if quiet_end is not None else DEFAULT_BREAKFAST_TIME_MINUTES

    if start > end:
        # Crosses midnight: e.g., 22:00 to 08:00
        return local_minutes >= start or local_minutes < end
    else:
        # Same day: e.g., 01:00 to 05:00
        return start <= local_minutes < end
</file>

<file path="src/domain/strategies/meal_analysis_strategy.py">
import logging
from abc import ABC, abstractmethod
from typing import Dict, Any, List, Optional

logger = logging.getLogger(__name__)

class MealAnalysisStrategy(ABC):
    """
    Abstract base class for meal analysis strategies.
    
    This implements the Strategy pattern for different types of context-aware
    meal analysis (basic, portion-aware, ingredient-aware, etc.)
    """
    
    @abstractmethod
    def get_analysis_prompt(self) -> str:
        """
        Get the system prompt for this analysis strategy.
        
        Returns:
            str: The system prompt text
        """
        pass
    
    @abstractmethod
    def get_user_message(self) -> str:
        """
        Get the user message for this analysis strategy.
        
        Returns:
            str: The user message text with context
        """
        pass
    
    @abstractmethod
    def get_strategy_name(self) -> str:
        """
        Get the name of this strategy for logging.
        
        Returns:
            str: Strategy name
        """
        pass

class BasicAnalysisStrategy(MealAnalysisStrategy):
    """
    Basic meal analysis strategy without additional context.
    """
    
    def get_analysis_prompt(self) -> str:
        return """
        You are a nutrition analysis assistant that can analyze food in images.
        Examine the image carefully and provide detailed nutritional information.
        
        Return your analysis in the following JSON format:
        {
          "dish_name": "Overall dish name or comma-separated food items if complex",
          "foods": [
            {
              "name": "Food name",
              "quantity": 1.0,
              "unit": "serving/g/oz/cup/etc",
              "calories": 100,
              "macros": {
                "protein": 10,
                "carbs": 20,
                "fat": 5,
              }
            }
          ],
          "total_calories": 100,
          "confidence": 0.8
        }
        
        - Include a dish_name field with the overall dish name (e.g., "Chicken Caesar Salad", "Spaghetti Bolognese")
        - If the foods are difficult to describe as a single dish, list them as comma-separated items (e.g., "grilled chicken, rice, broccoli")
        - Each food item should include name, estimated quantity, unit of measurement, calories, and macros
        - For quantities, estimate as precisely as possible based on visual cues
        - All macros should be in grams
        - Confidence should be between 0 (low) and 1 (high) based on how certain you are of your analysis
        - Always return well-formed JSON
        """
    
    def get_user_message(self) -> str:
        return "Analyze this food image and provide nutritional information:"
    
    def get_strategy_name(self) -> str:
        return "BasicAnalysis"

class PortionAwareAnalysisStrategy(MealAnalysisStrategy):
    """
    Portion-aware meal analysis strategy.
    """
    
    def __init__(self, portion_size: float, unit: str):
        self.portion_size = portion_size
        self.unit = unit
        logger.info(f"Created PortionAwareAnalysisStrategy: {portion_size} {unit}")
    
    def get_analysis_prompt(self) -> str:
        return """
        You are a nutrition analysis assistant that can analyze food in images with portion awareness.
        Examine the image carefully and provide detailed nutritional information adjusted for the specified portion size.
        
        IMPORTANT: The user has specified a target portion size. Please adjust your calculations accordingly.
        
        Return your analysis in the following JSON format:
        {
          "dish_name": "Overall dish name or comma-separated food items if complex",
          "foods": [
            {
              "name": "Food name",
              "quantity": 1.0,
              "unit": "serving/g/oz/cup/etc",
              "calories": 100,
              "macros": {
                "protein": 10,
                "carbs": 20,
                "fat": 5,
              }
            }
          ],
          "total_calories": 100,
          "confidence": 0.8,
          "portion_adjustment": "Adjusted for specified portion size"
        }
        
        - Include a dish_name field with the overall dish name (e.g., "Chicken Caesar Salad", "Spaghetti Bolognese")
        - If the foods are difficult to describe as a single dish, list them as comma-separated items (e.g., "grilled chicken, rice, broccoli")
        - Each food item should reflect the specified portion size
        - Calculate nutrition values proportionally to match the target portion
        - All macros should be in grams
        - Confidence should be between 0 (low) and 1 (high)
        - Include portion_adjustment field to indicate scaling was applied
        - Always return well-formed JSON
        """
    
    def get_user_message(self) -> str:
        return f"""Analyze this food image and provide nutritional information.

PORTION CONTEXT: The user has specified that this portion should be approximately {self.portion_size} {self.unit}. 
Please adjust your nutritional calculations accordingly to match this target portion size.

Consider the visual portion size in the image and scale the nutrition values to match the specified {self.portion_size} {self.unit}."""
    
    def get_strategy_name(self) -> str:
        return f"PortionAware({self.portion_size}{self.unit})"

class IngredientAwareAnalysisStrategy(MealAnalysisStrategy):
    """
    Ingredient-aware meal analysis strategy.
    """
    
    def __init__(self, ingredients: List[Dict[str, Any]]):
        self.ingredients = ingredients
        logger.info(f"Created IngredientAwareAnalysisStrategy with {len(ingredients)} ingredients")
    
    def get_analysis_prompt(self) -> str:
        return """
        You are a nutrition analysis assistant that can analyze food in images with ingredient awareness.
        Examine the image carefully and provide detailed nutritional information considering the known ingredients.
        
        IMPORTANT: The user has provided a list of ingredients in this meal. Please use this information to enhance your analysis.
        
        Return your analysis in the following JSON format:
        {
          "dish_name": "Overall dish name or comma-separated food items if complex",
          "foods": [
            {
              "name": "Food name",
              "quantity": 1.0,
              "unit": "serving/g/oz/cup/etc",
              "calories": 100,
              "macros": {
                "protein": 10,
                "carbs": 20,
                "fat": 5,
              }
            }
          ],
          "total_calories": 100,
          "confidence": 0.9,
          "ingredient_based": true,
          "combined_nutrition": "Calculated based on provided ingredients"
        }
        
        - Include a dish_name field with the overall dish name (e.g., "Chicken Caesar Salad", "Spaghetti Bolognese")
        - If the foods are difficult to describe as a single dish, list them as comma-separated items (e.g., "grilled chicken, rice, broccoli")
        - Use the provided ingredient list to improve accuracy
        - Calculate total nutrition considering all ingredients combined
        - Account for cooking methods and ingredient interactions
        - Higher confidence scores are appropriate when ingredients are known
        - Include ingredient_based field to indicate enhanced analysis
        - Always return well-formed JSON
        """
    
    def get_user_message(self) -> str:
        # Format ingredients list
        ingredient_lines = []
        for ing in self.ingredients:
            line = f"- {ing['name']}: {ing['quantity']} {ing['unit']}"
            if ing.get('calories'):
                line += f" ({ing['calories']} calories)"
            if ing.get('macros'):
                macros = ing['macros']
                line += f" [P:{macros.get('protein', 0)}g, C:{macros.get('carbs', 0)}g, F:{macros.get('fat', 0)}g]"
            ingredient_lines.append(line)
        
        ingredients_text = "\n".join(ingredient_lines)
        
        return f"""Analyze this food image and provide nutritional information.

INGREDIENT CONTEXT: The user has specified that this meal contains the following ingredients:
{ingredients_text}

Please calculate the total nutritional content considering all these ingredients together. 
Use this ingredient information to enhance the accuracy of your analysis and provide more precise nutrition calculations.
Account for how these ingredients combine and any cooking methods that might affect the nutritional values."""
    
    def get_strategy_name(self) -> str:
        return f"IngredientAware({len(self.ingredients)}ingredients)"

class WeightAwareAnalysisStrategy(MealAnalysisStrategy):
    """
    Weight-aware meal analysis strategy.
    """
    
    def __init__(self, weight_grams: float):
        self.weight_grams = weight_grams
        logger.info(f"Created WeightAwareAnalysisStrategy: {weight_grams}g")
    
    def get_analysis_prompt(self) -> str:
        return """
        You are a nutrition analysis assistant that can analyze food in images with weight awareness.
        Examine the image carefully and provide detailed nutritional information adjusted for the specified total weight.
        
        IMPORTANT: The user has specified a target total weight for this meal. Please adjust your calculations accordingly.
        
        Return your analysis in the following JSON format:
        {
          "dish_name": "Overall dish name or comma-separated food items if complex",
          "foods": [
            {
              "name": "Food name",
              "quantity": 1.0,
              "unit": "g",
              "calories": 100,
              "macros": {
                "protein": 10,
                "carbs": 20,
                "fat": 5,
              }
            }
          ],
          "total_calories": 100,
          "confidence": 0.85,
          "weight_adjustment": "Adjusted for specified total weight",
          "total_weight_grams": 300
        }
        
        - Include a dish_name field with the overall dish name (e.g., "Chicken Caesar Salad", "Spaghetti Bolognese")
        - If the foods are difficult to describe as a single dish, list them as comma-separated items (e.g., "grilled chicken, rice, broccoli")
        - Each food item should reflect proportions that add up to the target total weight
        - Calculate nutrition values to match the specified total weight
        - Use grams as the primary unit for quantities
        - All macros should be in grams
        - Higher confidence scores are appropriate with weight context
        - Include weight_adjustment and total_weight_grams fields
        - Always return well-formed JSON
        """
    
    def get_user_message(self) -> str:
        return f"""Analyze this food image and provide nutritional information.

WEIGHT CONTEXT: The user has specified that this meal should have a total weight of {self.weight_grams} grams.

Please examine the visual portions in the image and calculate nutritional values that correspond to this total weight of {self.weight_grams}g.
Adjust your analysis to ensure the combined weight of all food items matches the target weight as closely as possible."""
    
    def get_strategy_name(self) -> str:
        return f"WeightAware({self.weight_grams}g)"


class IngredientIdentificationStrategy(MealAnalysisStrategy):
    """
    Strategy for identifying a single ingredient from an image.

    Used when user takes a photo of an unknown food/ingredient and wants
    to identify it before getting meal suggestions.
    """

    def get_analysis_prompt(self) -> str:
        return """
        You are a food ingredient identification assistant.
        Identify the single food ingredient shown in this image.

        Return your analysis in the following JSON format:
        {
          "name": "ingredient name in English",
          "confidence": 0.95,
          "category": "vegetable|fruit|protein|grain|dairy|seasoning|other"
        }

        Guidelines:
        - Identify the PRIMARY/LARGEST ingredient if multiple are visible
        - Name should be in English, lowercase (e.g., "chicken breast", "broccoli", "salmon fillet")
        - Confidence between 0 (unsure) and 1 (certain)
        - Category must be one of: vegetable, fruit, protein, grain, dairy, seasoning, other
        - If no clear ingredient visible, return {"name": null, "confidence": 0, "category": null}
        - Always return well-formed JSON
        """

    def get_user_message(self) -> str:
        return "Identify the food ingredient in this image:"

    def get_strategy_name(self) -> str:
        return "IngredientIdentification"


class AnalysisStrategyFactory:
    """
    Factory class for creating meal analysis strategies.
    """
    
    @staticmethod
    def create_basic_strategy() -> MealAnalysisStrategy:
        """Create a basic analysis strategy."""
        return BasicAnalysisStrategy()
    
    @staticmethod
    def create_portion_strategy(portion_size: float, unit: str) -> MealAnalysisStrategy:
        """Create a portion-aware analysis strategy."""
        return PortionAwareAnalysisStrategy(portion_size, unit)
    
    @staticmethod
    def create_ingredient_strategy(ingredients: List[Dict[str, Any]]) -> MealAnalysisStrategy:
        """Create an ingredient-aware analysis strategy."""
        return IngredientAwareAnalysisStrategy(ingredients)
    
    @staticmethod
    def create_weight_strategy(weight_grams: float) -> MealAnalysisStrategy:
        """Create a weight-aware analysis strategy."""
        return WeightAwareAnalysisStrategy(weight_grams)

    @staticmethod
    def create_ingredient_identification_strategy() -> MealAnalysisStrategy:
        """Create an ingredient identification strategy for photo recognition."""
        return IngredientIdentificationStrategy()

    @staticmethod
    def create_combined_strategy(
        portion_size: Optional[float] = None, 
        unit: Optional[str] = None,
        ingredients: Optional[List[Dict[str, Any]]] = None
    ) -> MealAnalysisStrategy:
        """
        Create a combined strategy with both portion and ingredient context.
        
        Args:
            portion_size: Target portion size (optional)
            unit: Unit of portion size (optional)
            ingredients: List of ingredients (optional)
            
        Returns:
            MealAnalysisStrategy: Appropriate strategy based on provided context
        """
        if portion_size and unit and ingredients:
            # TODO: Implement CombinedAnalysisStrategy for future use
            logger.info("Combined strategy requested - using ingredient strategy for now")
            return IngredientAwareAnalysisStrategy(ingredients)
        elif portion_size and unit:
            return PortionAwareAnalysisStrategy(portion_size, unit)
        elif ingredients:
            return IngredientAwareAnalysisStrategy(ingredients)
        else:
            return BasicAnalysisStrategy()
</file>

<file path="src/domain/strategies/meal_edit_strategies.py">
"""
Strategy pattern for handling different food item change actions.
Each strategy encapsulates the logic for add, update, or remove operations.
"""
import logging
import uuid
from abc import ABC, abstractmethod
from typing import Dict

from src.app.commands.meal import FoodItemChange
from src.domain.model.nutrition import FoodItem
from src.domain.model.nutrition import Macros
from src.domain.services import NutritionCalculationService

logger = logging.getLogger(__name__)


class FoodItemChangeStrategy(ABC):
    """Base strategy for applying food item changes."""

    def __init__(self, nutrition_service: NutritionCalculationService):
        self.nutrition_service = nutrition_service

    @abstractmethod
    async def apply(
        self,
        food_items_dict: Dict[str, FoodItem],
        change: FoodItemChange
    ) -> None:
        """
        Apply the change to the food items dictionary.

        Args:
            food_items_dict: Dictionary of food items (id -> FoodItem)
            change: The change to apply
        """
        pass


class RemoveFoodItemStrategy(FoodItemChangeStrategy):
    """Strategy for removing a food item."""

    async def apply(
        self,
        food_items_dict: Dict[str, FoodItem],
        change: FoodItemChange
    ) -> None:
        """Remove food item from dictionary."""
        if not change.id:
            logger.warning("Remove action requires id")
            return

        food_items_dict.pop(change.id, None)
        logger.info(f"Removed food item: {change.id}")


class UpdateFoodItemStrategy(FoodItemChangeStrategy):
    """Strategy for updating an existing food item."""

    async def apply(
        self,
        food_items_dict: Dict[str, FoodItem],
        change: FoodItemChange
    ) -> None:
        """Update existing food item with new quantity/unit."""
        if not change.id or change.id not in food_items_dict:
            logger.warning(f"Update action requires valid id: {change.id}")
            return

        existing_item = food_items_dict[change.id]
        new_quantity = change.quantity or existing_item.quantity
        new_unit = change.unit or existing_item.unit

        # Check if unit changed - if so, fetch fresh nutrition data
        unit_changed = change.unit and change.unit != existing_item.unit

        if unit_changed:
            # Unit changed - fetch fresh nutrition data
            scaled_nutrition = self.nutrition_service.get_nutrition_for_ingredient(
                name=existing_item.name,
                quantity=new_quantity,
                unit=new_unit,
                fdc_id=existing_item.fdc_id
            )

            if scaled_nutrition:
                food_items_dict[change.id] = FoodItem(
                    id=existing_item.id,
                    name=existing_item.name,
                    quantity=new_quantity,
                    unit=new_unit,
                    calories=scaled_nutrition.calories,
                    macros=Macros(
                        protein=scaled_nutrition.protein,
                        carbs=scaled_nutrition.carbs,
                        fat=scaled_nutrition.fat
                    ),
                    micros=existing_item.micros,
                    confidence=0.9,
                    fdc_id=existing_item.fdc_id,
                    is_custom=existing_item.is_custom
                )
                logger.info(f"Updated food item with unit change: {existing_item.name}")
            else:
                # Fallback to simple scaling
                logger.warning(f"Could not fetch nutrition for unit change, using scaling")
                self._apply_simple_scaling(food_items_dict, change, existing_item, new_quantity, new_unit)
        else:
            # Same unit - just scale the nutrition
            self._apply_simple_scaling(food_items_dict, change, existing_item, new_quantity, new_unit)

    def _apply_simple_scaling(
        self,
        food_items_dict: Dict[str, FoodItem],
        change: FoodItemChange,
        existing_item: FoodItem,
        new_quantity: float,
        new_unit: str
    ) -> None:
        """Apply simple proportional scaling to nutrition."""
        scale_factor = new_quantity / existing_item.quantity

        food_items_dict[change.id] = FoodItem(
            id=existing_item.id,
            name=existing_item.name,
            quantity=new_quantity,
            unit=new_unit,
            calories=existing_item.calories * scale_factor,
            macros=Macros(
                protein=existing_item.macros.protein * scale_factor,
                carbs=existing_item.macros.carbs * scale_factor,
                fat=existing_item.macros.fat * scale_factor
            ),
            micros=existing_item.micros,
            confidence=existing_item.confidence,
            fdc_id=existing_item.fdc_id,
            is_custom=existing_item.is_custom
        )
        logger.info(f"Updated food item with scaling: {existing_item.name}")


class AddFoodItemStrategy(FoodItemChangeStrategy):
    """Strategy for adding a new food item."""

    def __init__(self, nutrition_service: NutritionCalculationService, food_service=None):
        super().__init__(nutrition_service)
        self.food_service = food_service

    async def apply(
        self,
        food_items_dict: Dict[str, FoodItem],
        change: FoodItemChange
    ) -> None:
        """Add new food item to dictionary."""
        new_item_id = str(uuid.uuid4())

        # Try to get nutrition from various sources
        quantity = change.quantity or 100
        unit = change.unit or "g"

        # Priority 1: Custom nutrition provided
        if change.custom_nutrition:
            food_item = self._create_from_custom_nutrition(
                new_item_id,
                change.name or "Custom Ingredient",
                quantity,
                unit,
                change.custom_nutrition
            )
            food_items_dict[new_item_id] = food_item
            logger.info(f"Added custom food item: {change.name}")
            return

        # Priority 2: Nutrition service (Pinecone/USDA)
        if change.name:
            scaled_nutrition = self.nutrition_service.get_nutrition_for_ingredient(
                name=change.name,
                quantity=quantity,
                unit=unit,
                fdc_id=change.fdc_id
            )

            if scaled_nutrition:
                food_items_dict[new_item_id] = FoodItem(
                    id=new_item_id,
                    name=change.name,
                    quantity=quantity,
                    unit=unit,
                    calories=scaled_nutrition.calories,
                    macros=Macros(
                        protein=scaled_nutrition.protein,
                        carbs=scaled_nutrition.carbs,
                        fat=scaled_nutrition.fat
                    ),
                    confidence=0.9,
                    fdc_id=change.fdc_id,
                    is_custom=False
                )
                logger.info(f"Added food item from nutrition service: {change.name}")
                return

        logger.warning(f"Could not find nutrition data for ingredient: {change.name}")

    def _create_from_custom_nutrition(
        self,
        item_id: str,
        name: str,
        quantity: float,
        unit: str,
        custom_nutrition
    ) -> FoodItem:
        """Create food item from custom nutrition data."""
        scale_factor = quantity / 100.0  # Custom nutrition is per 100g

        return FoodItem(
            id=item_id,
            name=name,
            quantity=quantity,
            unit=unit,
            calories=custom_nutrition.calories_per_100g * scale_factor,
            macros=Macros(
                protein=custom_nutrition.protein_per_100g * scale_factor,
                carbs=custom_nutrition.carbs_per_100g * scale_factor,
                fat=custom_nutrition.fat_per_100g * scale_factor
            ),
            confidence=0.8,
            fdc_id=None,
            is_custom=True
        )


class FoodItemChangeStrategyFactory:
    """Factory for creating appropriate strategy based on action."""

    @staticmethod
    def create_strategies(
        nutrition_service: NutritionCalculationService,
        food_service=None
    ) -> Dict[str, FoodItemChangeStrategy]:
        """Create all available strategies."""
        return {
            "add": AddFoodItemStrategy(nutrition_service, food_service),
            "update": UpdateFoodItemStrategy(nutrition_service),
            "remove": RemoveFoodItemStrategy(nutrition_service)
        }
</file>

<file path="src/infra/adapters/food_cache_service.py">
"""
Food cache service that uses Redis when available, with in-memory fallback.
"""
import time
from typing import Any, Dict, List, Optional

from src.domain.ports.food_cache_service_port import FoodCacheServicePort
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService


class FoodCacheService(FoodCacheServicePort):
    def __init__(self, cache_service: Optional[CacheService] = None):
        self.cache_service = cache_service
        self._search_cache: Dict[str, Any] = {}
        self._food_cache: Dict[int, Any] = {}

    async def get_cached_search(self, query: str) -> Optional[List[Dict[str, Any]]]:
        if self.cache_service:
            cache_key, _ = CacheKeys.food_search(query)
            return await self.cache_service.get_json(cache_key)

        entry = self._search_cache.get(query)
        if not entry or entry["ttl"] < time.time():
            self._search_cache.pop(query, None)
            return None
        return entry["data"]

    async def cache_search(self, query: str, results: List[Dict[str, Any]], ttl: int = 3600):
        if self.cache_service:
            cache_key, default_ttl = CacheKeys.food_search(query)
            await self.cache_service.set_json(cache_key, results, ttl or default_ttl)
            return

        self._search_cache[query] = {"ttl": time.time() + ttl, "data": results}

    async def get_cached_food(self, fdc_id: int) -> Optional[Dict[str, Any]]:
        if self.cache_service:
            cache_key, _ = CacheKeys.food_details(str(fdc_id))
            return await self.cache_service.get_json(cache_key)

        entry = self._food_cache.get(fdc_id)
        if not entry or entry["ttl"] < time.time():
            self._food_cache.pop(fdc_id, None)
            return None
        return entry["data"]

    async def cache_food(self, fdc_id: int, food_data: Dict[str, Any], ttl: int = 86400):
        if self.cache_service:
            cache_key, default_ttl = CacheKeys.food_details(str(fdc_id))
            await self.cache_service.set_json(cache_key, food_data, ttl or default_ttl)
            return

        self._food_cache[fdc_id] = {"ttl": time.time() + ttl, "data": food_data}
</file>

<file path="src/infra/adapters/mock_meal_suggestion_service.py">
"""
Mock Meal Suggestion Service for testing.
"""
import uuid
from typing import List, Dict, Any

from src.domain.model.meal_planning import MealType, PlannedMeal


class MockMealSuggestionService:
    """Mock implementation of meal suggestion service for testing."""
    
    def generate_suggestions(
        self,
        target_calories: float,
        dietary_preferences: List[str] = None,
        health_conditions: List[str] = None
    ) -> List[Dict[str, Any]]:
        """Generate mock meal suggestions."""
        # Calculate meal calories based on typical distribution
        breakfast_calories = target_calories * 0.25
        lunch_calories = target_calories * 0.35
        dinner_calories = target_calories * 0.30
        snack_calories = target_calories * 0.10
        
        suggestions = [
            {
                "meal_type": MealType.BREAKFAST.value,
                "dish_name": "Oatmeal with Berries and Nuts",
                "description": "Whole grain oats topped with fresh berries and almonds",
                "calories": breakfast_calories,
                "macros": {
                    "protein": breakfast_calories * 0.15 / 4,  # 15% from protein, 4 cal/g
                    "carbs": breakfast_calories * 0.60 / 4,    # 60% from carbs, 4 cal/g
                    "fat": breakfast_calories * 0.25 / 9,      # 25% from fat, 9 cal/g
                },
                "ingredients": [
                    "Rolled oats", "Blueberries", "Strawberries", 
                    "Almonds", "Honey", "Cinnamon"
                ],
                "prep_time_minutes": 10,
                "cooking_instructions": [
                    "Cook oats according to package directions",
                    "Top with fresh berries",
                    "Add sliced almonds and drizzle with honey",
                    "Sprinkle with cinnamon"
                ]
            },
            {
                "meal_type": MealType.LUNCH.value,
                "dish_name": "Grilled Chicken Salad",
                "description": "Mixed greens with grilled chicken breast and vegetables",
                "calories": lunch_calories,
                "macros": {
                    "protein": lunch_calories * 0.35 / 4,
                    "carbs": lunch_calories * 0.40 / 4,
                    "fat": lunch_calories * 0.25 / 9,
                    "": 12.0
                },
                "ingredients": [
                    "Chicken breast", "Mixed greens", "Cherry tomatoes",
                    "Cucumber", "Avocado", "Olive oil", "Lemon"
                ],
                "prep_time_minutes": 20,
                "cooking_instructions": [
                    "Season and grill chicken breast",
                    "Prepare salad with mixed greens and vegetables",
                    "Slice grilled chicken and place on salad",
                    "Dress with olive oil and lemon juice"
                ]
            },
            {
                "meal_type": MealType.DINNER.value,
                "dish_name": "Salmon with Quinoa and Vegetables",
                "description": "Baked salmon fillet with quinoa and roasted vegetables",
                "calories": dinner_calories,
                "macros": {
                    "protein": dinner_calories * 0.30 / 4,
                    "carbs": dinner_calories * 0.45 / 4,
                    "fat": dinner_calories * 0.25 / 9,
                },
                "ingredients": [
                    "Salmon fillet", "Quinoa", "Broccoli", "Carrots",
                    "Bell peppers", "Garlic", "Olive oil", "Herbs"
                ],
                "prep_time_minutes": 30,
                "cooking_instructions": [
                    "Preheat oven to 400°F",
                    "Season salmon and bake for 15-20 minutes",
                    "Cook quinoa according to package directions",
                    "Roast vegetables with olive oil and garlic",
                    "Serve salmon over quinoa with vegetables"
                ]
            },
            {
                "meal_type": MealType.SNACK.value,
                "dish_name": "Greek Yogurt with Nuts",
                "description": "Plain Greek yogurt topped with mixed nuts",
                "calories": snack_calories,
                "macros": {
                    "protein": snack_calories * 0.30 / 4,
                    "carbs": snack_calories * 0.40 / 4,
                    "fat": snack_calories * 0.30 / 9,
                },
                "ingredients": [
                    "Greek yogurt", "Walnuts", "Almonds", "Honey"
                ],
                "prep_time_minutes": 5,
                "cooking_instructions": [
                    "Spoon yogurt into bowl",
                    "Top with mixed nuts",
                    "Drizzle with honey if desired"
                ]
            }
        ]
        
        # Adjust suggestions based on dietary preferences
        if dietary_preferences:
            if "vegetarian" in dietary_preferences:
                # Replace chicken with tofu in lunch
                suggestions[1]["dish_name"] = "Tofu Salad"
                suggestions[1]["ingredients"][0] = "Tofu"
                # Replace salmon with lentils in dinner
                suggestions[2]["dish_name"] = "Lentil Curry with Quinoa"
                suggestions[2]["ingredients"][0] = "Red lentils"
        
        return suggestions
    
    def generate_daily_suggestions(self, user_data: Dict[str, Any]) -> List[PlannedMeal]:
        """Generate daily meal suggestions based on user data."""
        target_calories = user_data.get('target_calories')
        if not target_calories:
            raise ValueError("target_calories is required in user_data for mock service")
        dietary_preferences = user_data.get('dietary_preferences', [])
        
        # Get suggestions in dict format
        suggestions_data = self.generate_suggestions(
            target_calories,
            dietary_preferences,
            user_data.get('health_conditions', [])
        )
        
        # Convert to PlannedMeal objects
        planned_meals = []
        for suggestion in suggestions_data:
            meal = PlannedMeal(
                meal_id=str(uuid.uuid4()),
                meal_type=MealType(suggestion['meal_type']),
                name=suggestion['dish_name'],
                description=suggestion['description'],
                prep_time=suggestion['prep_time_minutes'],
                cook_time=suggestion['prep_time_minutes'],  # Using same as prep for mock
                calories=int(suggestion['calories']),
                protein=suggestion['macros']['protein'],
                carbs=suggestion['macros']['carbs'],
                fat=suggestion['macros']['fat'],
                ingredients=suggestion['ingredients'],
                instructions=suggestion['cooking_instructions'],
                is_vegetarian='vegetarian' in dietary_preferences,
                is_vegan='vegan' in dietary_preferences,
                is_gluten_free='gluten_free' in dietary_preferences,
                cuisine_type='American'
            )
            planned_meals.append(meal)
        
        return planned_meals
</file>

<file path="src/infra/adapters/vision_ai_service.py">
import base64
import json
import logging
import os
import re
from typing import Dict, Any, List

from dotenv import load_dotenv
from langchain_core.messages import HumanMessage, SystemMessage
from langchain_google_genai import ChatGoogleGenerativeAI

from src.domain.ports.vision_ai_service_port import VisionAIServicePort
from src.domain.strategies.meal_analysis_strategy import (
    MealAnalysisStrategy,
    AnalysisStrategyFactory
)

# Load environment variables
load_dotenv()

logger = logging.getLogger(__name__)

class VisionAIService(VisionAIServicePort):
    """
    Implementation of VisionAIServicePort using Google Gemini API.
    
    This class implements US-2.1 - Call Vision AI to get nutrition estimate.
    """
    
    def __init__(self):
        """Initialize the Gemini client."""
        self.api_key = os.getenv("GOOGLE_API_KEY")
        if not self.api_key:
            raise ValueError("GOOGLE_API_KEY environment variable is not set")
            
        self.model = ChatGoogleGenerativeAI(
            model=os.getenv("GEMINI_MODEL", "gemini-2.5-flash"),
            temperature=0.2,
            max_output_tokens=4096,
            google_api_key=self.api_key,
            convert_system_message_to_human=True
        )
        
    def analyze_with_strategy(self, image_bytes: bytes, strategy: MealAnalysisStrategy) -> Dict[str, Any]:
        """
        Analyze a food image using the provided analysis strategy.

        Args:
            image_bytes: The raw bytes of the image to analyze
            strategy: The analysis strategy to use

        Returns:
            JSON-compatible dictionary with the raw AI response

        Raises:
            RuntimeError: If analysis fails
        """
        try:
            # Encode image for the API
            image_base64 = base64.b64encode(image_bytes).decode('utf-8')

            # Create message with the image using strategy
            messages = [
                SystemMessage(content=strategy.get_analysis_prompt()),
                HumanMessage(
                    content=[
                        {"type": "text", "text": strategy.get_user_message()},
                        {"type": "image_url", "image_url": {"url": f"data:image/jpeg;base64,{image_base64}"}}
                    ]
                )
            ]

            # Call the API
            response = self.model.invoke(messages)

            # Parse the response to extract the JSON
            content = response.content

            # Validate response content is not empty
            if not content or (isinstance(content, str) and not content.strip()):
                # Check for safety blocking or other issues
                response_metadata = getattr(response, 'response_metadata', {})
                finish_reason = response_metadata.get('finish_reason', 'unknown')
                safety_ratings = response_metadata.get('safety_ratings', [])

                logger.warning(
                    f"Empty response from Gemini API. finish_reason={finish_reason}, "
                    f"safety_ratings={safety_ratings}"
                )

                if finish_reason == 'SAFETY':
                    raise ValueError(
                        "Image was blocked by AI safety filters. "
                        "Please try a different image of food."
                    )
                raise ValueError(
                    f"AI returned empty response (finish_reason: {finish_reason}). "
                    "The image may not be clear or recognizable as food."
                )

            # Extract JSON from the response
            result = self._extract_json_from_response(content)

            return {
                "raw_response": content,
                "structured_data": result,
                "strategy_used": strategy.get_strategy_name()
            }

        except Exception as e:
            raise RuntimeError(f"Failed to analyze image with {strategy.get_strategy_name()}: {str(e)}")

    def _extract_json_from_response(self, content: str) -> Dict[str, Any]:
        """
        Extract JSON from AI response, handling various formats.

        Args:
            content: The raw response string from the AI

        Returns:
            Parsed JSON as dictionary

        Raises:
            ValueError: If JSON cannot be extracted
        """
        # Try to parse the entire response as JSON
        try:
            return json.loads(content)
        except json.JSONDecodeError:
            pass

        # Try to find JSON in markdown code block (with closing ```)
        json_match = re.search(r'```(?:json)?\s*([\s\S]*?)```', content)
        if json_match:
            try:
                return json.loads(json_match.group(1).strip())
            except json.JSONDecodeError:
                pass

        # Try to find any complete JSON object
        json_match = re.search(r'\{[\s\S]*\}', content)
        if json_match:
            try:
                return json.loads(json_match.group(0))
            except json.JSONDecodeError:
                pass

        # Detect truncated response (has opening { but no closing })
        if '{' in content and '}' not in content:
            logger.error(f"Truncated JSON response detected: {content[:500]}")
            raise ValueError(
                "AI response was truncated. Please try again with a simpler image."
            )

        logger.error(f"Could not extract JSON from response: {content[:500]}")
        raise ValueError(
            "Could not extract JSON from AI response. "
            "Please try again or use a clearer image."
        )
        
    def analyze(self, image_bytes: bytes) -> Dict[str, Any]:
        """
        Analyze a food image to extract nutritional information.
        
        Args:
            image_bytes: The raw bytes of the image to analyze
            
        Returns:
            JSON-compatible dictionary with the raw AI response
            
        Raises:
            RuntimeError: If analysis fails
        """
        strategy = AnalysisStrategyFactory.create_basic_strategy()
        return self.analyze_with_strategy(image_bytes, strategy)
    
    def analyze_with_portion_context(self, image_bytes: bytes, portion_size: float, unit: str) -> Dict[str, Any]:
        """
        Analyze a food image with specific portion size context.
        
        Args:
            image_bytes: The raw bytes of the image to analyze
            portion_size: The target portion size
            unit: The unit of the portion size
            
        Returns:
            JSON-compatible dictionary with the raw AI response
        """
        strategy = AnalysisStrategyFactory.create_portion_strategy(portion_size, unit)
        return self.analyze_with_strategy(image_bytes, strategy)
    
    def analyze_with_ingredients_context(self, image_bytes: bytes, ingredients: List[Dict[str, Any]]) -> Dict[str, Any]:
        """
        Analyze a food image with known ingredients context.
        
        Args:
            image_bytes: The raw bytes of the image to analyze
            ingredients: List of ingredient dictionaries with name, quantity, unit
            
        Returns:
            JSON-compatible dictionary with the raw AI response
        """
        strategy = AnalysisStrategyFactory.create_ingredient_strategy(ingredients)
        return self.analyze_with_strategy(image_bytes, strategy)
    
    def analyze_with_weight_context(self, image_bytes: bytes, weight_grams: float) -> Dict[str, Any]:
        """
        Analyze a food image with specific weight context for accurate nutrition.
        
        Args:
            image_bytes: The raw bytes of the image to analyze
            weight_grams: The target weight in grams
            
        Returns:
            JSON-compatible dictionary with the raw AI response
        """
        strategy = AnalysisStrategyFactory.create_weight_strategy(weight_grams)
        return self.analyze_with_strategy(image_bytes, strategy)
</file>

<file path="src/infra/cache/__init__.py">
"""Redis-backed caching utilities."""
</file>

<file path="src/infra/cache/cache_keys.py">
"""
Shared cache key definitions and TTL helpers.
"""
from __future__ import annotations

from datetime import date


class CacheKeys:
    """Centralized cache key generator with TTL policies."""

    TTL_10_MIN = 600
    TTL_1_HOUR = 3600
    TTL_1_DAY = 86400
    TTL_7_DAYS = 604_800
    TTL_30_DAYS = 2_592_000

    @staticmethod
    def user_profile(user_id: str) -> tuple[str, int]:
        return (f"user:profile:{user_id}", CacheKeys.TTL_30_DAYS)

    @staticmethod
    def daily_macros(user_id: str, target_date: date) -> tuple[str, int]:
        return (
            f"user:{user_id}:macros:{target_date.isoformat()}",
            CacheKeys.TTL_1_DAY,
        )

    @staticmethod
    def food_search(query: str) -> tuple[str, int]:
        normalized = query.lower().strip()[:64]
        return (f"food:search:{normalized}", CacheKeys.TTL_7_DAYS)

    @staticmethod
    def food_details(food_id: str) -> tuple[str, int]:
        return (f"food:details:{food_id}", CacheKeys.TTL_7_DAYS)

    @staticmethod
    def feature_flag(flag_name: str) -> tuple[str, int]:
        return (f"feature:flag:{flag_name}", CacheKeys.TTL_10_MIN)

    @staticmethod
    def feature_flags() -> tuple[str, int]:
        return ("feature:flags:all", CacheKeys.TTL_10_MIN)

    @staticmethod
    def pattern_for_user(user_id: str) -> str:
        return f"user:{user_id}:*"
</file>

<file path="src/infra/cache/decorators.py">
"""
Cache decorators for wrapping async service calls.
"""
from __future__ import annotations

from functools import wraps
from typing import Awaitable, Callable, Optional

from src.infra.cache.cache_service import CacheService


def cached(
    key_func: Callable[..., str],
    ttl: Optional[int] = None,
):
    """
    Decorator to transparently cache async method results.

    The wrapped function must be an async method whose first argument is `self`
    and `self` must expose a `cache_service` attribute.
    """

    def decorator(func: Callable[..., Awaitable]):
        @wraps(func)
        async def wrapper(*args, **kwargs):
            self_obj = args[0]
            cache_service: CacheService = getattr(self_obj, "cache_service", None)

            if cache_service is None:
                return await func(*args, **kwargs)

            cache_key = key_func(*args, **kwargs)
            cached_value = await cache_service.get_json(cache_key)
            if cached_value is not None:
                return cached_value

            result = await func(*args, **kwargs)
            if result is not None:
                await cache_service.set_json(cache_key, result, ttl)
            return result

        return wrapper

    return decorator
</file>

<file path="src/infra/cache/metrics.py">
"""
Simple cache metrics collector.
"""
from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime
from typing import Dict


@dataclass
class CacheMetrics:
    hits: int = 0
    misses: int = 0
    errors: int = 0
    total_requests: int = 0

    @property
    def hit_rate(self) -> float:
        if self.total_requests == 0:
            return 0.0
        return (self.hits / self.total_requests) * 100


class CacheMonitor:
    """In-memory metrics tracker for cache activity."""

    def __init__(self):
        self.metrics = CacheMetrics()
        self.last_reset = datetime.utcnow()

    def record_hit(self) -> None:
        self.metrics.hits += 1
        self.metrics.total_requests += 1

    def record_miss(self) -> None:
        self.metrics.misses += 1
        self.metrics.total_requests += 1

    def record_error(self) -> None:
        self.metrics.errors += 1

    def snapshot(self) -> Dict[str, float | int | str]:
        return {
            "hits": self.metrics.hits,
            "misses": self.metrics.misses,
            "errors": self.metrics.errors,
            "total_requests": self.metrics.total_requests,
            "hit_rate": round(self.metrics.hit_rate, 2),
            "since": self.last_reset.isoformat(),
        }

    def reset(self) -> None:
        self.metrics = CacheMetrics()
        self.last_reset = datetime.utcnow()
</file>

<file path="src/infra/cache/redis_client.py">
"""
Async Redis client with connection pooling.
"""
from __future__ import annotations

import logging
from typing import Optional

import redis.asyncio as redis
from redis.exceptions import RedisError

logger = logging.getLogger(__name__)


class RedisClient:
    """Wrapper around redis.asyncio client that manages a shared pool."""

    def __init__(self, redis_url: str, max_connections: int = 50):
        self._redis_url = redis_url
        self.pool = redis.ConnectionPool.from_url(
            redis_url,
            max_connections=max_connections,
            decode_responses=True,
        )
        self.client: Optional[redis.Redis] = None

    async def connect(self) -> None:
        """Initialize the Redis connection."""
        if self.client is not None:
            return

        self.client = redis.Redis(connection_pool=self.pool)
        try:
            await self.client.ping()
            logger.info("Redis connected (%s)", self._redis_url)
        except RedisError as exc:  # pragma: no cover - connection errors logged
            logger.error("Failed to connect to Redis: %s", exc)
            raise

    async def disconnect(self) -> None:
        """Close Redis connections."""
        if self.client:
            await self.client.aclose()
            self.client = None

        await self.pool.disconnect()
        logger.info("Redis disconnected")

    async def get(self, key: str) -> Optional[str]:
        """Retrieve a cached value."""
        if not self.client:
            return None
        try:
            return await self.client.get(key)
        except RedisError as exc:
            logger.warning("Redis GET error for key %s: %s", key, exc)
            return None

    async def set(self, key: str, value: str, ttl: Optional[int] = None) -> bool:
        """Store a value with optional TTL."""
        if not self.client:
            return False
        try:
            if ttl:
                await self.client.setex(key, ttl, value)
            else:
                await self.client.set(key, value)
            return True
        except RedisError as exc:
            logger.warning("Redis SET error for key %s: %s", key, exc)
            return False

    async def delete(self, key: str) -> bool:
        """Delete a cached key."""
        if not self.client:
            return False
        try:
            await self.client.delete(key)
            return True
        except RedisError as exc:
            logger.warning("Redis DELETE error for key %s: %s", key, exc)
            return False

    async def delete_pattern(self, pattern: str) -> int:
        """Delete keys that match a pattern."""
        if not self.client:
            return 0
        try:
            keys = await self.client.keys(pattern)
            if not keys:
                return 0
            return await self.client.delete(*keys)
        except RedisError as exc:
            logger.warning("Redis DELETE pattern error for %s: %s", pattern, exc)
            return 0

    async def exists(self, key: str) -> bool:
        """Return True if a key exists."""
        if not self.client:
            return False
        try:
            return bool(await self.client.exists(key))
        except RedisError as exc:
            logger.warning("Redis EXISTS error for key %s: %s", key, exc)
            return False
</file>

<file path="src/infra/database/models/chat/__init__.py">
"""Chat database models."""
from .thread import ChatThread
from .message import ChatMessage

__all__ = [
    "ChatThread",
    "ChatMessage",
]
</file>

<file path="src/infra/database/models/meal/meal.py">
"""
Meal model for the main meal entity.
"""
from sqlalchemy import Column, String, Text, Enum, ForeignKey, DateTime, Integer, Boolean
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import TimestampMixin
from src.infra.database.models.enums import MealStatusEnum


class Meal(Base, TimestampMixin):
    """Database model for meals."""
    
    __tablename__ = 'meal'
    
    # Primary key
    meal_id = Column(String(36), primary_key=True)
    user_id = Column(String(36), nullable=False, index=True)  # User who created this meal
    status = Column(Enum(MealStatusEnum), nullable=False)
    dish_name = Column(String(255), nullable=True)  # The name of the dish
    ready_at = Column(DateTime, nullable=True)  # When meal analysis was completed
    error_message = Column(Text, nullable=True)
    raw_ai_response = Column(Text, nullable=True)
    
    # Edit tracking fields
    last_edited_at = Column(DateTime, nullable=True)  # When meal was last edited
    edit_count = Column(Integer, default=0, nullable=False)  # Number of times edited
    is_manually_edited = Column(Boolean, default=False, nullable=False)  # Whether meal has been manually edited
    
    # Relationships
    image_id = Column(String(36), ForeignKey("mealimage.image_id"), nullable=False)
    image = relationship("MealImage", uselist=False, lazy="joined")
    nutrition = relationship("Nutrition", uselist=False, back_populates="meal", cascade="all, delete-orphan")
    
    def to_domain(self):
        """Convert DB model to domain model."""
        from src.domain.model.meal import Meal as DomainMeal
        from src.infra.mappers import MealStatusMapper

        return DomainMeal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatusMapper.to_domain(self.status),
            created_at=self.created_at,
            image=self.image.to_domain() if self.image else None,
            dish_name=self.dish_name,
            nutrition=self.nutrition.to_domain() if self.nutrition else None,
            ready_at=self.ready_at,
            error_message=self.error_message,
            raw_gpt_json=self.raw_ai_response,
            updated_at=self.updated_at,
            last_edited_at=self.last_edited_at,
            edit_count=self.edit_count,
            is_manually_edited=self.is_manually_edited
        )
    
    @classmethod
    def from_domain(cls, domain_model):
        """Create DB model from domain model."""
        from datetime import datetime
        from src.infra.mappers import MealStatusMapper

        # Convert UUID objects to strings to ensure compatibility with MySQL
        meal_id = str(domain_model.meal_id) if domain_model.meal_id else None
        user_id = getattr(domain_model, "user_id", None)
        if user_id:
            user_id = str(user_id)

        # Create meal
        meal = cls(
            meal_id=meal_id,
            user_id=user_id,
            status=MealStatusMapper.to_db(domain_model.status),
            created_at=domain_model.created_at,
            updated_at=getattr(domain_model, "updated_at", None) or datetime.now(),
            dish_name=getattr(domain_model, "dish_name", None),
            ready_at=getattr(domain_model, "ready_at", None),
            error_message=getattr(domain_model, "error_message", None),
            raw_ai_response=getattr(domain_model, "raw_gpt_json", None),
            last_edited_at=getattr(domain_model, "last_edited_at", None),
            edit_count=getattr(domain_model, "edit_count", 0),
            is_manually_edited=getattr(domain_model, "is_manually_edited", False)
        )

        # Add image reference - convert UUID to string
        if domain_model.image:
            meal.image_id = str(domain_model.image.image_id)

        # Add nutrition if it exists
        if domain_model.nutrition:
            from src.infra.database.models.nutrition.nutrition import Nutrition
            meal.nutrition = Nutrition.from_domain(domain_model.nutrition, meal_id=meal_id)

        return meal
</file>

<file path="src/infra/database/models/notification/__init__.py">
"""
Notification database models.
"""
from .notification_preferences import NotificationPreferences
from .user_fcm_token import UserFcmToken

__all__ = [
    'NotificationPreferences',
    'UserFcmToken',
]
</file>

<file path="src/infra/database/models/nutrition/food_item.py">
"""
Food item model for individual food components within a meal.
"""
from sqlalchemy import Column, String, Float, Integer, ForeignKey, Boolean
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import PrimaryEntityMixin


class FoodItem(Base, PrimaryEntityMixin):
    """Database model for food items in a meal."""
    
    __tablename__ = 'food_item'  # Explicit table name to match migration
    
    name = Column(String(255), nullable=False)
    quantity = Column(Float, nullable=False)
    unit = Column(String(50), nullable=False)
    calories = Column(Float, nullable=False)
    confidence = Column(Float, nullable=True)
    
    # Edit support fields  
    fdc_id = Column(Integer, nullable=True)  # USDA FDC ID if available
    is_custom = Column(Boolean, default=False, nullable=False)  # Whether this is a custom ingredient
    
    # Macro fields (previously in separate Macros table)
    protein = Column(Float, default=0, nullable=False)
    carbs = Column(Float, default=0, nullable=False)
    fat = Column(Float, default=0, nullable=False)
    
    # Foreign keys
    nutrition_id = Column(Integer, ForeignKey("nutrition.id"), nullable=False)
    
    # Relationships
    nutrition = relationship("Nutrition", back_populates="food_items")
    
    def to_domain(self):
        """Convert DB model to domain model."""
        from src.domain.model.nutrition import FoodItem as DomainFoodItem
        
        # Create macros domain object from our fields
        from src.domain.model.nutrition import Macros as DomainMacros
        macros = DomainMacros(
            protein=self.protein,
            carbs=self.carbs,
            fat=self.fat,
        )
        
        return DomainFoodItem(
            id=self.id,  # Both database and domain use UUID strings now
            name=self.name,
            quantity=self.quantity,
            unit=self.unit,
            calories=self.calories,
            macros=macros,
            micros=None,  # Not implemented yet
            confidence=self.confidence,
            fdc_id=self.fdc_id,
            is_custom=self.is_custom
        )
    
    @classmethod
    def from_domain(cls, domain_model, nutrition_id=None):
        """Create DB model from domain model."""
        item = cls(
            name=domain_model.name,
            quantity=domain_model.quantity,
            unit=domain_model.unit,
            calories=domain_model.calories,
            confidence=domain_model.confidence,
            nutrition_id=nutrition_id,
            fdc_id=getattr(domain_model, 'fdc_id', None),
            is_custom=getattr(domain_model, 'is_custom', False)
        )
        
        # Set the ID if provided (for updates)
        # Convert UUID objects to strings to ensure compatibility with MySQL
        if hasattr(domain_model, 'id') and domain_model.id:
            item.id = str(domain_model.id)
        
        # Set macro fields directly
        if domain_model.macros:
            item.protein = domain_model.macros.protein
            item.carbs = domain_model.macros.carbs
            item.fat = domain_model.macros.fat
            
        return item
</file>

<file path="src/infra/database/models/nutrition/nutrition.py">
"""
Nutrition model for overall nutritional information of a meal.
"""
from sqlalchemy import Column, Float, Text, String, ForeignKey
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import SecondaryEntityMixin


class Nutrition(Base, SecondaryEntityMixin):
    """Database model for nutrition data."""
    
    calories = Column(Float, nullable=False)
    confidence_score = Column(Float, nullable=True)
    raw_ai_response = Column(Text, nullable=True)
    
    # Macro fields (previously in separate Macros table)
    protein = Column(Float, default=0, nullable=False)
    carbs = Column(Float, default=0, nullable=False)
    fat = Column(Float, default=0, nullable=False)
    
    # Relationships
    food_items = relationship("FoodItem", 
                             back_populates="nutrition", 
                             cascade="all, delete-orphan")
    meal_id = Column(String(36), ForeignKey("meal.meal_id"), nullable=False)
    meal = relationship("Meal", back_populates="nutrition")
    
    def to_domain(self):
        """Convert DB model to domain model."""
        from src.domain.model.nutrition import Nutrition as DomainNutrition
        
        # Convert food items if they exist
        food_items = [item.to_domain() for item in self.food_items] if self.food_items else None
        
        # Create macros domain object from our fields
        from src.domain.model.nutrition import Macros as DomainMacros
        macros = DomainMacros(
            protein=self.protein,
            carbs=self.carbs,
            fat=self.fat,
        )
        
        return DomainNutrition(
            calories=self.calories,
            macros=macros,
            micros=None,  # Not implemented yet
            food_items=food_items,
            confidence_score=self.confidence_score
        )
    
    @classmethod
    def from_domain(cls, domain_model, meal_id):
        """Create DB model from domain model."""
        # Convert UUID objects to strings to ensure compatibility with MySQL
        meal_id_str = str(meal_id) if meal_id else None
        
        nutrition = cls(
            calories=domain_model.calories,
            confidence_score=domain_model.confidence_score,
            meal_id=meal_id_str
        )
        
        # Set macro fields directly
        if domain_model.macros:
            nutrition.protein = domain_model.macros.protein
            nutrition.carbs = domain_model.macros.carbs
            nutrition.fat = domain_model.macros.fat
            
        # Add food items if they exist
        if domain_model.food_items:
            from .food_item import FoodItem
            # nutrition_id will be available after flush
            nutrition.food_items = [
                FoodItem.from_domain(food_item)
                for food_item in domain_model.food_items
            ]
            
        return nutrition
</file>

<file path="src/infra/database/models/user/profile.py">
"""
User profile model for physical attributes and personal information.
"""
from sqlalchemy import Column, String, Boolean, Integer, Float, ForeignKey, Index, CheckConstraint, JSON
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class UserProfile(Base, BaseMixin):
    """Stores user physical attributes and personal info with historical tracking."""
    __tablename__ = 'user_profiles'
    
    user_id = Column(String(36), ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    age = Column(Integer, nullable=False)
    gender = Column(String(20), nullable=False)  # male, female, other
    height_cm = Column(Float, nullable=False)
    weight_kg = Column(Float, nullable=False)
    body_fat_percentage = Column(Float, nullable=True)
    is_current = Column(Boolean, default=True, nullable=False)
    
    # Goal fields (from UserGoal)
    activity_level = Column(String(30), nullable=False, default='sedentary')  # sedentary, light, moderate, active, extra
    fitness_goal = Column(String(30), nullable=False, default='maintenance')  # maintenance, cutting, bulking
    target_weight_kg = Column(Float, nullable=True)
    meals_per_day = Column(Integer, default=3, nullable=False)
    snacks_per_day = Column(Integer, default=1, nullable=False)
    
    # Preference fields (from UserPreferences)
    dietary_preferences = Column(JSON, default=[], nullable=False)  # ['vegan', 'vegetarian', 'gluten_free', etc.]
    health_conditions = Column(JSON, default=[], nullable=False)    # ['diabetes', 'hypertension', etc.]
    allergies = Column(JSON, default=[], nullable=False)           # ['nuts', 'dairy', 'shellfish', etc.]
    pain_points = Column(JSON, default=[], nullable=True)
    
    # Constraints
    __table_args__ = (
        CheckConstraint('age >= 13 AND age <= 120', name='check_age_range'),
        CheckConstraint('height_cm > 0', name='check_height_positive'),
        CheckConstraint('weight_kg > 0', name='check_weight_positive'),
        CheckConstraint('body_fat_percentage IS NULL OR (body_fat_percentage >= 0 AND body_fat_percentage <= 100)', 
                       name='check_body_fat_range'),
        Index('idx_user_current', 'user_id', 'is_current'),
    )
    
    # Relationships
    user = relationship("User", back_populates="profiles")
</file>

<file path="src/infra/database/models/enums.py">
"""
Centralized enum definitions for database models.
"""
import enum


class MealStatusEnum(enum.Enum):
    """Enum for meal status in database."""
    PROCESSING = "PROCESSING"
    ANALYZING = "ANALYZING"
    ENRICHING = "ENRICHING"
    READY = "READY"
    FAILED = "FAILED"
    INACTIVE = "INACTIVE"


class DietaryPreferenceEnum(str, enum.Enum):
    """Dietary preference options."""
    vegan = "vegan"
    vegetarian = "vegetarian"
    pescatarian = "pescatarian"
    gluten_free = "gluten_free"
    keto = "keto"
    paleo = "paleo"
    low_carb = "low_carb"
    dairy_free = "dairy_free"
    none = "none"


class FitnessGoalEnum(str, enum.Enum):
    """Fitness goal options."""
    cut = "cut"
    bulk = "bulk"
    recomp = "recomp"


class MealTypeEnum(str, enum.Enum):
    """Meal type options."""
    breakfast = "breakfast"
    lunch = "lunch"
    dinner = "dinner"
    snack = "snack"


class PlanDurationEnum(str, enum.Enum):
    """Meal plan duration options."""
    daily = "daily"
    weekly = "weekly"


class ConversationStateEnum(str, enum.Enum):
    """Conversation state options for chat flow."""
    greeting = "greeting"
    asking_dietary_preferences = "asking_dietary_preferences"
    asking_allergies = "asking_allergies"
    asking_fitness_goals = "asking_fitness_goals"
    asking_meal_count = "asking_meal_count"
    asking_plan_duration = "asking_plan_duration"
    asking_cooking_time = "asking_cooking_time"
    asking_cuisine_preferences = "asking_cuisine_preferences"
    confirming_preferences = "confirming_preferences"
    generating_plan = "generating_plan"
    showing_plan = "showing_plan"
    adjusting_meal = "adjusting_meal"
    completed = "completed"


class ActivityLevelEnum(str, enum.Enum):
    """Activity level for TDEE calculations."""
    sedentary = "sedentary"
    lightly_active = "lightly_active"
    moderately_active = "moderately_active"
    very_active = "very_active"
    extra_active = "extra_active"


class SexEnum(str, enum.Enum):
    """Biological sex for TDEE calculations."""
    male = "male"
    female = "female"


class GoalEnum(str, enum.Enum):
    """Fitness goal for macro calculations."""
    cut = "cut"
    bulk = "bulk"
    recomp = "recomp"
</file>

<file path="src/infra/event_bus/pymediator_event_bus.py">
"""
PyMediator-based event bus implementation.
"""
import asyncio
import logging
from typing import Any, Type, TypeVar, Dict, List

from pymediator import Mediator as PyMediator, SingletonRegistry

from src.app.events.base import Event, DomainEvent, EventHandler
from .event_bus import EventBus

logger = logging.getLogger(__name__)

T = TypeVar('T')


class EventRequest:
    """Wrapper to make our Events compatible with pymediator Request protocol."""
    def __init__(self, event: Event):
        self._event = event

    @property
    def event(self) -> Event:
        return self._event


class AsyncPyMediatorHandlerAdapter:
    """Async-aware adapter for our EventHandlers."""

    def __init__(self, event_handler: EventHandler):
        self._event_handler = event_handler

    async def handle(self, request: Any) -> Any:
        """Handle the request asynchronously."""
        # Extract the actual event from the wrapper
        if hasattr(request, 'event'):
            actual_event = request.event
        else:
            actual_event = request

        return await self._event_handler.handle(actual_event)


class PyMediatorEventBus(EventBus):
    """
    Event bus implementation using pymediator library.

    This implementation wraps pymediator to provide compatibility with our
    event-driven architecture while leveraging pymediator's features.
    Uses async-native execution without thread pools for proper event loop handling.
    """

    def __init__(self):
        # Use SingletonRegistry to ensure handlers are reused
        registry = SingletonRegistry()
        self._mediator = PyMediator(registry=registry)
        self._event_type_mapping: Dict[Type[Event], Type[EventRequest]] = {}
        self._domain_event_subscribers: Dict[Type[DomainEvent], List[Any]] = {}
        # Store direct handler references for async execution
        self._async_handlers: Dict[Type[Event], EventHandler] = {}

    def register_handler(self, event_type: Type[Event], handler: EventHandler) -> None:
        """Register a handler for a specific event type."""
        # Store the handler directly for async execution
        self._async_handlers[event_type] = handler

        # Create a unique wrapper class for this event type
        wrapper_class = type(
            f"{event_type.__name__}Request",
            (EventRequest,),
            {
                '__init__': lambda self, event: EventRequest.__init__(self, event)
            }
        )

        # Store the mapping
        self._event_type_mapping[event_type] = wrapper_class

        # Create async handler adapter
        adapter_class = type(
            f"{handler.__class__.__name__}AsyncAdapter",
            (AsyncPyMediatorHandlerAdapter,),
            {
                '__init__': lambda self: AsyncPyMediatorHandlerAdapter.__init__(self, handler)
            }
        )

        # Register with pymediator
        self._mediator.registry.register(wrapper_class, adapter_class)

    def subscribe(self, event_type: Type[DomainEvent], handler) -> None:
        """Subscribe to domain events."""
        if event_type not in self._domain_event_subscribers:
            self._domain_event_subscribers[event_type] = []

        self._domain_event_subscribers[event_type].append(handler)
        logger.info(f"Subscribed to {event_type.__name__}")

    async def send(self, event: Event) -> Any:
        """Send a command/query and get the result."""
        event_type = type(event)

        if event_type not in self._async_handlers:
            raise ValueError(f"No handler registered for {event_type.__name__}")

        try:
            # Get the handler directly and execute it asynchronously
            handler = self._async_handlers[event_type]

            # Check if handler is async
            import inspect
            if inspect.iscoroutinefunction(handler.handle):
                result = await handler.handle(event)
            else:
                # For sync handlers, execute directly (no thread pool needed)
                result = handler.handle(event)

            # Handle domain events if returned
            if isinstance(result, list) and all(isinstance(e, DomainEvent) for e in result):
                logger.info(f"Publishing {len(result)} domain events from command result")
                for domain_event in result:
                    await self.publish(domain_event)
            elif isinstance(result, dict) and 'events' in result:
                events = result.get('events', [])
                logger.info(f"Publishing {len(events)} domain events from command result")
                for domain_event in events:
                    if isinstance(domain_event, DomainEvent):
                        await self.publish(domain_event)
            return result

        except Exception as e:
            logger.error(f"Error handling {event_type.__name__}: {str(e)}", exc_info=True)
            raise
    
    async def publish(self, event: DomainEvent) -> None:
        """Publish a domain event to all subscribers."""
        event_type = type(event)
        
        if event_type not in self._domain_event_subscribers:
            logger.debug(f"No subscribers for {event_type.__name__}")
            return
        
        subscribers = self._domain_event_subscribers[event_type]
        logger.debug(f"Publishing {event_type.__name__} to {len(subscribers)} subscribers")
        
        # Execute subscribers concurrently
        tasks = []
        for subscriber in subscribers:
            if asyncio.iscoroutinefunction(subscriber):
                tasks.append(subscriber(event))
            else:
                # Wrap sync handlers in async
                async def async_wrapper(handler, evt):
                    return handler(evt)
                tasks.append(async_wrapper(subscriber, event))
        
        if tasks:
            # Execute all tasks in the background (fire-and-forget)
            async def run_tasks_in_background():
                logger.info(f"Starting background processing for {event_type.__name__}")
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # Log any exceptions
                for i, result in enumerate(results):
                    if isinstance(result, Exception):
                        logger.error(
                            f"Subscriber {i} for {event_type.__name__} failed: {result}",
                            exc_info=result
                        )
                logger.info(f"Background processing completed for {event_type.__name__}")
            
            # Schedule the task to run in the background
            logger.info(f"Scheduling background task for {event_type.__name__}")
            asyncio.create_task(run_tasks_in_background())

    def close(self):
        """Close event bus resources."""
        logger.info("Event bus closed")
</file>

<file path="src/infra/repositories/notification/__init__.py">
"""Notification repository components."""
from src.infra.repositories.notification.fcm_token_operations import FcmTokenOperations
from src.infra.repositories.notification.notification_preferences_operations import NotificationPreferencesOperations
from src.infra.repositories.notification.reminder_query_builder import ReminderQueryBuilder

__all__ = [
    "FcmTokenOperations",
    "NotificationPreferencesOperations",
    "ReminderQueryBuilder",
]
</file>

<file path="src/infra/repositories/notification/fcm_token_operations.py">
"""FCM token CRUD operations."""
import logging
from typing import List, Optional

from sqlalchemy import and_
from sqlalchemy.orm import Session

from src.domain.model.notification import UserFcmToken
from src.infra.database.models.notification import UserFcmToken as DBUserFcmToken

logger = logging.getLogger(__name__)


class FcmTokenOperations:
    """Handles FCM token database operations."""

    @staticmethod
    def save_fcm_token(db: Session, token: UserFcmToken) -> UserFcmToken:
        """Save an FCM token to the database."""
        try:
            existing_token = db.query(DBUserFcmToken).filter(
                DBUserFcmToken.fcm_token == token.fcm_token
            ).first()

            if existing_token:
                existing_token.user_id = token.user_id
                existing_token.device_type = token.device_type.value
                existing_token.is_active = token.is_active
                existing_token.updated_at = token.updated_at
                db.commit()
                return existing_token.to_domain()
            else:
                db_token = DBUserFcmToken(
                    id=token.token_id,
                    user_id=token.user_id,
                    fcm_token=token.fcm_token,
                    device_type=token.device_type.value,
                    is_active=token.is_active,
                    created_at=token.created_at,
                    updated_at=token.updated_at
                )
                db.add(db_token)
                db.commit()
                return db_token.to_domain()
        except Exception as e:
            db.rollback()
            logger.error(f"Error saving FCM token: {e}")
            raise e

    @staticmethod
    def find_fcm_token_by_token(db: Session, fcm_token: str) -> Optional[UserFcmToken]:
        """Find an FCM token by the token string."""
        db_token = db.query(DBUserFcmToken).filter(
            DBUserFcmToken.fcm_token == fcm_token
        ).first()
        return db_token.to_domain() if db_token else None

    @staticmethod
    def find_active_fcm_tokens_by_user(db: Session, user_id: str) -> List[UserFcmToken]:
        """Find all active FCM tokens for a user."""
        db_tokens = db.query(DBUserFcmToken).filter(
            and_(
                DBUserFcmToken.user_id == user_id,
                DBUserFcmToken.is_active == True
            )
        ).all()
        return [token.to_domain() for token in db_tokens]

    @staticmethod
    def deactivate_fcm_token(db: Session, fcm_token: str) -> bool:
        """Deactivate an FCM token."""
        try:
            db_token = db.query(DBUserFcmToken).filter(
                DBUserFcmToken.fcm_token == fcm_token
            ).first()

            if db_token:
                db_token.is_active = False
                db.commit()
                return True
            else:
                return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error deactivating FCM token: {e}")
            raise e

    @staticmethod
    def delete_fcm_token(db: Session, fcm_token: str) -> bool:
        """Delete an FCM token."""
        try:
            db_token = db.query(DBUserFcmToken).filter(
                DBUserFcmToken.fcm_token == fcm_token
            ).first()

            if db_token:
                db.delete(db_token)
                db.commit()
                return True
            else:
                return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error deleting FCM token: {e}")
            raise e
</file>

<file path="src/infra/repositories/notification/notification_preferences_operations.py">
"""Notification preferences CRUD operations."""
import logging
from datetime import datetime
from typing import Optional

from sqlalchemy.orm import Session

from src.domain.model.notification import NotificationPreferences
from src.infra.database.models.notification import NotificationPreferences as DBNotificationPreferences

logger = logging.getLogger(__name__)


class NotificationPreferencesOperations:
    """Handles notification preferences database operations."""

    @staticmethod
    def save_notification_preferences(db: Session, preferences: NotificationPreferences) -> NotificationPreferences:
        """Save notification preferences to the database."""
        try:
            existing_prefs = db.query(DBNotificationPreferences).filter(
                DBNotificationPreferences.user_id == preferences.user_id
            ).first()

            if existing_prefs:
                existing_prefs.meal_reminders_enabled = preferences.meal_reminders_enabled
                existing_prefs.water_reminders_enabled = preferences.water_reminders_enabled
                existing_prefs.sleep_reminders_enabled = preferences.sleep_reminders_enabled
                existing_prefs.progress_notifications_enabled = preferences.progress_notifications_enabled
                existing_prefs.reengagement_notifications_enabled = preferences.reengagement_notifications_enabled
                existing_prefs.breakfast_time_minutes = preferences.breakfast_time_minutes
                existing_prefs.lunch_time_minutes = preferences.lunch_time_minutes
                existing_prefs.dinner_time_minutes = preferences.dinner_time_minutes
                existing_prefs.water_reminder_interval_hours = preferences.water_reminder_interval_hours
                existing_prefs.sleep_reminder_time_minutes = preferences.sleep_reminder_time_minutes
                existing_prefs.updated_at = preferences.updated_at
                db.commit()
                return existing_prefs.to_domain()
            else:
                db_prefs = DBNotificationPreferences(
                    id=preferences.preferences_id,
                    user_id=preferences.user_id,
                    meal_reminders_enabled=preferences.meal_reminders_enabled,
                    water_reminders_enabled=preferences.water_reminders_enabled,
                    sleep_reminders_enabled=preferences.sleep_reminders_enabled,
                    progress_notifications_enabled=preferences.progress_notifications_enabled,
                    reengagement_notifications_enabled=preferences.reengagement_notifications_enabled,
                    breakfast_time_minutes=preferences.breakfast_time_minutes,
                    lunch_time_minutes=preferences.lunch_time_minutes,
                    dinner_time_minutes=preferences.dinner_time_minutes,
                    water_reminder_interval_hours=preferences.water_reminder_interval_hours,
                    sleep_reminder_time_minutes=preferences.sleep_reminder_time_minutes,
                    created_at=preferences.created_at,
                    updated_at=preferences.updated_at
                )
                db.add(db_prefs)
                db.commit()
                return db_prefs.to_domain()
        except Exception as e:
            db.rollback()
            logger.error(f"Error saving notification preferences: {e}")
            raise e

    @staticmethod
    def find_notification_preferences_by_user(db: Session, user_id: str) -> Optional[NotificationPreferences]:
        """Find notification preferences by user ID."""
        db_prefs = db.query(DBNotificationPreferences).filter(
            DBNotificationPreferences.user_id == user_id
        ).first()
        return db_prefs.to_domain() if db_prefs else None

    @staticmethod
    def delete_notification_preferences(db: Session, user_id: str) -> bool:
        """Delete notification preferences for a user."""
        try:
            db_prefs = db.query(DBNotificationPreferences).filter(
                DBNotificationPreferences.user_id == user_id
            ).first()

            if db_prefs:
                db.delete(db_prefs)
                db.commit()
                return True
            else:
                return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error deleting notification preferences: {e}")
            raise e

    @staticmethod
    def update_last_water_reminder(db: Session, user_id: str, sent_at: datetime) -> bool:
        """Update last water reminder timestamp for user."""
        try:
            prefs = db.query(DBNotificationPreferences).filter(
                DBNotificationPreferences.user_id == user_id
            ).first()
            if prefs:
                prefs.last_water_reminder_at = sent_at
                db.commit()
                return True
            return False
        except Exception as e:
            db.rollback()
            logger.error(f"Error updating last water reminder for {user_id}: {e}")
            raise e
</file>

<file path="src/infra/repositories/notification/reminder_query_builder.py">
"""Reminder query builder for finding users due for notifications."""
from datetime import datetime
from typing import List

from sqlalchemy.orm import Session

from src.domain.services.timezone_utils import (
    utc_to_local_minutes,
    is_in_quiet_hours,
    DEFAULT_TIMEZONE
)
from src.infra.database.models.notification import NotificationPreferences as DBNotificationPreferences
from src.infra.database.models.user.user import User


class ReminderQueryBuilder:
    """Builds queries for finding users due for reminders."""

    @staticmethod
    def find_users_for_meal_reminder(db: Session, meal_type: str, current_utc: datetime) -> List[str]:
        """
        Find user IDs who should receive meal reminders at current UTC time.

        Converts UTC to each user's local time for matching.

        Args:
            db: Database session
            meal_type: breakfast, lunch, or dinner
            current_utc: Current UTC datetime

        Returns:
            List of user IDs who should receive reminder
        """
        if meal_type == "breakfast":
            time_field = DBNotificationPreferences.breakfast_time_minutes
        elif meal_type == "lunch":
            time_field = DBNotificationPreferences.lunch_time_minutes
        elif meal_type == "dinner":
            time_field = DBNotificationPreferences.dinner_time_minutes
        else:
            return []

        results = (
            db.query(
                DBNotificationPreferences.user_id,
                User.timezone,
                time_field
            )
            .join(User, DBNotificationPreferences.user_id == User.id)
            .filter(
                DBNotificationPreferences.meal_reminders_enabled == True,
                time_field.isnot(None)
            )
            .all()
        )

        matching_users = []
        for user_id, timezone, pref_minutes in results:
            user_timezone = timezone or DEFAULT_TIMEZONE
            local_minutes = utc_to_local_minutes(current_utc, user_timezone)

            if pref_minutes is not None and pref_minutes == local_minutes:
                matching_users.append(user_id)

        return matching_users

    @staticmethod
    def find_users_for_sleep_reminder(db: Session, current_utc: datetime) -> List[str]:
        """
        Find user IDs who should receive sleep reminders at current UTC time.

        Args:
            db: Database session
            current_utc: Current UTC datetime

        Returns:
            List of user IDs who should receive reminder
        """
        results = (
            db.query(
                DBNotificationPreferences.user_id,
                DBNotificationPreferences.sleep_reminder_time_minutes,
                User.timezone
            )
            .join(User, DBNotificationPreferences.user_id == User.id)
            .filter(
                DBNotificationPreferences.sleep_reminders_enabled == True,
                DBNotificationPreferences.sleep_reminder_time_minutes.isnot(None)
            )
            .all()
        )

        matching_users = []
        for user_id, pref_minutes, timezone in results:
            user_timezone = timezone or DEFAULT_TIMEZONE
            local_minutes = utc_to_local_minutes(current_utc, user_timezone)

            if pref_minutes == local_minutes:
                matching_users.append(user_id)

        return matching_users

    @staticmethod
    def find_users_for_water_reminder(db: Session, current_utc: datetime) -> List[str]:
        """
        Find users who should receive water reminders based on interval and quiet hours.

        Skips users whose local time is in quiet hours (sleep → breakfast).

        Args:
            db: Database session
            current_utc: Current UTC datetime

        Returns:
            List of user IDs due for water reminder
        """
        results = (
            db.query(
                DBNotificationPreferences.user_id,
                DBNotificationPreferences.water_reminder_interval_hours,
                DBNotificationPreferences.last_water_reminder_at,
                DBNotificationPreferences.sleep_reminder_time_minutes,
                DBNotificationPreferences.breakfast_time_minutes,
                User.timezone
            )
            .join(User, DBNotificationPreferences.user_id == User.id)
            .filter(DBNotificationPreferences.water_reminders_enabled == True)
            .all()
        )

        matching_users = []
        for (user_id, interval_hours, last_sent,
             sleep_time, breakfast_time, timezone) in results:

            user_timezone = timezone or DEFAULT_TIMEZONE
            local_minutes = utc_to_local_minutes(current_utc, user_timezone)

            if is_in_quiet_hours(local_minutes, sleep_time, breakfast_time):
                continue

            if last_sent is None:
                matching_users.append(user_id)
            else:
                current_naive = current_utc.replace(tzinfo=None)
                last_sent_naive = last_sent.replace(tzinfo=None) if last_sent.tzinfo else last_sent
                hours_since_last = (current_naive - last_sent_naive).total_seconds() / 3600
                if hours_since_last >= interval_hours:
                    matching_users.append(user_id)

        return matching_users
</file>

<file path="src/infra/services/ai/parsers/__init__.py">
"""AI response parsers."""
from .ai_response_parser import AIResponseParser

__all__ = ["AIResponseParser"]
</file>

<file path="src/infra/services/ai/parsers/ai_response_parser.py">
"""
AI response parser for handling structured responses from AI services.
Extracts parsing logic to make it reusable and testable.
"""
import json
import logging
from typing import Dict, Any, List

logger = logging.getLogger(__name__)


class AIResponseParser:
    """
    Parser for AI chat responses.

    Handles JSON-formatted responses with structured data like
    meal suggestions, follow-up questions, etc.
    """

    @staticmethod
    def parse_response(content: str) -> Dict[str, Any]:
        """
        Parse AI response and extract structured data.

        Args:
            content: Raw AI response content (potentially JSON)

        Returns:
            Dictionary with:
            - message: The display message (str)
            - follow_ups: List of follow-up questions (list)
            - structured_data: Meal suggestions and other data (dict or None)
        """
        try:
            # Try to parse as JSON
            # Handle potential markdown code blocks
            clean_content = content.strip()

            # Remove markdown code block delimiters
            if clean_content.startswith("```json"):
                clean_content = clean_content[7:]
            elif clean_content.startswith("```"):
                clean_content = clean_content[3:]

            if clean_content.endswith("```"):
                clean_content = clean_content[:-3]

            clean_content = clean_content.strip()

            # Parse JSON
            parsed = json.loads(clean_content)

            return {
                "message": parsed.get("message", content),
                "follow_ups": AIResponseParser._parse_follow_ups(
                    parsed.get("follow_ups", [])
                ),
                "structured_data": AIResponseParser._parse_structured_data(parsed)
            }

        except json.JSONDecodeError as e:
            logger.warning(f"AI response not in JSON format: {e}")
            # Fallback: return raw content with no structured data
            return {
                "message": content,
                "follow_ups": [],
                "structured_data": None
            }

    @staticmethod
    def _parse_follow_ups(follow_ups_raw: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Parse and validate follow-up questions.

        Args:
            follow_ups_raw: Raw follow-up data from AI

        Returns:
            List of validated follow-up dictionaries
        """
        validated_follow_ups = []

        for i, follow_up in enumerate(follow_ups_raw):
            if not isinstance(follow_up, dict):
                continue

            validated_follow_ups.append({
                "id": follow_up.get("id", f"followup_{i}"),
                "text": follow_up.get("text", ""),
                "type": follow_up.get("type", "question"),
                "metadata": follow_up.get("metadata")
            })

        return validated_follow_ups

    @staticmethod
    def _parse_structured_data(parsed: Dict[str, Any]) -> Dict[str, Any]:
        """
        Parse structured data like meals and recipes.

        Args:
            parsed: Parsed JSON response

        Returns:
            Structured data dictionary or None if no data present
        """
        meals = parsed.get("meals", [])
        recipes = parsed.get("recipes", [])

        # Only return structured data if we have content
        if meals or recipes:
            return {
                "meals": AIResponseParser._validate_meals(meals),
                "recipes": recipes  # Could add validation here too
            }

        return None

    @staticmethod
    def _validate_meals(meals: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """
        Validate meal data structure.

        Args:
            meals: List of meal dictionaries

        Returns:
            List of validated meal dictionaries
        """
        validated_meals = []

        for meal in meals:
            if not isinstance(meal, dict):
                continue

            # Ensure required fields exist
            validated_meal = {
                "name": meal.get("name", "Unknown Meal"),
                "ingredients": meal.get("ingredients", []),
                "difficulty": meal.get("difficulty", "medium"),
                "cook_time": meal.get("cook_time", "Unknown"),
                "description": meal.get("description", "")
            }

            validated_meals.append(validated_meal)

        return validated_meals

    @staticmethod
    def is_json_response(content: str) -> bool:
        """
        Check if content appears to be JSON formatted.

        Args:
            content: Content to check

        Returns:
            True if content appears to be JSON
        """
        clean_content = content.strip()

        # Check for markdown code blocks
        if clean_content.startswith("```"):
            return True

        # Check for JSON object start
        if clean_content.startswith("{") and clean_content.endswith("}"):
            try:
                json.loads(clean_content)
                return True
            except json.JSONDecodeError:
                return False

        return False
</file>

<file path="src/infra/services/ai/prompts/__init__.py">
"""AI prompt management."""
from .system_prompts import SystemPrompts

__all__ = ["SystemPrompts"]
</file>

<file path="src/infra/services/ai/prompts/system_prompts.py">
"""
System prompts for AI chat services.
Centralizes prompt management for easy maintenance and versioning.
"""
from typing import Optional


class SystemPrompts:
    """
    Manages system prompts for different AI chat contexts.

    This class centralizes all prompt definitions making them easier to:
    - Maintain and update
    - Version control
    - A/B test
    - Customize per user or context
    """

    # Meal Planning Assistant Prompt
    MEAL_PLANNING_ASSISTANT = """You are a helpful meal planning and cooking assistant. Your role is to:

1. Help users choose meals based on their available ingredients
2. Suggest recipes and cooking instructions
3. Provide nutritional information when relevant
4. Offer alternatives and modifications based on dietary needs

IMPORTANT: You MUST always respond in this exact JSON format (no markdown, no code blocks, just raw JSON):
{
  "message": "Your friendly, conversational response here. Be helpful and encouraging!",
  "follow_ups": [
    {"id": "followup_1", "text": "Relevant follow-up question or action", "type": "question"},
    {"id": "followup_2", "text": "Another contextual suggestion", "type": "recipe"}
  ],
  "meals": [
    {"name": "Meal Name", "ingredients": ["ingredient1", "ingredient2"], "difficulty": "easy", "cook_time": "30 mins", "description": "Brief description"}
  ]
}

Guidelines:
- Be conversational, friendly, and encouraging in your "message" field
- Suggest 2-5 meal options when the user asks about ingredients or meal ideas
- Always provide 2-4 relevant follow-up questions based on the conversation context
- Follow-up types: "question" (ask for more info), "recipe" (show recipe details), "modify" (dietary changes), "alternative" (suggest alternatives)
- Consider dietary restrictions, allergies, or preferences if mentioned
- If user asks for a specific recipe, include detailed cooking instructions in your message
- Keep meal suggestions practical and achievable for home cooking
- If you don't have enough information, ask clarifying questions in follow_ups

Remember: ONLY output valid JSON. No explanations, no markdown formatting, just the JSON object."""

    @staticmethod
    def get_meal_planning_prompt(
        custom_instructions: Optional[str] = None
    ) -> str:
        """
        Get meal planning assistant system prompt.

        Args:
            custom_instructions: Optional custom instructions to append

        Returns:
            Complete system prompt
        """
        base_prompt = SystemPrompts.MEAL_PLANNING_ASSISTANT

        if custom_instructions:
            base_prompt += f"\n\nAdditional Instructions:\n{custom_instructions}"

        return base_prompt

    @staticmethod
    def get_prompt_for_user_preferences(
        dietary_restrictions: Optional[list] = None,
        allergies: Optional[list] = None,
        cuisine_preferences: Optional[list] = None
    ) -> str:
        """
        Get customized prompt based on user preferences.

        Args:
            dietary_restrictions: List of dietary restrictions (e.g., ["vegetarian", "low-carb"])
            allergies: List of allergies (e.g., ["peanuts", "shellfish"])
            cuisine_preferences: List of preferred cuisines (e.g., ["Italian", "Japanese"])

        Returns:
            Customized system prompt
        """
        custom_instructions = []

        if dietary_restrictions:
            restrictions_str = ", ".join(dietary_restrictions)
            custom_instructions.append(
                f"The user follows these dietary restrictions: {restrictions_str}. "
                "Always respect these restrictions in meal suggestions."
            )

        if allergies:
            allergies_str = ", ".join(allergies)
            custom_instructions.append(
                f"IMPORTANT: The user is allergic to: {allergies_str}. "
                "NEVER suggest meals containing these allergens."
            )

        if cuisine_preferences:
            cuisines_str = ", ".join(cuisine_preferences)
            custom_instructions.append(
                f"The user prefers these cuisines: {cuisines_str}. "
                "Prioritize suggestions from these cuisines when possible."
            )

        custom_text = " ".join(custom_instructions) if custom_instructions else None
        return SystemPrompts.get_meal_planning_prompt(custom_text)
</file>

<file path="src/infra/services/ai/openai_chat_service.py">
"""
OpenAI implementation of AI chat service.
"""
import logging
import os
from typing import List, Dict, Any, Optional, AsyncIterator

from src.domain.ports.ai_chat_service_port import AIChatServicePort

logger = logging.getLogger(__name__)


class OpenAIChatService(AIChatServicePort):
    """OpenAI implementation of AI chat service."""
    
    def __init__(self, api_key: Optional[str] = None, model: str = "gpt-3.5-turbo"):
        self.api_key = api_key or os.getenv("OPENAI_API_KEY")
        self.model = model
        self.client = None
        
        if self.api_key:
            try:
                import openai
                self.client = openai.AsyncOpenAI(api_key=self.api_key)
                logger.info(f"OpenAI chat service initialized with model {self.model}")
            except ImportError:
                logger.warning("OpenAI package not installed. Install with: pip install openai")
        else:
            logger.warning("OPENAI_API_KEY not set. AI responses will not be available.")
    
    async def generate_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None
    ) -> Dict[str, Any]:
        """Generate AI response using OpenAI API."""
        if not self.client:
            raise RuntimeError("OpenAI client not initialized. Check API key.")
        
        # Validate temperature parameter
        if not 0 <= temperature <= 2:
            raise ValueError("temperature must be between 0 and 2")
        
        try:
            # Prepare messages
            formatted_messages = []
            
            # Add system prompt if provided
            if system_prompt:
                formatted_messages.append({
                    "role": "system",
                    "content": system_prompt
                })
            
            # Add conversation messages
            formatted_messages.extend(messages)
            
            # Call OpenAI API
            response = await self.client.chat.completions.create(
                model=self.model,
                messages=formatted_messages,
                temperature=temperature,
                max_tokens=max_tokens
            )
            
            # Extract response
            content = response.choices[0].message.content
            
            # Prepare metadata
            metadata = {
                "model": response.model,
                "usage": {
                    "prompt_tokens": response.usage.prompt_tokens,
                    "completion_tokens": response.usage.completion_tokens,
                    "total_tokens": response.usage.total_tokens
                },
                "finish_reason": response.choices[0].finish_reason
            }
            
            return {
                "content": content,
                "metadata": metadata
            }
        
        except Exception as e:
            logger.error(f"Error generating OpenAI response: {e}")
            raise RuntimeError(f"Failed to generate AI response: {str(e)}")
    
    async def generate_streaming_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None
    ) -> AsyncIterator[Dict[str, Any]]:
        """Generate AI response with streaming chunks."""
        if not self.client:
            raise RuntimeError("OpenAI client not initialized. Check API key.")
        
        # Validate temperature parameter
        if not 0 <= temperature <= 2:
            raise ValueError("temperature must be between 0 and 2")
        
        try:
            # Prepare messages
            formatted_messages = []
            
            # Add system prompt if provided
            if system_prompt:
                formatted_messages.append({
                    "role": "system",
                    "content": system_prompt
                })
            
            # Add conversation messages
            formatted_messages.extend(messages)
            
            # Call OpenAI API with streaming
            stream = await self.client.chat.completions.create(
                model=self.model,
                messages=formatted_messages,
                temperature=temperature,
                max_tokens=max_tokens,
                stream=True
            )
            
            # Yield chunks
            async for chunk in stream:
                if chunk.choices[0].delta.content:
                    yield {
                        "chunk": chunk.choices[0].delta.content,
                        "metadata": {
                            "model": chunk.model,
                            "finish_reason": chunk.choices[0].finish_reason
                        }
                    }
        
        except Exception as e:
            logger.error(f"Error generating streaming OpenAI response: {e}")
            raise RuntimeError(f"Failed to generate streaming AI response: {str(e)}")
</file>

<file path="src/infra/websocket/__init__.py">
"""WebSocket utilities."""
from .connection_manager import ConnectionManager, chat_connection_manager

__all__ = [
    "ConnectionManager",
    "chat_connection_manager",
]
</file>

<file path="src/api/builders/chat_response_builder.py">
"""
Chat response builder for constructing API responses.
Extracts response building logic from route handlers.
"""
from typing import Dict, List, Optional

from src.api.schemas.response.chat_responses import (
    MessageResponse,
    FollowUpQuestion,
    StructuredData,
    MealSuggestion
)


class ChatResponseBuilder:
    """Builds properly structured chat API responses."""

    @staticmethod
    def build_message_response(msg_dict: dict) -> MessageResponse:
        """
        Build MessageResponse with proper follow_ups and structured_data.

        Args:
            msg_dict: Dictionary containing message data with metadata

        Returns:
            MessageResponse with properly structured follow-ups and data
        """
        metadata = msg_dict.get("metadata") or {}
        follow_ups_raw = metadata.get("follow_ups", [])
        structured_data_raw = metadata.get("structured_data")

        # Convert raw follow_ups to FollowUpQuestion objects
        follow_ups = None
        if follow_ups_raw:
            follow_ups = [
                FollowUpQuestion(
                    id=f.get("id", f"followup_{i}"),
                    text=f.get("text", ""),
                    type=f.get("type", "question"),
                    metadata=f.get("metadata")
                )
                for i, f in enumerate(follow_ups_raw)
            ]

        # Convert raw structured_data to StructuredData
        structured_data = None
        if structured_data_raw and (
            structured_data_raw.get("meals") or structured_data_raw.get("recipes")
        ):
            # Convert meal dicts to MealSuggestion objects
            meals = None
            if structured_data_raw.get("meals"):
                meals = [
                    MealSuggestion(**meal) if isinstance(meal, dict) else meal
                    for meal in structured_data_raw.get("meals", [])
                ]
            
            structured_data = StructuredData(
                meals=meals,
                recipes=structured_data_raw.get("recipes")
            )

        return MessageResponse(
            message_id=msg_dict.get("message_id"),
            thread_id=msg_dict.get("thread_id"),
            role=msg_dict.get("role"),
            content=msg_dict.get("content"),
            created_at=msg_dict.get("created_at"),
            metadata=metadata,
            follow_ups=follow_ups,
            structured_data=structured_data
        )

    @staticmethod
    def build_message_list(messages: List[dict]) -> List[MessageResponse]:
        """
        Build a list of MessageResponse objects from message dictionaries.

        Args:
            messages: List of message dictionaries

        Returns:
            List of MessageResponse objects
        """
        return [
            ChatResponseBuilder.build_message_response(msg)
            for msg in messages
        ]

    @staticmethod
    def build_thread_with_messages(
        thread_data: dict,
        messages: Optional[List[dict]] = None
    ) -> dict:
        """
        Build thread response with properly formatted messages.

        Args:
            thread_data: Thread dictionary data
            messages: Optional list of message dictionaries

        Returns:
            Thread data with formatted messages
        """
        result = thread_data.copy()

        # Convert messages if provided
        if messages:
            result["messages"] = ChatResponseBuilder.build_message_list(messages)
        elif "messages" in result and isinstance(result["messages"], list):
            # Convert existing messages in thread_data
            result["messages"] = ChatResponseBuilder.build_message_list(
                result["messages"]
            )

        return result
</file>

<file path="src/api/mappers/daily_meal_mapper.py">
"""
Mapper for daily meal suggestion DTOs and domain models.
"""
from datetime import date
from typing import Dict, Any

from src.api.schemas.request import UserPreferencesRequest
from src.api.schemas.response import (
    SuggestedMealResponse,
    DailyMealSuggestionsResponse,
    NutritionTotalsResponse
)
from src.domain.model.meal_planning import PlannedMeal, MealType
from src.domain.model.meal_planning import SimpleMacroTargets


class DailyMealMapper:
    """Mapper for daily meal suggestions."""
    
    @staticmethod
    def map_user_preferences_to_dict(request: UserPreferencesRequest) -> Dict[str, Any]:
        """
        Convert UserPreferencesRequest to dictionary for domain service.
        
        Args:
            request: User preferences from API request
            
        Returns:
            Dictionary with user preferences for domain service
        """
        # Build target_macros from individual fields if any are provided
        target_macros = None
        if any([request.target_protein, request.target_carbs, request.target_fat]):
            target_macros = {
                "protein": request.target_protein,
                "carbs": request.target_carbs,
                "fat": request.target_fat
            }
        
        return {
            "age": request.age,
            "gender": request.gender,
            "height": request.height,
            "weight": request.weight,
            "activity_level": request.activity_level,
            "goal": request.goal,
            "dietary_preferences": request.dietary_preferences or [],
            "health_conditions": request.health_conditions or [],
            "target_calories": request.target_calories,
            "target_macros": target_macros
        }
    
    @staticmethod
    def map_planned_meal_to_schema(meal: PlannedMeal) -> SuggestedMealResponse:
        """
        Convert PlannedMeal domain model to SuggestedMealSchema.
        
        Args:
            meal: PlannedMeal domain model
            
        Returns:
            SuggestedMealSchema DTO
        """
        # Extract preparation time components
        prep_time = meal.preparation_time.get("prep", 0) if meal.preparation_time else 0
        cook_time = meal.preparation_time.get("cook", 0) if meal.preparation_time else 0
        total_time = meal.preparation_time.get("total", prep_time + cook_time) if meal.preparation_time else prep_time + cook_time
        
        # Extract dietary tags
        tags = meal.tags or []
        is_vegetarian = "vegetarian" in tags
        is_vegan = "vegan" in tags
        is_gluten_free = "gluten-free" in tags
        
        # Extract cuisine type
        cuisine_type = None
        for tag in tags:
            if tag not in ["vegetarian", "vegan", "gluten-free", "high-protein", "low-carb"]:
                cuisine_type = tag
                break
        
        return SuggestedMealResponse(
            meal_id=meal.id,
            meal_type=meal.meal_type.value,
            name=meal.name,
            description=meal.description,
            prep_time=prep_time,
            cook_time=cook_time,
            total_time=total_time,
            calories=int(meal.calories),
            protein=meal.protein,
            carbs=meal.carbs,
            fat=meal.fat,
            ingredients=meal.ingredients,
            instructions=meal.instructions or [],
            is_vegetarian=is_vegetarian,
            is_vegan=is_vegan,
            is_gluten_free=is_gluten_free,
            cuisine_type=cuisine_type
        )
    
    @staticmethod
    def map_handler_response_to_dto(
        handler_response: Dict[str, Any],
        target_calories: float,
        target_macros: SimpleMacroTargets
    ) -> DailyMealSuggestionsResponse:
        """
        Convert handler response dictionary to DailyMealSuggestionsResponse.
        
        Args:
            handler_response: Response from daily meal suggestion handler
            target_calories: Target calories for the user
            target_macros: Target macros for the user
            
        Returns:
            DailyMealSuggestionsResponse DTO
        """
        # Map meals
        meals = []
        for meal_dict in handler_response.get("meals", []):
            # Convert meal_type string to enum
            meal_type_str = meal_dict["meal_type"]
            meal_type = MealType(meal_type_str) if isinstance(meal_type_str, str) else meal_type_str
            
            # Create PlannedMeal from dict for easier mapping
            meal = PlannedMeal(
                meal_type=meal_type,
                name=meal_dict["name"],
                description=meal_dict["description"],
                calories=meal_dict["calories"],
                protein=meal_dict["protein"],
                carbs=meal_dict["carbs"],
                fat=meal_dict["fat"],
                prep_time=meal_dict.get("prep_time", 0),
                cook_time=meal_dict.get("cook_time", 0),
                ingredients=meal_dict["ingredients"],
                instructions=meal_dict.get("instructions", []),
                is_vegetarian=meal_dict.get("is_vegetarian", False),
                is_vegan=meal_dict.get("is_vegan", False),
                is_gluten_free=meal_dict.get("is_gluten_free", False),
                cuisine_type=meal_dict.get("cuisine_type")
            )
            
            # Set extra attributes for mapper
            meal.id = meal_dict["meal_id"]
            meal.preparation_time = {
                "prep": meal_dict.get("prep_time", 0),
                "cook": meal_dict.get("cook_time", 0),
                "total": meal_dict.get("total_time", 0)
            }
            
            # Build tags from dietary flags
            tags = []
            if meal_dict.get("is_vegetarian"):
                tags.append("vegetarian")
            if meal_dict.get("is_vegan"):
                tags.append("vegan")
            if meal_dict.get("is_gluten_free"):
                tags.append("gluten-free")
            if meal_dict.get("cuisine_type"):
                tags.append(meal_dict["cuisine_type"])
            meal.tags = tags
            
            meals.append(DailyMealMapper.map_planned_meal_to_schema(meal))
        
        # Map nutrition totals
        daily_totals_dict = handler_response.get("daily_totals", {})
        daily_totals = NutritionTotalsResponse(
            calories=daily_totals_dict.get("calories", 0),
            protein=daily_totals_dict.get("protein", 0),
            carbs=daily_totals_dict.get("carbs", 0),
            fat=daily_totals_dict.get("fat", 0)
        )
        
        target_totals = NutritionTotalsResponse(
            calories=target_calories,
            protein=target_macros.protein,
            carbs=target_macros.carbs,
            fat=target_macros.fat
        )
        
        return DailyMealSuggestionsResponse(
            date=handler_response.get("date", date.today().isoformat()),
            meal_count=handler_response.get("meal_count", len(meals)),
            meals=meals,
            daily_totals=daily_totals,
            target_totals=target_totals
        )
    
    @staticmethod
    def map_to_suggestions_response(result: Dict[str, Any]) -> DailyMealSuggestionsResponse:
        """
        Map handler result to suggestions response.
        
        Args:
            result: Result from handler with meals and targets
            
        Returns:
            DailyMealSuggestionsResponse DTO
        """
        target_calories = result.get('target_calories')
        if not target_calories:
            raise ValueError("target_calories is required in result data. Ensure handler provides calculated TDEE data.")
        
        target_macros = result.get('target_macros')
        if not target_macros:
            raise ValueError("target_macros is required in result data. Ensure handler provides calculated TDEE macros.")
        
        # Convert macros dict to SimpleMacroTargets if needed
        if target_macros and hasattr(target_macros, 'protein'):
            # It's already a SimpleMacroTargets object
            pass
        elif isinstance(target_macros, dict):
            # Convert dict to SimpleMacroTargets object
            from src.domain.model.meal_planning import SimpleMacroTargets
            target_macros = SimpleMacroTargets(
                protein=target_macros.get('protein', 0.0),
                carbs=target_macros.get('carbs', 0.0),
                fat=target_macros.get('fat', 0.0)
            )
        else:
            raise ValueError("target_macros must be a dict or SimpleMacroTargets object with actual TDEE calculation data.")
        
        return DailyMealMapper.map_handler_response_to_dto(
            result,
            target_calories,
            target_macros
        )
    
    @staticmethod
    def map_to_single_meal_response(result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Map handler result to single meal response.
        
        Args:
            result: Result from handler with single meal
            
        Returns:
            Dictionary with meal data for SingleMealSuggestionResponse
        """
        return {"meal": result.get("meal", {})}
</file>

<file path="src/api/mappers/meal_mapper.py">
"""
Mapper for meal-related DTOs and domain models.
"""
from typing import List, Optional

from src.api.schemas.response import (
    SimpleMealResponse,
    DetailedMealResponse,
    MealListResponse,
    FoodItemResponse,
    NutritionResponse
)
from src.api.schemas.response.daily_nutrition_response import DailyNutritionResponse
from src.domain.model.meal import Meal
from src.domain.model.nutrition import FoodItem, Nutrition, Macros, Micros

# Status mapping from domain to API
STATUS_MAPPING = {
    "PROCESSING": "pending",
    "ANALYZING": "analyzing", 
    "ENRICHING": "analyzing",
    "READY": "ready",
    "FAILED": "failed"
}


class MealMapper:
    """Mapper for meal data transformation."""
    
    @staticmethod
    def to_simple_response(meal: Meal) -> SimpleMealResponse:
        """
        Convert Meal domain model to SimpleMealResponse DTO.
        
        Args:
            meal: Meal domain model
            
        Returns:
            SimpleMealResponse DTO
        """
        return SimpleMealResponse(
            meal_id=meal.meal_id,
            status=STATUS_MAPPING.get(meal.status.value, meal.status.value.lower()),
            dish_name=meal.dish_name,
            ready_at=meal.ready_at,
            error_message=meal.error_message,
            created_at=meal.created_at
        )
    
    @staticmethod
    def to_detailed_response(meal: Meal, image_url: Optional[str] = None) -> DetailedMealResponse:
        """
        Convert Meal domain model to DetailedMealResponse DTO.
        
        Args:
            meal: Meal domain model
            image_url: Optional image URL
            
        Returns:
            DetailedMealResponse DTO
        """
        from src.api.schemas.response.meal_responses import MacrosResponse
        
        # Map food items from nutrition if available
        food_items = []
        total_calories = 0
        total_nutrition = None
        
        if meal.nutrition:
            total_calories = meal.nutrition.calories
            
            # Map total nutrition macros
            if hasattr(meal.nutrition, 'macros') and meal.nutrition.macros:
                total_nutrition = MacrosResponse(
                    protein=meal.nutrition.macros.protein,
                    carbs=meal.nutrition.macros.carbs,
                    fat=meal.nutrition.macros.fat,
                )
            # Handle legacy structure where nutrition has direct properties
            elif hasattr(meal.nutrition, 'protein'):
                total_nutrition = MacrosResponse(
                    protein=meal.nutrition.protein,
                    carbs=meal.nutrition.carbs,
                    fat=meal.nutrition.fat,
                )
            
            # Map food items
            if meal.nutrition.food_items:
                from src.api.schemas.response.meal_responses import CustomNutritionResponse
                for item in meal.nutrition.food_items:
                    nutrition_dto = None
                    if hasattr(item, 'macros') and item.macros:
                        nutrition_dto = NutritionResponse(
                            nutrition_id=str(item.name),  # Use name as ID since FoodItem doesn't have ID
                            calories=item.calories,
                            protein_g=item.macros.protein,
                            carbs_g=item.macros.carbs,
                            fat_g=item.macros.fat,
                            sugar_g=None,
                            sodium_mg=None
                        )
                    
                    # Calculate per-100g custom nutrition if this is a custom ingredient or has no fdc_id
                    custom_nutrition_dto = None
                    if hasattr(item, 'is_custom') and item.is_custom and item.quantity > 0:
                        # Calculate per-100g values from absolute values
                        scale_factor = 100.0 / item.quantity
                        custom_nutrition_dto = CustomNutritionResponse(
                            calories_per_100g=item.calories * scale_factor,
                            protein_per_100g=item.macros.protein * scale_factor if item.macros else 0.0,
                            carbs_per_100g=item.macros.carbs * scale_factor if item.macros else 0.0,
                            fat_per_100g=item.macros.fat * scale_factor if item.macros else 0.0,
                        )
                    
                    food_item_dto = FoodItemResponse(
                        id=str(item.id),  # Use the primary key ID as string
                        name=item.name,
                        category=None,
                        quantity=item.quantity,
                        unit=item.unit,
                        description=None,
                        nutrition=nutrition_dto,
                        custom_nutrition=custom_nutrition_dto,
                        fdc_id=getattr(item, 'fdc_id', None),
                        is_custom=getattr(item, 'is_custom', False)
                    )
                    food_items.append(food_item_dto)
        
        return DetailedMealResponse(
            meal_id=meal.meal_id,
            status=STATUS_MAPPING.get(meal.status.value, meal.status.value.lower()),
            dish_name=meal.dish_name,
            ready_at=meal.ready_at,
            error_message=meal.error_message,
            created_at=meal.created_at,
            updated_at=None,  # Meal domain model doesn't have updated_at
            food_items=food_items,
            image_url=image_url,
            total_calories=total_calories,
            total_weight_grams=meal.weight_grams if hasattr(meal, 'weight_grams') else None,
            total_nutrition=total_nutrition
        )
    
    @staticmethod
    def to_meal_list_response(
        meals: List[Meal], 
        total: int,
        page: int = 1,
        page_size: int = 10,
        image_urls: Optional[dict] = None
    ) -> MealListResponse:
        """
        Convert list of Meal domain models to MealListResponse DTO.
        
        Args:
            meals: List of Meal domain models
            total: Total count of meals
            page: Current page number
            page_size: Items per page
            image_urls: Optional dict mapping meal_id to image URLs
            
        Returns:
            MealListResponse DTO
        """
        image_urls = image_urls or {}
        
        meal_responses = []
        for meal in meals:
            if meal.nutrition and meal.nutrition.food_items:  # Has detailed info
                response = MealMapper.to_detailed_response(
                    meal, 
                    image_urls.get(meal.meal_id)
                )
            else:  # Simple response
                response = MealMapper.to_simple_response(meal)
            meal_responses.append(response)
        
        return MealListResponse(
            meals=meal_responses,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=(total + page_size - 1) // page_size
        )
    
    @staticmethod
    def map_nutrition_from_dict(nutrition_dict: dict) -> Nutrition:
        """
        Create Nutrition domain model from dictionary.
        
        Args:
            nutrition_dict: Dictionary with nutrition data
            
        Returns:
            Nutrition domain model
        """
        macros = Macros(
            protein=nutrition_dict.get("protein_g", 0),
            carbs=nutrition_dict.get("carbs_g", 0),
            fat=nutrition_dict.get("fat_g", 0)
        )
        
        micros = None
        if "sodium_mg" in nutrition_dict:
            micros = Micros(
                sodium=nutrition_dict.get("sodium_mg", 0)
            )
        
        return Nutrition(
            calories=nutrition_dict.get("calories", 0),
            macros=macros,
            micros=micros,
            food_items=[]
        )
    
    @staticmethod
    def map_food_item_from_dict(item_dict: dict) -> FoodItem:
        """
        Create FoodItem domain model from dictionary.
        
        Args:
            item_dict: Dictionary with food item data
            
        Returns:
            FoodItem domain model
        """
        # Extract calories and macros from nutrition dict if present
        calories = item_dict.get("calories", 0)
        macros = Macros(protein=0, carbs=0, fat=0)
        micros = None
        
        if "nutrition" in item_dict and item_dict["nutrition"]:
            nutrition_data = item_dict["nutrition"]
            calories = nutrition_data.get("calories", 0)
            macros = Macros(
                protein=nutrition_data.get("protein_g", 0),
                carbs=nutrition_data.get("carbs_g", 0),
                fat=nutrition_data.get("fat_g", 0)
            )
            if "sodium_mg" in nutrition_data:
                micros = Micros(sodium=nutrition_data.get("sodium_mg", 0))
        
        return FoodItem(
            id=item_dict.get("id", ""),
            name=item_dict.get("name", ""),
            quantity=item_dict.get("quantity", 0),
            unit=item_dict.get("unit", ""),
            calories=calories,
            macros=macros,
            micros=micros,
            confidence=item_dict.get("confidence", 1.0),
            fdc_id=item_dict.get("fdc_id"),
            is_custom=item_dict.get("is_custom", False)
        )
    
    @staticmethod
    def to_daily_nutrition_response(daily_macros_data: dict) -> DailyNutritionResponse:
        """
        Convert daily macros query result to DailyNutritionResponse DTO.
        
        Args:
            daily_macros_data: Dictionary with daily macros data from query
            
        Returns:
            DailyNutritionResponse DTO
        """
        from src.api.schemas.response.daily_nutrition_response import MacrosResponse
        from src.api.exceptions import ResourceNotFoundException
        
        # Extract data - require actual user targets, no hardcoded defaults
        target_calories = daily_macros_data.get("target_calories")
        if not target_calories:
            raise ResourceNotFoundException(
                message="User profile not found or incomplete. Please complete onboarding first.",
                error_code="TDEE_DATA_NOT_FOUND",
                details={
                    "user_id": daily_macros_data.get("user_id"),
                    "reason": "User has not completed onboarding or TDEE calculation is missing"
                }
            )
        
        target_macros = MacrosResponse(
            protein=daily_macros_data.get("target_macros").get("protein") or 0.0,
            carbs=daily_macros_data.get("target_macros").get("carbs") or 0.0, 
            fat=daily_macros_data.get("target_macros").get("fat") or 0.0,
        )
        
        consumed_macros = MacrosResponse(
            protein=daily_macros_data.get("total_protein", 0.0),
            carbs=daily_macros_data.get("total_carbs", 0.0),
            fat=daily_macros_data.get("total_fat", 0.0),
        )

        consumed_calories = daily_macros_data.get("total_calories", 0.0)

        # Calculate remaining macros
        remaining_calories = max(0, target_calories - consumed_calories)
        remaining_macros = MacrosResponse(
            protein=max(0, target_macros.protein - consumed_macros.protein),
            carbs=max(0, target_macros.carbs - consumed_macros.carbs),
            fat=max(0, target_macros.fat - consumed_macros.fat),
        )
        
        # Calculate completion percentages
        completion_percentage = {
            "calories": (consumed_calories / target_calories * 100) if target_calories > 0 else 0,
            "protein": (consumed_macros.protein / target_macros.protein * 100) if target_macros.protein > 0 else 0,
            "carbs": (consumed_macros.carbs / target_macros.carbs * 100) if target_macros.carbs > 0 else 0,
            "fat": (consumed_macros.fat / target_macros.fat * 100) if target_macros.fat > 0 else 0
        }
        
        return DailyNutritionResponse(
            date=daily_macros_data.get("date", ""),
            target_calories=target_calories,
            target_macros=target_macros,
            consumed_calories=consumed_calories,
            consumed_macros=consumed_macros,
            remaining_calories=remaining_calories,
            remaining_macros=remaining_macros,
            completion_percentage=completion_percentage,
        )
</file>

<file path="src/api/mappers/meal_suggestion_mapper.py">
"""Mappers for meal suggestion domain to API responses."""

from typing import List

from src.domain.model.meal_suggestion import MealSuggestion, SuggestionSession
from src.api.schemas.response.meal_suggestion_responses import (
    MealSuggestionResponse,
    MacroEstimateResponse,
    IngredientResponse,
    RecipeStepResponse,
    SuggestionsListResponse,
    AcceptedMealResponse,
)


def to_meal_suggestion_response(suggestion: MealSuggestion) -> MealSuggestionResponse:
    """Convert domain MealSuggestion to API response."""
    return MealSuggestionResponse(
        id=suggestion.id,
        meal_name=suggestion.meal_name,
        description=suggestion.description,
        macros=MacroEstimateResponse(
            calories=suggestion.macros.calories,
            protein=suggestion.macros.protein,
            carbs=suggestion.macros.carbs,
            fat=suggestion.macros.fat,
        ),
        ingredients=[
            IngredientResponse(
                name=ing.name,
                amount=ing.amount,
                unit=ing.unit,
            )
            for ing in suggestion.ingredients
        ],
        recipe_steps=[
            RecipeStepResponse(
                step=step.step,
                instruction=step.instruction,
                duration_minutes=step.duration_minutes,
            )
            for step in suggestion.recipe_steps
        ],
        prep_time_minutes=suggestion.prep_time_minutes,
        confidence_score=suggestion.confidence_score,
    )


def to_suggestions_list_response(
    session: SuggestionSession,
    suggestions: List[MealSuggestion],
) -> SuggestionsListResponse:
    """Convert session + suggestions to API response."""
    return SuggestionsListResponse(
        session_id=session.id,
        meal_type=session.meal_type,
        meal_portion_type=session.meal_portion_type,
        target_calories=session.target_calories,
        suggestions=[to_meal_suggestion_response(s) for s in suggestions],
        suggestion_count=len(suggestions),
        expires_at=session.expires_at,
    )


def to_accepted_meal_response(result: dict) -> AcceptedMealResponse:
    """Convert acceptance result to API response."""
    return AcceptedMealResponse(
        meal_id=result["meal_id"],
        meal_name=result["meal_name"],
        macros=MacroEstimateResponse(
            calories=result["adjusted_macros"].calories,
            protein=result["adjusted_macros"].protein,
            carbs=result["adjusted_macros"].carbs,
            fat=result["adjusted_macros"].fat,
        ),
        saved_at=result["saved_at"],
    )
</file>

<file path="src/api/middleware/premium_check.py">
"""
Premium access validation middleware.

Uses RevenueCat as source of truth, with local cache for performance.
"""
import logging
import os

from fastapi import Request, HTTPException, status

from src.domain.services.revenuecat_service import RevenueCatService

logger = logging.getLogger(__name__)


async def require_premium(request: Request):
    """
    Dependency that requires active premium subscription.
    
    Strategy:
    1. Check local database cache first (fast)
    2. If no cache, verify with RevenueCat API (accurate)
    
    Usage:
        @router.get("/premium-feature", dependencies=[Depends(require_premium)])
        async def premium_feature():
            return {"data": "premium content"}
    """
    user = getattr(request.state, 'user', None)
    
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication required"
        )
    
    # Quick check: Local database cache
    if user.is_premium():
        logger.debug(f"User {user.id} has cached premium subscription")
        return
    
    # No local subscription - verify with RevenueCat (source of truth)
    logger.info(f"User {user.id} has no cached subscription, checking RevenueCat")
    
    revenuecat_secret_key = os.getenv("REVENUECAT_SECRET_API_KEY", "")
    if not revenuecat_secret_key:
        logger.warning("REVENUECAT_SECRET_API_KEY not configured")
        raise HTTPException(
            status_code=status.HTTP_402_PAYMENT_REQUIRED,
            detail={
                "message": "Premium subscription required",
                "error_code": "PREMIUM_REQUIRED"
            }
        )
    
    revenuecat = RevenueCatService(revenuecat_secret_key)
    is_premium = await revenuecat.is_premium_active(app_user_id=user.id)
    
    if is_premium:
        # User has premium in RevenueCat but not in local cache
        # This can happen if webhook failed or is delayed
        logger.warning(f"User {user.id} has premium in RevenueCat but not in cache")
        # Allow access - webhook will sync eventually
        return
    
    # User does not have premium access
    raise HTTPException(
        status_code=status.HTTP_402_PAYMENT_REQUIRED,
        detail={
            "message": "Premium subscription required",
            "error_code": "PREMIUM_REQUIRED"
        }
    )


async def get_premium_status(request: Request) -> dict:
    """
    Non-blocking premium check that returns status info.
    
    Usage:
        @router.get("/feature")
        async def feature(premium_info: dict = Depends(get_premium_status)):
            if premium_info["is_premium"]:
                return {"data": "premium"}
            else:
                return {"data": "basic"}
    """
    user = getattr(request.state, 'user', None)
    
    if not user:
        return {
            "is_premium": False,
            "subscription": None,
            "source": "no_user"
        }
    
    # Check local cache
    subscription = user.get_active_subscription()
    
    if subscription:
        return {
            "is_premium": True,
            "subscription": {
                "product_id": subscription.product_id,
                "expires_at": subscription.expires_at.isoformat() if subscription.expires_at else None,
                "is_monthly": subscription.is_monthly(),
                "is_yearly": subscription.is_yearly()
            },
            "source": "cache"
        }
    
    # Check RevenueCat if configured
    revenuecat_secret_key = os.getenv("REVENUECAT_SECRET_API_KEY", "")
    if revenuecat_secret_key:
        revenuecat = RevenueCatService(revenuecat_secret_key)
        sub_info = await revenuecat.get_subscription_info(user.id)
        
        if sub_info:
            return {
                "is_premium": True,
                "subscription": sub_info,
                "source": "revenuecat_api"
            }
    
    return {
        "is_premium": False,
        "subscription": None,
        "source": "none"
    }
</file>

<file path="src/api/routes/v1/activities.py">
"""
Activities API endpoints - Event-driven architecture.
"""

from datetime import datetime
from typing import List, Dict, Optional

from fastapi import APIRouter, Depends, Query

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import ValidationException, handle_exception
from src.app.queries.activity import GetDailyActivitiesQuery
from src.infra.event_bus import EventBus

router = APIRouter(
    prefix="/v1/activities",
    tags=["activities"],
)


@router.get("/daily", response_model=None)
async def get_daily_activities(
    user_id: str = Depends(get_current_user_id),
    date: Optional[str] = Query(
        None, description="Date in YYYY-MM-DD format, defaults to today"
    ),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    Get all activities (meals and workouts) for a specific date.

    Returns a unified list of activities including:
    - Meal activities with nutrition data
    - Workout activities (placeholder for future implementation)

    Activities are sorted by timestamp in descending order (newest first).

    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Parse and validate date
        if date:
            try:
                target_date = datetime.strptime(date, "%Y-%m-%d")
            except ValueError as e:
                raise ValidationException("Invalid date format. Use YYYY-MM-DD") from e
        else:
            target_date = datetime.now()

        # Send query
        query = GetDailyActivitiesQuery(user_id=user_id, target_date=target_date)
        activities = await event_bus.send(query)

        return activities

    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/api/routes/v1/chat_ws.py">
"""
WebSocket endpoint for real-time chat.
"""
import json
import logging

from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Query, Depends, status
from fastapi.exceptions import WebSocketException
from firebase_admin import auth as firebase_auth

from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import ResourceNotFoundException
from src.app.queries.chat import GetThreadQuery
from src.infra.database.config import get_db
from src.infra.event_bus import EventBus
from src.infra.websocket.connection_manager import chat_connection_manager

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/v1/chat", tags=["Chat WebSocket"])


async def verify_firebase_token_and_get_user_id(token: str) -> str:
    """
    Verify Firebase token and return the authenticated user's database ID.
    
    Args:
        token: Firebase ID token string
        
    Returns:
        The authenticated user's database ID (UUID)
        
    Raises:
        WebSocketException: If token is invalid, expired, or user not found
    """
    try:
        # Verify the Firebase ID token
        decoded_token = firebase_auth.verify_id_token(token)
        firebase_uid = decoded_token.get("uid")
        
        if not firebase_uid:
            logger.error("Firebase token missing 'uid' field")
            raise WebSocketException(
                code=status.WS_1008_POLICY_VIOLATION,
                reason="Invalid token: missing user identifier"
            )
        
        # Look up user in database by firebase_uid (only active users)
        from src.infra.database.models.user.user import User
        db = next(get_db())
        try:
            user = db.query(User).filter(
                User.firebase_uid == firebase_uid,
                User.is_active == True  # CRITICAL: Block deleted/inactive users
            ).first()
            
            if not user:
                logger.warning(f"Active user with Firebase UID {firebase_uid} not found in database")
                raise WebSocketException(
                    code=status.WS_1008_POLICY_VIOLATION,
                    reason="User not found or account has been deleted"
                )
            
            return user.id
        finally:
            db.close()
            
    except WebSocketException:
        raise
    except firebase_auth.ExpiredIdTokenError as e:
        logger.warning(f"Expired Firebase token: {e}")
        raise WebSocketException(
            code=status.WS_1008_POLICY_VIOLATION,
            reason="Authentication token has expired"
        ) from e
    except firebase_auth.RevokedIdTokenError as e:
        logger.warning(f"Revoked Firebase token: {e}")
        raise WebSocketException(
            code=status.WS_1008_POLICY_VIOLATION,
            reason="Authentication token has been revoked"
        ) from e
    except firebase_auth.InvalidIdTokenError as e:
        logger.warning(f"Invalid Firebase token: {e}")
        raise WebSocketException(
            code=status.WS_1008_POLICY_VIOLATION,
            reason="Invalid authentication token"
        ) from e
    except Exception as e:
        logger.error(f"Error verifying Firebase token: {e}")
        raise WebSocketException(
            code=status.WS_1011_INTERNAL_ERROR,
            reason="Failed to verify authentication token"
        ) from e


async def verify_thread_access(thread_id: str, user_id: str, event_bus: EventBus) -> bool:
    """Verify user has access to thread."""
    try:
        query = GetThreadQuery(thread_id=thread_id, user_id=user_id)
        await event_bus.send(query)
        return True
    except (ResourceNotFoundException, Exception) as e:
        logger.warning(f"Thread access denied for user {user_id}, thread {thread_id}: {e}")
        return False


@router.websocket("/ws/{thread_id}")
async def chat_websocket(
    websocket: WebSocket,
    thread_id: str,
    token: str = Query(...),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    WebSocket endpoint for real-time chat.
    
    Connection URL: ws://localhost:8000/v1/chat/ws/{thread_id}?token={firebase_token}
    
    The Firebase token is validated and the user_id is extracted from it.
    The user_id is NOT accepted as a query parameter for security reasons.
    
    Message Types (Incoming):
    - ping: Keep-alive ping
    - typing: User is typing indicator
    
    Message Types (Outgoing):
    - message_complete: New message received
    - message_chunk: Streaming message chunk (AI response)
    - typing_indicator: Someone is typing
    - error: Error occurred
    - pong: Response to ping
    """
    user_id = None
    
    try:
        # Validate Firebase token and extract user_id
        user_id = await verify_firebase_token_and_get_user_id(token)
        logger.info(f"WebSocket authentication successful for user {user_id}, thread {thread_id}")
        
        # Verify user has access to thread (if event_bus is available)
        if event_bus:
            has_access = await verify_thread_access(thread_id, user_id, event_bus)
            if not has_access:
                raise WebSocketException(
                    code=status.WS_1008_POLICY_VIOLATION,
                    reason="Access denied to this thread"
                )
        
        # Connect to manager
        await chat_connection_manager.connect(websocket, thread_id, user_id)
        
        # Send connection confirmation
        await websocket.send_json({
            "type": "connected",
            "thread_id": thread_id,
            "message": "Connected to chat thread"
        })
        
        # Listen for incoming messages
        while True:
            try:
                data = await websocket.receive_text()
                message = json.loads(data)
                
                message_type = message.get("type")
                
                if message_type == "ping":
                    # Respond to ping
                    await websocket.send_json({"type": "pong"})
                
                elif message_type == "typing":
                    # Broadcast typing indicator to other users
                    is_typing = message.get("is_typing", False)
                    await chat_connection_manager.broadcast_typing_indicator(
                        thread_id, is_typing
                    )
                
                else:
                    logger.warning(f"Unknown message type: {message_type}")
            
            except json.JSONDecodeError:
                await websocket.send_json({
                    "type": "error",
                    "message": "Invalid JSON format"
                })
            
            except WebSocketDisconnect:
                break
            
            except Exception as e:
                logger.error(f"Error processing WebSocket message: {e}")
                await websocket.send_json({
                    "type": "error",
                    "message": str(e)
                })
    
    except WebSocketException:
        # Re-raise WebSocket exceptions (authentication/authorization errors)
        raise
    except Exception as e:
        logger.error(f"WebSocket error: {e}")
        raise WebSocketException(code=status.WS_1011_INTERNAL_ERROR, reason=str(e))
    
    finally:
        # Cleanup on disconnect (only if user_id was successfully authenticated)
        if user_id:
            await chat_connection_manager.disconnect(websocket, thread_id, user_id)
            logger.info(f"WebSocket closed for thread {thread_id}, user {user_id}")
</file>

<file path="src/api/routes/v1/meal_plans.py">
"""
Meal planning API endpoints - Event-driven architecture.
"""
from datetime import date

from fastapi import APIRouter, Depends, Query

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request import (
    IngredientBasedMealPlanRequest
)
from src.api.schemas.response import (
    MealsByDateResponse,
    MealPlanGenerationStatusResponse
)
from src.app.commands.meal_plan import (
    GenerateWeeklyIngredientBasedMealPlanCommand,
)
from src.app.queries.meal_plan import (
    GetMealPlanQuery,
    GetMealsFromPlanByDateQuery
)
from src.infra.event_bus import EventBus

router = APIRouter(prefix="/v1/meal-plans", tags=["Meal Planning"])


@router.post("/generate/weekly-ingredient-based", response_model=MealPlanGenerationStatusResponse)
async def generate_weekly_ingredient_based_meal_plan(
    request: IngredientBasedMealPlanRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Generate a weekly meal plan based on provided ingredients and user preferences.
    
    This endpoint generates a comprehensive weekly meal plan using the ingredients provided
    in the request body, combined with the user's profile, preferences, and goals.
    
    The system generates the meal plan in the background and returns a simple success status,
    allowing the frontend to show a loading screen and navigate to the home screen once complete.
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Generate weekly meal plan using ingredients from request
        command = GenerateWeeklyIngredientBasedMealPlanCommand(
            user_id=user_id,
            available_ingredients=request.available_ingredients,
            available_seasonings=request.available_seasonings
        )
        
        # Execute the command - this generates the full meal plan and saves it to the database
        await event_bus.send(command)
        
        # Return simple status response instead of full meal plan data
        return MealPlanGenerationStatusResponse(
            success=True,
            message="Weekly meal plan generated successfully!",
            user_id=user_id
        )
        
    except Exception as e:
        raise handle_exception(e) from e


@router.get("/{plan_id}")
async def get_meal_plan(
    plan_id: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """Get an existing meal plan."""
    try:
        # Create query
        query = GetMealPlanQuery(plan_id=plan_id)
        
        # Send query
        result = await event_bus.send(query)
        
        return result["meal_plan"]
    except Exception as e:
        raise handle_exception(e) from e


# Query meals by date
@router.get("/meals/by-date", response_model=MealsByDateResponse)
async def get_meals_by_date(
    meal_date: date = Query(..., description="Date to get meals for (YYYY-MM-DD format)"),
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get meals for a specific date.
    
    Retrieves all meals planned for the specified date. Can optionally filter by meal type.
    This endpoint searches through all stored meal plans (both daily and weekly) to find
    meals that match the requested date.
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    
    Parameters:
    - meal_date: The specific date to retrieve meals for (YYYY-MM-DD format)
    - meal_type: Optional filter to only return specific meal type (breakfast, lunch, dinner, snack)
    """
    try:
        # Create query for planned meals by date
        query = GetMealsFromPlanByDateQuery(
            user_id=user_id,
            meal_date=meal_date,
        )

        # Send query - returns dict matching MealsByDateResponse
        result = await event_bus.send(query)

        return MealsByDateResponse(**result)
    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/api/routes/v1/meal_suggestions.py">
"""
Meal suggestion API endpoints (Phase 06).
Includes both legacy endpoints and new session-based endpoints.
"""

from datetime import date, datetime

from fastapi import APIRouter, Depends, status

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request.meal_suggestion_requests import (
    MealSuggestionRequest,
    SaveMealSuggestionRequest,
    RegenerateSuggestionsRequest,
    AcceptSuggestionRequest,
    RejectSuggestionRequest,
)
from src.api.schemas.response.meal_suggestion_responses import (
    SaveMealSuggestionResponse,
    SuggestionsListResponse,
    AcceptedMealResponse,
)
from src.api.mappers.meal_suggestion_mapper import (
    to_suggestions_list_response,
    to_accepted_meal_response,
)
from src.app.commands.meal_suggestion import (
    GenerateMealSuggestionsCommand,
    SaveMealSuggestionCommand,
    RegenerateSuggestionsCommand,
    AcceptSuggestionCommand,
    RejectSuggestionCommand,
    DiscardSessionCommand,
)
from src.app.queries.meal_suggestion import GetSessionSuggestionsQuery
from src.infra.event_bus import EventBus

router = APIRouter(prefix="/v1/meal-suggestions", tags=["Meal Suggestions"])


@router.post("/save", response_model=SaveMealSuggestionResponse)
async def save_meal_suggestion(
    request: SaveMealSuggestionRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    Save a selected meal suggestion to the user's meal history.

    This endpoint saves a meal suggestion to the user's planned meals for a specific date.
    The meal can then be viewed in the user's meal plan and tracked in their daily nutrition.

    Authentication required: User ID is automatically extracted from the Firebase token.

    Parameters:
    - suggestion_id: ID of the suggestion to save - REQUIRED
    - name: Name of the meal - REQUIRED
    - description: Description of the meal - OPTIONAL
    - meal_type: Type of meal (breakfast, lunch, dinner, snack) - REQUIRED
    - estimated_cook_time_minutes: Total cooking time - REQUIRED
    - calories: Calories for the meal - REQUIRED
    - protein: Protein in grams - REQUIRED
    - carbs: Carbohydrates in grams - REQUIRED
    - fat: Fat in grams - REQUIRED
    - ingredients_list: List of ingredients - OPTIONAL
    - instructions: Cooking instructions - OPTIONAL
    - meal_date: Date to save the meal for (YYYY-MM-DD), defaults to today - OPTIONAL

    Returns:
    - success: Whether the save was successful
    - message: Status message
    - meal_id: ID of the saved meal in the database
    - meal_date: Date the meal was saved for
    """
    try:
        # Parse meal date if provided
        meal_date = None
        if request.meal_date:
            try:
                meal_date = datetime.strptime(request.meal_date, "%Y-%m-%d").date()
            except ValueError:
                raise ValueError("meal_date must be in YYYY-MM-DD format")
        else:
            meal_date = date.today()

        # Apply portion multiplier to macros before saving
        multiplier = request.portion_multiplier or 1
        scaled_calories = int(request.calories * multiplier)
        scaled_protein = request.protein * multiplier
        scaled_carbs = request.carbs * multiplier
        scaled_fat = request.fat * multiplier

        # Create command with scaled macros
        command = SaveMealSuggestionCommand(
            user_id=user_id,
            suggestion_id=request.suggestion_id,
            name=request.name,
            description=request.description,
            meal_type=request.meal_type,
            estimated_cook_time_minutes=request.estimated_cook_time_minutes,
            calories=scaled_calories,
            protein=scaled_protein,
            carbs=scaled_carbs,
            fat=scaled_fat,
            ingredients_list=request.ingredients_list,
            instructions=request.instructions,
            meal_date=meal_date,
        )

        # Execute the command
        result = await event_bus.send(command)

        # Return response
        return SaveMealSuggestionResponse(**result)

    except Exception as e:
        raise handle_exception(e) from e


# ============================================================================
# Phase 06: New Session-Based Endpoints
# ============================================================================


@router.post("/generate", response_model=SuggestionsListResponse)
async def generate_suggestions(
    request: MealSuggestionRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    [Phase 06] Generate 3 meal suggestions with session tracking.

    Uses meal_portion_type (snack/main/omad) to calculate target calories from user's TDEE.
    Creates a session that tracks shown suggestions for regeneration.
    Session expires after 4 hours.

    Backward compatible: accepts deprecated meal_size (S/M/L/XL/OMAD) and maps to new types.
    """
    try:
        portion_type = request.get_effective_portion_type()

        command = GenerateMealSuggestionsCommand(
            user_id=user_id,
            meal_type=request.meal_type,
            meal_portion_type=portion_type.value,
            ingredients=request.ingredients,
            time_available_minutes=request.cooking_time_minutes.value,
            exclude_ids=[],
        )

        session, suggestions = await event_bus.send(command)
        return to_suggestions_list_response(session, suggestions)

    except Exception as e:
        raise handle_exception(e) from e


@router.post("/regenerate", response_model=SuggestionsListResponse)
async def regenerate_suggestions(
    request: RegenerateSuggestionsRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    [Phase 06] Regenerate 3 NEW suggestions excluding previously shown.

    Requires session_id from initial generation.
    Excludes all previously shown suggestions plus explicitly passed exclude_ids.
    """
    try:
        command = RegenerateSuggestionsCommand(
            user_id=user_id,
            session_id=request.session_id,
            exclude_ids=request.exclude_ids,
        )

        session, suggestions = await event_bus.send(command)
        return to_suggestions_list_response(session, suggestions)

    except Exception as e:
        raise handle_exception(e) from e


@router.get("/{session_id}", response_model=SuggestionsListResponse)
async def get_session_suggestions(
    session_id: str,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    [Phase 06] Get current session's suggestions.

    Retrieves all suggestions generated in this session.
    Returns 404 if session expired (4h TTL).
    """
    try:
        query = GetSessionSuggestionsQuery(
            user_id=user_id,
            session_id=session_id,
        )

        session, suggestions = await event_bus.send(query)
        return to_suggestions_list_response(session, suggestions)

    except Exception as e:
        raise handle_exception(e) from e


@router.post("/{suggestion_id}/accept", response_model=AcceptedMealResponse)
async def accept_suggestion(
    suggestion_id: str,
    request: AcceptSuggestionRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    [Phase 06] Accept suggestion with portion multiplier (1x-4x).

    Applies portion multiplier to macros and saves to meal history.
    Marks suggestion as accepted.
    """
    try:
        command = AcceptSuggestionCommand(
            user_id=user_id,
            suggestion_id=suggestion_id,
            portion_multiplier=request.portion_multiplier,
            consumed_at=request.consumed_at,
        )

        result = await event_bus.send(command)
        return to_accepted_meal_response(result)

    except Exception as e:
        raise handle_exception(e) from e


@router.post("/{suggestion_id}/reject", status_code=status.HTTP_204_NO_CONTENT)
async def reject_suggestion(
    suggestion_id: str,
    request: RejectSuggestionRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    [Phase 06] Reject suggestion with optional feedback.

    Marks suggestion as rejected. Feedback used for analytics/improvement.
    """
    try:
        command = RejectSuggestionCommand(
            user_id=user_id,
            suggestion_id=suggestion_id,
            feedback=request.feedback if hasattr(request, "feedback") else None,
        )

        await event_bus.send(command)

    except Exception as e:
        raise handle_exception(e) from e


@router.delete("/{session_id}", status_code=status.HTTP_204_NO_CONTENT)
async def discard_session(
    session_id: str,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
):
    """
    [Phase 06] Discard entire suggestion session.

    Deletes session and all associated suggestions from cache.
    Used when user cancels the flow.
    """
    try:
        command = DiscardSessionCommand(
            user_id=user_id,
            session_id=session_id,
        )

        await event_bus.send(command)

    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/api/schemas/request/__init__.py">
"""
Request DTOs for API endpoints.
"""

# Daily meal requests
from .daily_meal_requests import (
    UserPreferencesRequest,
    MealSuggestionFilterRequest,
    MealTypeEnum
)
# Ingredient-based meal plan requests
from .ingredient_based_meal_plan_requests import (
    IngredientBasedMealPlanRequest
)
# Meal suggestion requests
from .meal_suggestion_requests import (
    MealSuggestionRequest,
    SaveMealSuggestionRequest
)
# Meal plan requests
from .meal_plan_requests import (
    UserPreferencesSchema,
    ConversationMessageRequest,
    ReplaceMealRequest
)
# Meal requests
from .meal_requests import (
    CreateMealRequest,
    UpdateMealRequest,
    UpdateMealMacrosRequest,
    MealSearchRequest,
    AnalyzeMealImageRequest,
    MacrosRequest
)
# Onboarding requests
from .onboarding_requests import (
    OnboardingCompleteRequest
)
# TDEE requests
from .tdee_requests import (
    TdeeCalculationRequest,
    BatchTdeeCalculationRequest,
    SexEnum,
    ActivityLevelEnum,
    GoalEnum,
    UnitSystemEnum
)
# User requests
from .user_requests import (
    UserSyncRequest,
    UserUpdateLastAccessedRequest,
    UserCreateRequest
)
# Common enums
from ..common.auth_enums import AuthProviderEnum
# Ingredient recognition requests
from .ingredient_recognition_requests import (
    IngredientRecognitionRequest
)

__all__ = [
    # Daily meal
    'UserPreferencesRequest',
    'MealSuggestionFilterRequest',
    'MealTypeEnum',
    
    # Meal
    'CreateMealRequest',
    'UpdateMealRequest',
    'UpdateMealMacrosRequest',
    'MealSearchRequest',
    'AnalyzeMealImageRequest',
    'MacrosRequest',
    
    # TDEE
    'TdeeCalculationRequest',
    'BatchTdeeCalculationRequest',
    'SexEnum',
    'ActivityLevelEnum',
    'GoalEnum',
    'UnitSystemEnum',
    
    # Meal plan
    'UserPreferencesSchema',
    'ConversationMessageRequest',
    'ReplaceMealRequest',
    
    # Ingredient-based meal plan
    'IngredientBasedMealPlanRequest',
    
    # Meal suggestion
    'MealSuggestionRequest',
    'SaveMealSuggestionRequest',
    
    # Onboarding
    'OnboardingCompleteRequest',
    
    # User
    'UserSyncRequest',
    'UserUpdateLastAccessedRequest',
    'UserCreateRequest',
    
    # Common enums
    'AuthProviderEnum',

    # Ingredient recognition
    'IngredientRecognitionRequest'
]
</file>

<file path="src/api/schemas/request/tdee_requests.py">
"""
TDEE calculation request DTOs.
"""
from enum import Enum
from typing import Optional, List

from pydantic import BaseModel, Field, model_validator


class SexEnum(str, Enum):
    """Enum for biological sex."""
    male = "male"
    female = "female"


class ActivityLevelEnum(str, Enum):
    """Enum for activity levels."""
    sedentary = "sedentary"
    light = "light"
    moderate = "moderate"
    active = "active"
    extra = "extra"


class GoalEnum(str, Enum):
    """Enum for fitness goals."""
    cut = "cut"
    bulk = "bulk"
    recomp = "recomp"


class UnitSystemEnum(str, Enum):
    """Enum for unit systems."""
    metric = "metric"
    imperial = "imperial"


class TdeeCalculationRequest(BaseModel):
    """Request DTO for TDEE calculation matching Flutter OnboardingData."""
    age: int = Field(..., ge=13, le=120, description="User age")
    sex: SexEnum = Field(..., description="User biological sex")
    height: float = Field(..., gt=0, description="Height in user's preferred units")
    weight: float = Field(..., gt=0, description="Weight in user's preferred units")
    body_fat_percentage: Optional[float] = Field(
        None, 
        ge=5, 
        le=55, 
        description="Body fat percentage (optional)"
    )
    activity_level: ActivityLevelEnum = Field(..., description="Activity level")
    goal: GoalEnum = Field(..., description="Fitness goal")
    unit_system: UnitSystemEnum = Field(
        UnitSystemEnum.metric, 
        description="Unit system for height/weight"
    )

    @model_validator(mode='after')
    def validate_measurements_with_units(self):
        """Validate height and weight based on unit system."""
        unit_system = self.unit_system
        height = self.height
        weight = self.weight
        
        if height is not None and unit_system is not None:
            if unit_system == UnitSystemEnum.metric:
                if not (100 <= height <= 272):
                    raise ValueError('Height must be between 100-272 cm for metric system')
            else:  # imperial
                if not (39 <= height <= 107):
                    raise ValueError('Height must be between 39-107 inches for imperial system')
        
        if weight is not None and unit_system is not None:
            if unit_system == UnitSystemEnum.metric:
                if not (30 <= weight <= 250):
                    raise ValueError('Weight must be between 30-250 kg for metric system')
            else:  # imperial
                if not (66 <= weight <= 551):
                    raise ValueError('Weight must be between 66-551 lbs for imperial system')
        
        return self
    
    class Config:
        json_schema_extra = {
            "example": {
                "age": 25,
                "sex": "male",
                "height": 180.0,
                "weight": 75.0,
                "body_fat_percentage": 15.0,
                "activity_level": "moderate",
                "goal": "recomp",
                "unit_system": "metric"
            }
        }


class BatchTdeeCalculationRequest(BaseModel):
    """Request DTO for batch TDEE calculations."""
    calculations: List[TdeeCalculationRequest] = Field(
        ..., 
        min_items=1,
        max_items=10,
        description="List of TDEE calculations to perform"
    )
</file>

<file path="src/api/schemas/response/chat_responses.py">
"""
Response schemas for chat endpoints.
"""
from typing import Optional, Dict, Any, List
from pydantic import BaseModel


class FollowUpQuestion(BaseModel):
    """A suggested follow-up question or action."""
    id: str  # Unique identifier for tracking
    text: str  # The question/action text
    type: str  # Type: "question", "recipe", "modify", "alternative"
    metadata: Optional[Dict[str, Any]] = None


class MealSuggestion(BaseModel):
    """A meal suggestion from the AI."""
    name: str
    ingredients: Optional[List[str]] = None
    difficulty: Optional[str] = None  # "easy", "medium", "hard"
    cook_time: Optional[str] = None
    description: Optional[str] = None


class StructuredData(BaseModel):
    """Structured data from AI response (meals, recipes, etc.)."""
    meals: Optional[List[MealSuggestion]] = None
    recipes: Optional[List[Dict[str, Any]]] = None


class MessageResponse(BaseModel):
    """Response for a single message."""
    message_id: str
    thread_id: str
    role: str
    content: str
    created_at: str
    metadata: Optional[Dict[str, Any]] = None
    follow_ups: Optional[List[FollowUpQuestion]] = None
    structured_data: Optional[StructuredData] = None


class ThreadResponse(BaseModel):
    """Response for a single thread."""
    thread_id: str
    user_id: str
    title: Optional[str] = None
    status: str
    created_at: str
    updated_at: str
    metadata: Optional[Dict[str, Any]] = None
    message_count: int = 0
    last_message_at: Optional[str] = None
    messages: Optional[List[MessageResponse]] = None


class ThreadListResponse(BaseModel):
    """Response for list of threads."""
    threads: List[ThreadResponse]
    total_count: int
    limit: int
    offset: int


class SendMessageResponse(BaseModel):
    """Response after sending a message."""
    success: bool
    user_message: MessageResponse
    assistant_message: Optional[MessageResponse] = None
</file>

<file path="src/api/schemas/response/notification_responses.py">
"""
Notification response schemas for push notification management.
"""
from typing import Optional

from pydantic import BaseModel, Field


class FcmTokenResponse(BaseModel):
    """Response for FCM token operations."""
    success: bool = Field(..., description="Whether the operation was successful")
    message: str = Field(..., description="Response message")


class NotificationPreferencesResponse(BaseModel):
    """Response containing notification preferences."""
    meal_reminders_enabled: bool = Field(..., description="Whether meal reminders are enabled")
    water_reminders_enabled: bool = Field(..., description="Whether water reminders are enabled")
    sleep_reminders_enabled: bool = Field(..., description="Whether sleep reminders are enabled")
    progress_notifications_enabled: bool = Field(..., description="Whether progress notifications are enabled")
    reengagement_notifications_enabled: bool = Field(..., description="Whether reengagement notifications are enabled")
    
    # Meal timing (minutes from midnight: 0-1439)
    breakfast_time_minutes: Optional[int] = Field(None, description="Breakfast reminder time (minutes from midnight)")
    lunch_time_minutes: Optional[int] = Field(None, description="Lunch reminder time (minutes from midnight)")
    dinner_time_minutes: Optional[int] = Field(None, description="Dinner reminder time (minutes from midnight)")
    
    # Water reminder settings
    water_reminder_interval_hours: int = Field(..., description="Water reminder interval in hours")
    
    # Sleep reminder timing
    sleep_reminder_time_minutes: Optional[int] = Field(None, description="Sleep reminder time (minutes from midnight)")


class NotificationPreferencesUpdateResponse(BaseModel):
    """Response for notification preferences update."""
    success: bool = Field(..., description="Whether the update was successful")
    preferences: NotificationPreferencesResponse = Field(..., description="Updated notification preferences")
</file>

<file path="src/api/exceptions.py">
"""
API Exception classes for consistent error handling.
"""
import logging
import traceback
from typing import Optional, Dict, Any

from fastapi import HTTPException, status

logger = logging.getLogger(__name__)

class MealTrackException(Exception):
    """Base exception for all MealTrack exceptions."""
    
    def __init__(
        self, 
        message: str, 
        error_code: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None
    ):
        self.message = message
        self.error_code = error_code or self.__class__.__name__
        self.details = details or {}
        super().__init__(self.message)


class ValidationException(MealTrackException):
    """Raised when request validation fails."""
    pass


class ResourceNotFoundException(MealTrackException):
    """Raised when a requested resource is not found."""
    pass


class BusinessLogicException(MealTrackException):
    """Raised when business rules are violated."""
    pass


class ConflictException(MealTrackException):
    """Raised when a request conflicts with current resource state (e.g., cooldown)."""
    pass


class ExternalServiceException(MealTrackException):
    """Raised when an external service fails."""
    pass


class AuthenticationException(MealTrackException):
    """Raised when authentication fails."""
    pass


class AuthorizationException(MealTrackException):
    """Raised when user lacks permission."""
    pass


def create_http_exception(exc: MealTrackException) -> HTTPException:
    """Convert domain exception to HTTP exception with appropriate status code."""
    
    status_map = {
        ValidationException: status.HTTP_400_BAD_REQUEST,
        ResourceNotFoundException: status.HTTP_404_NOT_FOUND,
        BusinessLogicException: status.HTTP_422_UNPROCESSABLE_ENTITY,
        ExternalServiceException: status.HTTP_503_SERVICE_UNAVAILABLE,
        AuthenticationException: status.HTTP_401_UNAUTHORIZED,
        AuthorizationException: status.HTTP_403_FORBIDDEN,
        ConflictException: status.HTTP_409_CONFLICT,
    }
    
    status_code = status_map.get(type(exc), status.HTTP_500_INTERNAL_SERVER_ERROR)
    
    return HTTPException(
        status_code=status_code,
        detail={
            "error_code": exc.error_code,
            "message": exc.message,
            "details": exc.details
        }
    )


def handle_exception(exc: Exception) -> HTTPException:
    """Handle any exception and convert to appropriate HTTP exception."""
    
    if isinstance(exc, MealTrackException):
        logger.warning(
            f"MealTrack exception occurred: {exc.error_code} - {exc.message}",
            extra={
                "error_code": exc.error_code,
                "details": exc.details
            }
        )
        return create_http_exception(exc)
    
    if isinstance(exc, HTTPException):
        logger.warning(
            f"HTTP exception occurred: {exc.status_code} - {exc.detail}"
        )
        return exc
    
    # Unexpected exceptions - log full stack trace
    logger.error(
        f"Unexpected exception occurred: {type(exc).__name__} - {str(exc)}",
        exc_info=True,
        extra={
            "exception_type": type(exc).__name__,
            "exception_message": str(exc),
            "stack_trace": traceback.format_exc()
        }
    )
    
    return HTTPException(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        detail={
            "error_code": "INTERNAL_ERROR",
            "message": "An unexpected error occurred",
            "details": {"error": str(exc)}
        }
    )
</file>

<file path="src/app/commands/meal_suggestion/save_meal_suggestion_command.py">
"""
Command for saving a meal suggestion to meal history.
"""
from dataclasses import dataclass
from datetime import date
from typing import Optional, List

from src.app.events.base import Command


@dataclass
class SaveMealSuggestionCommand(Command):
    """
    Command to save a selected meal suggestion to the user's meal history.
    
    Saves the suggestion as a planned meal in the database.
    """
    
    # User identification
    user_id: str
    
    # Suggestion data
    suggestion_id: str
    name: str
    description: str
    meal_type: str  # breakfast, lunch, dinner, snack
    estimated_cook_time_minutes: int
    calories: int
    protein: float
    carbs: float
    fat: float
    ingredients_list: List[str]
    instructions: List[str]
    
    # Optional date (defaults to today)
    meal_date: Optional[date] = None
    
    def __post_init__(self):
        """Validate command data."""
        valid_meal_types = ["breakfast", "lunch", "dinner", "snack"]
        if self.meal_type not in valid_meal_types:
            raise ValueError(f"meal_type must be one of {valid_meal_types}")
        
        if self.estimated_cook_time_minutes <= 0:
            raise ValueError("estimated_cook_time_minutes must be greater than 0")
        
        if self.calories <= 0:
            raise ValueError("calories must be greater than 0")
        
        # Set default date if not provided
        if self.meal_date is None:
            object.__setattr__(self, 'meal_date', date.today())
</file>

<file path="src/app/commands/notification/register_fcm_token_command.py">
"""
Command to register an FCM token for push notifications.
"""
from dataclasses import dataclass
from typing import Optional

from src.app.events.base import Command


@dataclass
class RegisterFcmTokenCommand(Command):
    """Command to register an FCM token for push notifications."""
    user_id: str
    fcm_token: str
    device_type: str  # 'ios' or 'android'
    timezone: Optional[str] = None  # IANA timezone identifier
</file>

<file path="src/app/handlers/command_handlers/chat/create_thread_command_handler.py">
"""
Handler for creating a new chat thread.
"""
import logging
from typing import Dict, Any

from src.app.commands.chat import CreateThreadCommand
from src.app.events.base import EventHandler, handles
from src.domain.model.chat import Thread, Message
from src.domain.ports.chat_repository_port import ChatRepositoryPort

logger = logging.getLogger(__name__)

# Welcome message content and follow-ups
WELCOME_MESSAGE_CONTENT = "Hello! I'm your meal planning assistant. What would you like to eat today? Tell me what ingredients you have, and I'll suggest some delicious meals you can cook!"

WELCOME_FOLLOW_UPS = [
    {"id": "quick_1", "text": "I have chicken and vegetables", "type": "question"},
    {"id": "quick_2", "text": "Suggest quick meals (under 30 min)", "type": "question"},
    {"id": "quick_3", "text": "I want healthy low-calorie options", "type": "question"},
    {"id": "quick_4", "text": "What can I make with pasta?", "type": "question"}
]


@handles(CreateThreadCommand)
class CreateThreadCommandHandler(EventHandler[CreateThreadCommand, Dict[str, Any]]):
    """Handler for creating new chat threads."""
    
    def __init__(self, chat_repository: ChatRepositoryPort = None):
        self.chat_repository = chat_repository
    
    def set_dependencies(self, chat_repository: ChatRepositoryPort):
        """Set dependencies for dependency injection."""
        self.chat_repository = chat_repository
    
    async def handle(self, command: CreateThreadCommand) -> Dict[str, Any]:
        """Create a new thread with automatic welcome message."""
        if not self.chat_repository:
            raise RuntimeError("Chat repository not configured")
        
        # Create new thread domain object
        thread = Thread.create_new(
            user_id=command.user_id,
            title=command.title,
            metadata=command.metadata
        )
        
        # Save thread
        saved_thread = self.chat_repository.save_thread(thread)
        
        logger.info(f"Created new chat thread {saved_thread.thread_id} for user {command.user_id}")
        
        # Create welcome message from assistant
        welcome_message = Message.create_assistant_message(
            thread_id=saved_thread.thread_id,
            content=WELCOME_MESSAGE_CONTENT,
            metadata={
                "is_welcome": True,
                "follow_ups": WELCOME_FOLLOW_UPS,
                "structured_data": None
            }
        )
        
        # Save welcome message
        saved_welcome = self.chat_repository.save_message(welcome_message)
        logger.info(f"Created welcome message {saved_welcome.message_id} for thread {saved_thread.thread_id}")
        
        # Include welcome message in thread response
        thread_dict = saved_thread.to_dict()
        thread_dict["messages"] = [saved_welcome.to_dict()]
        thread_dict["message_count"] = 1
        
        return {
            "success": True,
            "thread": thread_dict,
            "welcome_message": saved_welcome.to_dict()
        }
</file>

<file path="src/app/handlers/command_handlers/chat/send_message_command_handler.py">
"""
Handler for sending a message in a chat thread.
Refactored to use MessageOrchestrationService.
"""
import logging
from typing import Dict, Any

from src.app.commands.chat import SendMessageCommand
from src.app.events.base import EventHandler, handles
from src.domain.ports.chat_repository_port import ChatRepositoryPort
from src.domain.ports.ai_chat_service_port import AIChatServicePort
from src.app.services.chat import MessageOrchestrationService

logger = logging.getLogger(__name__)


@handles(SendMessageCommand)
class SendMessageCommandHandler(EventHandler[SendMessageCommand, Dict[str, Any]]):
    """
    Handler for sending messages in chat threads.
    
    This handler is now a thin coordinator that delegates to
    MessageOrchestrationService for the actual work.
    """
    
    def __init__(
        self,
        chat_repository: ChatRepositoryPort = None,
        ai_service: AIChatServicePort = None
    ):
        self.chat_repository = chat_repository
        self.ai_service = ai_service
        
        # Initialize orchestration service immediately if dependencies are provided
        if chat_repository:
            self.orchestration_service = MessageOrchestrationService(
                chat_repository=chat_repository,
                ai_service=ai_service
            )
        else:
            self.orchestration_service = None
    
    def set_dependencies(
        self,
        chat_repository: ChatRepositoryPort,
        ai_service: AIChatServicePort = None
    ):
        """Set dependencies for dependency injection."""
        self.chat_repository = chat_repository
        self.ai_service = ai_service
        
        # Initialize orchestration service with dependencies
        if chat_repository:
            self.orchestration_service = MessageOrchestrationService(
                chat_repository=chat_repository,
                ai_service=ai_service
            )
    
    async def handle(self, command: SendMessageCommand) -> Dict[str, Any]:
        """
        Send a message and get AI response.
        
        Delegates to MessageOrchestrationService for processing.
        """
        if not self.orchestration_service:
            raise RuntimeError("Orchestration service not configured")
        
        return await self.orchestration_service.send_message(
            thread_id=command.thread_id,
            user_id=command.user_id,
            content=command.content,
            metadata=command.metadata
        )
</file>

<file path="src/app/handlers/command_handlers/delete_meal_command_handler.py">
"""
Handler for soft-deleting meals (marking as INACTIVE).
"""
import logging
from datetime import datetime
from typing import Dict, Any, Optional

from src.api.exceptions import ResourceNotFoundException
from src.app.commands.meal import DeleteMealCommand
from src.app.events.base import EventHandler, handles
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService

logger = logging.getLogger(__name__)


@handles(DeleteMealCommand)
class DeleteMealCommandHandler(EventHandler[DeleteMealCommand, Dict[str, Any]]):
    """Handler for soft-deleting a meal (marking as INACTIVE)."""

    def __init__(self, meal_repository: MealRepositoryPort = None, cache_service: Optional[CacheService] = None):
        self.meal_repository = meal_repository
        self.cache_service = cache_service

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.meal_repository = kwargs.get('meal_repository', self.meal_repository)
        self.cache_service = kwargs.get('cache_service', self.cache_service)

    async def handle(self, command: DeleteMealCommand) -> Dict[str, Any]:
        """Handle meal deletion by marking as INACTIVE."""
        if not self.meal_repository:
            raise RuntimeError("Meal repository not configured")

        # Get meal
        meal = self.meal_repository.find_by_id(command.meal_id)
        if not meal:
            raise ResourceNotFoundException(f"Meal with ID {command.meal_id} not found")

        # Mark as inactive
        inactive_meal = meal.mark_inactive()
        self.meal_repository.save(inactive_meal)
        await self._invalidate_daily_macros(meal)

        return {
            "meal_id": inactive_meal.meal_id,
            "status": inactive_meal.status.value,
            "message": "Meal marked as inactive"
        }

    async def _invalidate_daily_macros(self, meal):
        if not self.cache_service or not meal:
            return
        created_at = meal.created_at or datetime.utcnow()
        cache_key, _ = CacheKeys.daily_macros(meal.user_id, created_at.date())
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/delete_user_command_handler.py">
"""
DeleteUserCommandHandler - Handler for deleting user accounts.
Performs soft delete in database and hard delete in Firebase Auth.
"""
import logging
from datetime import datetime
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.commands.user import DeleteUserCommand
from src.app.events.base import EventHandler, handles
from src.infra.database.models.user import User
from src.infra.services.firebase_auth_service import FirebaseAuthService

logger = logging.getLogger(__name__)


@handles(DeleteUserCommand)
class DeleteUserCommandHandler(EventHandler[DeleteUserCommand, Dict[str, Any]]):
    """Handler for deleting user accounts."""

    def __init__(self, db: Session = None):
        self.db = db
        self.firebase_auth_service = FirebaseAuthService()

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, command: DeleteUserCommand) -> Dict[str, Any]:
        """
        Delete user account.
        - Soft delete in database (set is_active=False)
        - Anonymize user data
        - Hard delete in Firebase Authentication
        """
        if not self.db:
            raise RuntimeError("Database session not configured")

        try:
            # Find user by firebase_uid
            user = self.db.query(User).filter(
                User.firebase_uid == command.firebase_uid,
                User.is_active == True  # Only delete active users
            ).first()

            if not user:
                raise ResourceNotFoundException(
                    f"Active user with Firebase UID not found"
                )

            # Store user_id for logging
            user_id = user.id

            # Step 1: Anonymize user data (GDPR compliance)
            user.email = f"deleted_{user.id}@deleted.local"
            user.username = f"deleted_user_{user.id}"
            user.first_name = None
            user.last_name = None
            user.phone_number = None
            user.display_name = None
            user.photo_url = None
            user.password_hash = "DELETED"

            # Step 2: Soft delete in database
            user.is_active = False
            user.last_accessed = datetime.utcnow()

            # Commit database changes first
            self.db.commit()
            logger.info(f"Successfully soft deleted user in database")

            # Step 3: Revoke refresh tokens to invalidate all active sessions
            # This prevents the user from getting new access tokens
            try:
                self.firebase_auth_service.revoke_refresh_tokens(command.firebase_uid)
                logger.info(f"Successfully revoked Firebase refresh tokens")
            except Exception as revoke_error:
                logger.warning(f"Token revocation failed: {str(revoke_error)}")
                # Continue - deletion is more important

            # Step 4: Hard delete from Firebase Authentication
            try:
                firebase_deleted = self.firebase_auth_service.delete_firebase_user(
                    command.firebase_uid
                )
                if firebase_deleted:
                    logger.info(f"Successfully deleted user from Firebase")
                else:
                    logger.warning(f"Firebase deletion returned False")
            except Exception as firebase_error:
                # Log Firebase error but don't rollback DB changes
                logger.error(f"Firebase deletion failed: {str(firebase_error)}")
                # Continue - database soft delete is more important than Firebase cleanup

            return {
                "firebase_uid": command.firebase_uid,
                "deleted": True,
                "message": "Account successfully deleted"
            }

        except ResourceNotFoundException:
            # Re-raise not found errors
            raise
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error deleting user account: {str(e)}")
            raise Exception(f"Failed to delete user account: {str(e)}")
</file>

<file path="src/app/handlers/command_handlers/edit_meal_command_handler.py">
"""
Handler for editing meal ingredients.
"""
import logging
import uuid
from datetime import datetime
from typing import Dict, Any, Optional

from src.api.exceptions import ValidationException, ResourceNotFoundException
from src.app.commands.meal import EditMealCommand
from src.app.events.base import EventHandler, handles
from src.app.events.meal import MealEditedEvent
from src.domain.model.meal import MealStatus
from src.domain.model.nutrition import FoodItem, Macros
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService
from src.infra.services.pinecone_service import get_pinecone_service

logger = logging.getLogger(__name__)


@handles(EditMealCommand)
class EditMealCommandHandler(EventHandler[EditMealCommand, Dict[str, Any]]):
    """Handler for editing meal ingredients."""

    def __init__(self,
                 meal_repository: MealRepositoryPort = None,
                 food_service=None,
                 nutrition_calculator=None,
                 pinecone_service=None,
                 cache_service: Optional[CacheService] = None):
        self.meal_repository = meal_repository
        self.food_service = food_service
        self.nutrition_calculator = nutrition_calculator
        self.pinecone_service = pinecone_service
        self.cache_service = cache_service

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.meal_repository = kwargs.get('meal_repository', self.meal_repository)
        self.food_service = kwargs.get('food_service', self.food_service)
        self.nutrition_calculator = kwargs.get('nutrition_calculator', self.nutrition_calculator)
        self.pinecone_service = kwargs.get('pinecone_service', self.pinecone_service)
        self.cache_service = kwargs.get('cache_service', self.cache_service)

    async def handle(self, command: EditMealCommand) -> Dict[str, Any]:
        """Handle meal editing operations."""
        if not self.meal_repository:
            raise RuntimeError("Meal repository not configured")

        # 1. Validate meal exists
        meal = self.meal_repository.find_by_id(command.meal_id)
        if not meal:
            raise ResourceNotFoundException("Meal not found")

        if meal.status != MealStatus.READY:
            raise ValidationException("Meal must be in READY status to edit")

        # 2. Apply food item changes
        updated_food_items = await self._apply_food_item_changes(
            meal.nutrition.food_items if meal.nutrition else [],
            command.food_item_changes
        )

        # 3. Recalculate nutrition
        updated_nutrition = self._calculate_total_nutrition(updated_food_items)

        # 4. Update meal
        updated_meal = meal.mark_edited(
            nutrition=updated_nutrition,
            dish_name=command.dish_name or meal.dish_name
        )

        # 5. Persist changes
        saved_meal = self.meal_repository.save(updated_meal)
        await self._invalidate_daily_macros(saved_meal)

        # 6. Calculate nutrition delta for event
        nutrition_delta = self._calculate_nutrition_delta(meal.nutrition, updated_nutrition)

        # 7. Generate changes summary
        changes_summary = self._generate_changes_summary(command.food_item_changes)

        return {
            "success": True,
            "meal_id": saved_meal.meal_id,
            "message": f"Meal updated successfully. {changes_summary}",
            "dish_name": saved_meal.dish_name or "Meal",
            "total_calories": updated_nutrition.calories,
            "updated_nutrition": {
                "calories": updated_nutrition.calories,
                "protein": updated_nutrition.macros.protein,
                "carbs": updated_nutrition.macros.carbs,
                "fat": updated_nutrition.macros.fat,
            },
            "updated_food_items": [item.to_dict() for item in updated_food_items],
            "edit_metadata": {
                "edit_count": saved_meal.edit_count,
                "changes_summary": changes_summary
            },
            "events": [
                MealEditedEvent(
                    aggregate_id=saved_meal.meal_id,
                    meal_id=saved_meal.meal_id,
                    user_id=saved_meal.user_id,
                    edit_type="ingredients_updated",
                    changes_summary=changes_summary,
                    nutrition_delta=nutrition_delta,
                    edit_count=saved_meal.edit_count
                )
            ]
        }

    async def _apply_food_item_changes(self, current_food_items, changes):
        """Apply food item changes to current list using strategy pattern."""
        from src.domain.services import NutritionCalculationService
        from src.domain.strategies.meal_edit_strategies import FoodItemChangeStrategyFactory

        # Convert current items to dict for easier manipulation
        food_items_dict = {}
        if current_food_items:
            for item in current_food_items:
                food_items_dict[item.id] = item

        # Initialize nutrition service and create strategies
        nutrition_service = NutritionCalculationService(
            pinecone_service=self.pinecone_service or get_pinecone_service(),
            usda_service=self.food_service
        )
        strategies = FoodItemChangeStrategyFactory.create_strategies(
            nutrition_service,
            self.food_service
        )

        # Apply each change using the appropriate strategy
        for change in changes:
            strategy = strategies.get(change.action)
            if strategy:
                await strategy.apply(food_items_dict, change)
            else:
                logger.warning(f"Unknown action: {change.action}")

        return list(food_items_dict.values())

    async def _get_usda_food_nutrition(self, fdc_id: int, quantity: float):
        """Get nutrition data from USDA service."""
        if not self.food_service:
            raise RuntimeError("Food service not configured")

        # Get food details from USDA
        food_data = await self.food_service.get_food_details(fdc_id)

        # Extract nutrition data (per 100g basis)
        nutrients = food_data.get('foodNutrients', [])

        # Map USDA nutrient IDs to our fields
        nutrient_map = {
            1008: 'calories',  # Energy (kcal)
            1003: 'protein',   # Protein
            1005: 'carbs',     # Carbohydrate, by difference
            1004: 'fat'        # Total lipid (fat)
        }

        nutrition_values = {}
        for nutrient in nutrients:
            nutrient_id = nutrient.get('nutrient', {}).get('id')
            if nutrient_id in nutrient_map:
                nutrition_values[nutrient_map[nutrient_id]] = nutrient.get('amount', 0)

        # Calculate nutrition for the specified quantity
        scale_factor = quantity / 100.0  # USDA data is per 100g

        return FoodItem(
            id=str(uuid.uuid4()),  # Generate new ID for USDA food
            name=food_data.get('description', f"USDA Food {fdc_id}"),
            quantity=quantity,
            unit="g",
            calories=nutrition_values.get('calories', 0) * scale_factor,
            macros=Macros(
                protein=nutrition_values.get('protein', 0) * scale_factor,
                carbs=nutrition_values.get('carbs', 0) * scale_factor,
                fat=nutrition_values.get('fat', 0) * scale_factor,
            ),
            confidence=1.0,
            fdc_id=fdc_id,
            is_custom=False
        )

    def _calculate_total_nutrition(self, food_items):
        """Calculate total nutrition from food items using nutrition service."""
        from src.domain.services import NutritionCalculationService

        nutrition_service = NutritionCalculationService()
        return nutrition_service.calculate_meal_total(food_items)

    def _calculate_nutrition_delta(self, old_nutrition, new_nutrition):
        """Calculate the difference in nutrition values."""
        if not old_nutrition:
            return {
                "calories": new_nutrition.calories,
                "protein": new_nutrition.macros.protein,
                "carbs": new_nutrition.macros.carbs,
                "fat": new_nutrition.macros.fat
            }

        return {
            "calories": new_nutrition.calories - old_nutrition.calories,
            "protein": new_nutrition.macros.protein - old_nutrition.macros.protein,
            "carbs": new_nutrition.macros.carbs - old_nutrition.macros.carbs,
            "fat": new_nutrition.macros.fat - old_nutrition.macros.fat
        }

    def _generate_changes_summary(self, changes):
        """Generate a human-readable summary of changes."""
        summary_parts = []
        for change in changes:
            if change.action == "add":
                summary_parts.append(f"Added {change.name or 'ingredient'}")
            elif change.action == "remove":
                summary_parts.append("Removed ingredient")
            elif change.action == "update":
                summary_parts.append("Updated portion")

        return "; ".join(summary_parts) if summary_parts else "Updated meal"

    async def _invalidate_daily_macros(self, meal):
        if not self.cache_service or not meal:
            return
        created_at = meal.created_at or datetime.utcnow()
        cache_key, _ = CacheKeys.daily_macros(meal.user_id, created_at.date())
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/save_user_onboarding_command_handler.py">
"""
SaveUserOnboardingCommandHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Optional

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException, ValidationException
from src.app.commands.user import SaveUserOnboardingCommand
from src.app.events.base import EventHandler, handles
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService
from src.infra.database.models.user import User
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)


@handles(SaveUserOnboardingCommand)
class SaveUserOnboardingCommandHandler(EventHandler[SaveUserOnboardingCommand, None]):
    """Handler for saving user onboarding data."""

    def __init__(self, db: Session = None, cache_service: Optional[CacheService] = None):
        self.db = db
        self.cache_service = cache_service

    def set_dependencies(self, db: Session, **kwargs):
        """Set dependencies for dependency injection."""
        self.db = db
        self.cache_service = kwargs.get("cache_service", self.cache_service)

    async def handle(self, command: SaveUserOnboardingCommand) -> None:
        """Save user onboarding data."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Validate input
        if command.age < 1 or command.age > 120:
            raise ValidationException("Age must be between 1 and 120")

        if command.weight_kg <= 0:
            raise ValidationException("Weight must be greater than 0")

        if command.height_cm <= 0:
            raise ValidationException("Height must be greater than 0")

        try:
            # Get existing user
            user = self.db.query(User).filter(User.id == command.user_id).first()
            if not user:
                raise ResourceNotFoundException(f"User {command.user_id} not found. User must be created before onboarding.")

            # Get or create user profile
            profile = self.db.query(UserProfile).filter(
                UserProfile.user_id == command.user_id
            ).first()

            if not profile:
                profile = UserProfile(user_id=command.user_id)

            # Update profile with personal info
            profile.age = command.age
            profile.gender = command.gender
            profile.height_cm = command.height_cm
            profile.weight_kg = command.weight_kg
            profile.body_fat_percentage = command.body_fat_percentage

            # Update goals
            profile.activity_level = command.activity_level
            profile.fitness_goal = command.fitness_goal
            profile.meals_per_day = command.meals_per_day

            # Update preferences (JSON fields) - REQUIRED
            profile.pain_points = command.pain_points
            profile.dietary_preferences = command.dietary_preferences

            # Save profile
            self.db.add(profile)
            self.db.commit()
            self.db.refresh(profile)
            await self._invalidate_user_profile(command.user_id)

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error saving onboarding data: {str(e)}")
            raise

    async def _invalidate_user_profile(self, user_id: str):
        if not self.cache_service:
            return
        cache_key, _ = CacheKeys.user_profile(user_id)
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/upload_meal_image_immediately_command_handler.py">
"""
Handler for immediate meal image upload and analysis.
"""
import logging
from datetime import datetime
from uuid import uuid4
from typing import Optional

from src.app.commands.meal import UploadMealImageImmediatelyCommand
from src.app.events.base import EventHandler, handles
from src.domain.model.meal import Meal, MealStatus
from src.domain.model.meal import MealImage
from src.domain.parsers.gpt_response_parser import GPTResponseParser
from src.domain.ports.image_store_port import ImageStorePort
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.domain.ports.vision_ai_service_port import VisionAIServicePort
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService

logger = logging.getLogger(__name__)


@handles(UploadMealImageImmediatelyCommand)
class UploadMealImageImmediatelyHandler(EventHandler[UploadMealImageImmediatelyCommand, Meal]):
    """Handler for immediate meal image upload and analysis."""
    
    def __init__(
        self,
        image_store: ImageStorePort = None,
        meal_repository: MealRepositoryPort = None,
        vision_service: VisionAIServicePort = None,
        gpt_parser: GPTResponseParser = None,
        cache_service: Optional[CacheService] = None,
    ):
        self.image_store = image_store
        self.meal_repository = meal_repository
        self.vision_service = vision_service
        self.gpt_parser = gpt_parser
        self.cache_service = cache_service
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.image_store = kwargs.get('image_store', self.image_store)
        self.meal_repository = kwargs.get('meal_repository', self.meal_repository)
        self.vision_service = kwargs.get('vision_service', self.vision_service)
        self.gpt_parser = kwargs.get('gpt_parser', self.gpt_parser)
        self.cache_service = kwargs.get('cache_service', self.cache_service)
    
    async def handle(self, command: UploadMealImageImmediatelyCommand) -> Meal:
        """Handle immediate meal image upload and analysis."""
        if not all([self.image_store, self.meal_repository, self.vision_service, self.gpt_parser]):
            raise RuntimeError("Required dependencies not configured")
        
        try:
            # Upload image to storage
            logger.info("Uploading image to storage")
            image_url = self.image_store.save(
                command.file_contents,
                command.content_type
            )

            image_id = image_url
            if image_url.startswith("mock://images/"):
                image_id = image_url.replace("mock://images/", "")
            elif "cloudinary.com" in image_url:
                # Extract public_id from cloudinary URL
                parts = image_url.split("/")
                if len(parts) > 1:
                    # Get the last part and remove file extension
                    image_id = parts[-1].split(".")[0]
            
            # Determine the meal date - use target_date if provided, otherwise use now
            meal_date = command.target_date if command.target_date else datetime.now().date()
            meal_datetime = datetime.combine(meal_date, datetime.now().time())
            
            logger.info(f"Creating meal record for date: {meal_date}")
            
            # Create meal record with ANALYZING status
            meal = Meal(
                meal_id=str(uuid4()),
                user_id=command.user_id,
                status=MealStatus.ANALYZING,
                created_at=meal_datetime,
                image=MealImage(
                    image_id=image_id,
                    format="jpeg" if "jpeg" in command.content_type else "png",
                    size_bytes=len(command.file_contents),
                    url=image_url
                )
            )
            
            # Save initial meal record
            saved_meal = self.meal_repository.save(meal)
            logger.info(f"Created meal record {saved_meal.meal_id} with ANALYZING status")
            
            # Perform AI analysis immediately
            logger.info(f"Performing AI vision analysis for meal {saved_meal.meal_id}")
            vision_result = self.vision_service.analyze(command.file_contents)
            
            # Parse the response
            nutrition = self.gpt_parser.parse_to_nutrition(vision_result)
            dish_name = self.gpt_parser.parse_dish_name(vision_result)
            
            # Update meal with analysis results
            meal.dish_name = dish_name or "Unknown dish"
            meal.status = MealStatus.READY
            meal.ready_at = datetime.now()
            meal.raw_gpt_json = self.gpt_parser.extract_raw_json(vision_result)
            
            # Use the parsed nutrition directly
            meal.nutrition = nutrition
            
            # Save the fully analyzed meal
            final_meal = self.meal_repository.save(meal)
            logger.info(f"Meal {final_meal.meal_id} analysis completed successfully with status {final_meal.status}")
            await self._invalidate_daily_macros(command.user_id, meal_date)
            
            return final_meal
            
        except Exception as e:
            logger.error(f"Failed to upload and analyze meal immediately: {str(e)}")
            # If meal was created, update it to failed status
            if 'meal' in locals() and meal.meal_id:
                meal.status = MealStatus.FAILED
                meal.error_message = str(e)
                self.meal_repository.save(meal)
            raise

    async def _invalidate_daily_macros(self, user_id, target_date):
        if not self.cache_service:
            return
        cache_key, _ = CacheKeys.daily_macros(user_id, target_date)
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/weekly_ingredient_based_meal_plan_command_handler.py">
"""
Command handler for weekly ingredient-based meal-plan generation.
Works with Python 3.11 and the simplified WeeklyIngredientBasedMealPlanService.
"""

import logging
from typing import Any, Dict, Optional

from sqlalchemy.orm import Session

from src.app.commands.meal_plan import GenerateWeeklyIngredientBasedMealPlanCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_plan_persistence_service import MealPlanPersistenceService
from src.domain.services.user_profile_service import UserProfileService
from src.domain.model.meal_planning import PlanDuration
from src.domain.services.weekly_ingredient_based_meal_plan_service import (
    WeeklyIngredientBasedMealPlanService,
)

logger = logging.getLogger(__name__)


@handles(GenerateWeeklyIngredientBasedMealPlanCommand)
class GenerateWeeklyIngredientBasedMealPlanCommandHandler(
    EventHandler[GenerateWeeklyIngredientBasedMealPlanCommand, Dict[str, Any]]
):
    """Generate and persist a Monday-to-Sunday meal plan."""

    def __init__(self, db: Optional[Session] = None) -> None:
        self.db: Optional[Session] = db
        self.meal_plan_service = WeeklyIngredientBasedMealPlanService()
        self.user_profile_service = UserProfileService(db) if db else None
        self.persistence_service = MealPlanPersistenceService(db) if db else None

    # ------------------------------------------------------------------ #
    # dependency injection                                               #
    # ------------------------------------------------------------------ #

    def set_dependencies(self, db: Session) -> None:
        self.db = db
        self.user_profile_service = UserProfileService(db)
        self.persistence_service = MealPlanPersistenceService(db)

    # ------------------------------------------------------------------ #
    # main handler                                                       #
    # ------------------------------------------------------------------ #

    async def handle(
        self, command: GenerateWeeklyIngredientBasedMealPlanCommand
    ) -> Dict[str, Any]:
        if not self.db:
            raise RuntimeError("Database session not configured")

        logger.info(
            "Generating weekly ingredient-based meal plan for user %s (%d ingredients)",
            command.user_id,
            len(command.available_ingredients),
        )

        # ── 1. get user profile data using shared service ──────────────
        user_data = await self.user_profile_service.get_user_profile_or_defaults(command.user_id)
        
        # ── 2. calculate next Monday-Sunday dates ───────────────────────
        from datetime import datetime, timedelta
        today = datetime.now().date()
        days_since_monday = today.weekday()  # Monday = 0
        # Calculate next Monday
        days_until_next_monday = 7 - days_since_monday if days_since_monday != 0 else 7
        start_date = today + timedelta(days=days_until_next_monday)
        end_date = start_date + timedelta(days=6)
        
        # ── 3. prepare request data with specific dates ─────────────────
        request_data = {
            "user_id": command.user_id,
            "available_ingredients": command.available_ingredients,
            "available_seasonings": command.available_seasonings,
            "start_date": start_date.isoformat(),
            "end_date": end_date.isoformat(),
            "start_date_obj": start_date,
            "end_date_obj": end_date,
            **user_data  # Include all user profile data
        }

        try:
            plan_json = self.meal_plan_service.generate_weekly_meal_plan(request_data)
        except Exception as exc:  # pragma: no cover
            logger.exception("Meal-plan generation failed")
            raise

        logger.info("Meal plan generated for user %s", command.user_id)

        # ── 3. persist meal plan using shared service ───────────────────
        if self.persistence_service:
            user_preferences = self.user_profile_service.create_user_preferences_from_data(
                user_data, PlanDuration.WEEKLY
            )
            plan_id = self.persistence_service.save_weekly_meal_plan(
                plan_json, user_preferences, command.user_id
            )
            plan_json["plan_id"] = plan_id

        return plan_json
</file>

<file path="src/app/handlers/query_handlers/get_daily_macros_query_handler.py">
"""
GetDailyMacrosQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from datetime import date
from typing import Dict, Any, Optional

from src.app.events.base import EventHandler, handles
from src.app.queries.meal import GetDailyMacrosQuery
from src.domain.model.meal import MealStatus
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService

logger = logging.getLogger(__name__)


@handles(GetDailyMacrosQuery)
class GetDailyMacrosQueryHandler(EventHandler[GetDailyMacrosQuery, Dict[str, Any]]):
    """Handler for calculating daily macronutrient totals with user targets."""

    def __init__(
        self,
        meal_repository: MealRepositoryPort = None,
        db=None,
        cache_service: Optional[CacheService] = None,
    ):
        self.meal_repository = meal_repository
        self.db = db
        self.cache_service = cache_service

    def set_dependencies(self, meal_repository: MealRepositoryPort, db=None, **kwargs):
        """Set dependencies for dependency injection."""
        self.meal_repository = meal_repository
        if db:
            self.db = db
        self.cache_service = kwargs.get("cache_service", self.cache_service)

    async def handle(self, query: GetDailyMacrosQuery) -> Dict[str, Any]:
        """Calculate daily macros for a given date with user targets."""
        if not self.meal_repository:
            raise RuntimeError("Meal repository not configured")

        target_date = query.target_date or date.today()
        cached_result = await self._try_get_cached_result(query.user_id, target_date)
        if cached_result is not None:
            return cached_result

        meals = self.meal_repository.find_by_date(target_date, user_id=query.user_id)

        # Initialize totals
        total_calories = 0.0
        total_protein = 0.0
        total_carbs = 0.0
        total_fat = 0.0
        meal_count = 0
        meals_with_nutrition = 0

        # Calculate totals from meals with nutrition data
        for meal in meals:
            # Skip INACTIVE meals entirely
            if meal.status == MealStatus.INACTIVE:
                continue
            meal_count += 1
            if meal.nutrition and meal.status in [MealStatus.READY, MealStatus.ENRICHING]:
                meals_with_nutrition += 1
                total_calories += meal.nutrition.calories or 0
                if meal.nutrition.macros:
                    total_protein += meal.nutrition.macros.protein or 0
                    total_carbs += meal.nutrition.macros.carbs or 0
                    total_fat += meal.nutrition.macros.fat or 0

        # Get user's TDEE targets
        target_calories = None
        target_macros = None

        try:
            # Get TDEE calculation for the user
            from src.app.handlers.query_handlers.get_user_tdee_query_handler import GetUserTdeeQueryHandler
            from src.app.queries.tdee import GetUserTdeeQuery

            tdee_handler = GetUserTdeeQueryHandler(self.db)
            tdee_query = GetUserTdeeQuery(user_id=query.user_id)
            tdee_result = await tdee_handler.handle(tdee_query)

            target_calories = tdee_result.get('target_calories')
            target_macros = tdee_result.get('macros', {})
            
            if target_calories is None:
                logger.warning(f"TDEE data missing for user {query.user_id}. User may not have completed onboarding.")
        except Exception as e:
            logger.warning(f"Could not fetch TDEE data for user {query.user_id}: {e}", exc_info=True)
            # Continue without target data - mapper will handle this appropriately

        result = {
            "date": target_date.isoformat(),
            "user_id": query.user_id,
            "total_calories": round(total_calories, 1),
            "total_protein": round(total_protein, 1),
            "total_carbs": round(total_carbs, 1),
            "total_fat": round(total_fat, 1),
            "meal_count": meal_count,
            "meals_with_nutrition": meals_with_nutrition
        }

        # Add target data if available
        if target_calories is not None:
            result["target_calories"] = target_calories

        if target_macros:
            result["target_macros"] = {
                "protein": target_macros.get('protein', 0.0),
                "carbs": target_macros.get('carbs', 0.0),
                "fat": target_macros.get('fat', 0.0),
                "calories": target_macros.get('calories', target_calories or 0.0)
            }

        await self._write_cache(query.user_id, target_date, result)
        return result

    async def _try_get_cached_result(self, user_id: str, target_date: date):
        if not self.cache_service:
            return None
        cache_key, _ = CacheKeys.daily_macros(user_id, target_date)
        return await self.cache_service.get_json(cache_key)

    async def _write_cache(self, user_id: str, target_date: date, payload: Dict[str, Any]):
        if not self.cache_service:
            return
        cache_key, ttl = CacheKeys.daily_macros(user_id, target_date)
        await self.cache_service.set_json(cache_key, payload, ttl)
</file>

<file path="src/app/handlers/query_handlers/get_user_by_firebase_uid_query_handler.py">
"""
GetUserByFirebaseUidQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
import os
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.user.get_user_by_firebase_uid_query import GetUserByFirebaseUidQuery
from src.infra.database.models.user import User

logger = logging.getLogger(__name__)


@handles(GetUserByFirebaseUidQuery)
class GetUserByFirebaseUidQueryHandler(EventHandler[GetUserByFirebaseUidQuery, Dict[str, Any]]):
    """Handler for getting user by Firebase UID."""

    def __init__(self, db: Session = None):
        self.db = db

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, query: GetUserByFirebaseUidQuery) -> Dict[str, Any]:
        """Get user by Firebase UID."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get user by firebase_uid
        user = self.db.query(User).filter(
            User.firebase_uid == query.firebase_uid
        ).first()

        if not user:
            raise ResourceNotFoundException(f"User with Firebase UID {query.firebase_uid} not found")

        # In development, avoid touching subscriptions table (may not exist yet)
        if os.getenv("ENVIRONMENT") == "development":
            is_premium_value = True
        else:
            try:
                is_premium_value = bool(user.is_premium())
            except Exception:
                # Safe fallback if subscription lookup fails
                is_premium_value = False

        return {
            "id": user.id,
            "firebase_uid": user.firebase_uid,
            "email": user.email,
            "username": user.username,
            "first_name": user.first_name,
            "last_name": user.last_name,
            "phone_number": user.phone_number,
            "display_name": user.display_name,
            "photo_url": user.photo_url,
            "provider": user.provider,
            "is_active": user.is_active,
            "onboarding_completed": user.onboarding_completed,
            "last_accessed": user.last_accessed,
            "created_at": user.created_at,
            "updated_at": user.updated_at,
            # Required by UserProfileResponse
            "is_premium": is_premium_value
        }
</file>

<file path="src/app/handlers/query_handlers/get_user_metrics_query_handler.py">
"""
GetUserMetricsQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import handles, EventHandler
from src.app.queries.user import GetUserMetricsQuery
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)

@handles(GetUserMetricsQuery)
class GetUserMetricsQueryHandler(EventHandler[GetUserMetricsQuery, Dict[str, Any]]):
    """Handler for getting user's current metrics for settings display."""

    def __init__(self, db: Session = None):
        self.db = db

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, query: GetUserMetricsQuery) -> Dict[str, Any]:
        """Get user's current metrics."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get current user profile
        profile = self.db.query(UserProfile).filter(
            UserProfile.user_id == query.user_id,
            UserProfile.is_current == True
        ).first()

        if not profile:
            raise ResourceNotFoundException(f"Current profile for user {query.user_id} not found")

        return {
            "user_id": query.user_id,
            "age": profile.age,
            "gender": profile.gender,
            "height_cm": profile.height_cm,
            "weight_kg": profile.weight_kg,
            "body_fat_percentage": profile.body_fat_percentage,
            "activity_level": profile.activity_level,
            "fitness_goal": profile.fitness_goal,
            "target_weight_kg": profile.target_weight_kg,
            "updated_at": profile.updated_at
        }
</file>

<file path="src/domain/constants/meal_constants.py">
"""
Constants for meal-related domain operations.

This module centralizes all meal-related constants, magic numbers,
and configuration values used throughout the domain layer.
"""


class MealDistribution:
    """Constants for meal calorie distribution."""
    
    # Standard distribution percentages
    BREAKFAST_PERCENT = 0.25
    LUNCH_PERCENT = 0.35
    DINNER_PERCENT = 0.30
    SNACK_PERCENT = 0.10
    
    # Calorie thresholds
    MIN_CALORIES_FOR_SNACK = 1800
    
    # With snack adjustments
    BREAKFAST_WITH_SNACK = 0.225  # 25% * 0.9
    LUNCH_WITH_SNACK = 0.315      # 35% * 0.9
    DINNER_WITH_SNACK = 0.27      # 30% * 0.9


class NutritionConstants:
    """Constants for nutrition calculations."""
    
    # Calorie per gram of macronutrients
    CALORIES_PER_GRAM_PROTEIN = 4
    CALORIES_PER_GRAM_CARBS = 4
    CALORIES_PER_GRAM_FAT = 9
    
    # Validation tolerances
    CALORIE_TOLERANCE_PERCENT = 0.20  # 20% tolerance for calorie validation
    TOTAL_CALORIE_TOLERANCE_PERCENT = 0.05  # 5% tolerance for total calories
    
    # Default confidence scores
    DEFAULT_FOOD_CONFIDENCE = 1.0
    MIN_CONFIDENCE_THRESHOLD = 0.5


class PortionUnits:
    """Valid units for portion sizes."""
    
    WEIGHT_UNITS = ["g", "oz", "kg", "lb"]
    VOLUME_UNITS = ["ml", "l", "cup", "tbsp", "tsp", "fl oz"]
    COUNT_UNITS = ["piece", "serving", "slice", "unit"]
    
    ALL_UNITS = WEIGHT_UNITS + VOLUME_UNITS + COUNT_UNITS
    
    # Conversion factors to grams (approximate)
    TO_GRAMS = {
        "g": 1,
        "oz": 28.35,
        "kg": 1000,
        "lb": 453.59,
        "cup": 240,  # Approximate, varies by ingredient
        "tbsp": 15,  # Approximate
        "tsp": 5,    # Approximate
    }


class GPTPromptConstants:
    """Constants for GPT prompts."""
    
    # Response format version
    RESPONSE_FORMAT_VERSION = "1.0"
    
    # Confidence thresholds
    HIGH_CONFIDENCE = 0.8
    MEDIUM_CONFIDENCE = 0.6
    LOW_CONFIDENCE = 0.4
    
    # Token limits
    MAX_OUTPUT_TOKENS = 2000
    MAX_PROMPT_LENGTH = 4000


class MealPlanningConstants:
    """Constants for meal planning."""
    
    # Cooking time defaults (minutes)
    DEFAULT_WEEKDAY_COOKING_TIME = 30
    DEFAULT_WEEKEND_COOKING_TIME = 60
    MAX_SNACK_PREP_TIME = 15
    
    # Meal variety
    MIN_DAYS_BEFORE_REPEAT = 3
    MAX_CUISINE_REPEATS_PER_WEEK = 2
    
    # Plan duration
    WEEKLY_PLAN_DAYS = 7
    DAILY_PLAN_DAYS = 1


class TDEEConstants:
    """Constants for TDEE calculations."""
    
    # Activity level multipliers
    ACTIVITY_MULTIPLIERS = {
        "sedentary": 1.2,
        "light": 1.375,
        "moderate": 1.55,
        "active": 1.725,
        "extra": 1.9
    }
    
    # Goal adjustments (calories)
    CUTTING_DEFICIT = 500      # 500 calorie deficit
    BULKING_SURPLUS = 300      # 300 calorie surplus (lean bulk)
    # MAINTENANCE_ADJUSTMENT removed - use RECOMP_ADJUSTMENT instead
    RECOMP_ADJUSTMENT = 0      # No calorie adjustment for recomposition

    # Goal-specific macro ratios (protein/carbs/fat)
    # Based on nutrition science: higher protein during deficit/recomp, higher carbs during bulk
    MACRO_RATIOS = {
        "bulk": {
            "protein": 0.30,
            "carbs": 0.45,
            "fat": 0.25
        },
        "cut": {
            "protein": 0.35,
            "carbs": 0.40,
            "fat": 0.25
        },
        "recomp": {
            "protein": 0.35,
            "carbs": 0.40,
            "fat": 0.25
        }
    }
    
    # Validation ranges
    MIN_AGE = 13
    MAX_AGE = 120
    MIN_WEIGHT_KG = 30
    MAX_WEIGHT_KG = 300
    MIN_HEIGHT_CM = 100
    MAX_HEIGHT_CM = 250
    MIN_BODY_FAT_PCT = 3
    MAX_BODY_FAT_PCT = 60


class ConversationConstants:
    """Constants for conversation flow."""
    
    # Message limits
    MAX_MESSAGE_LENGTH = 1000
    MAX_CONVERSATION_MESSAGES = 100
    
    # Timeout settings
    CONVERSATION_TIMEOUT_MINUTES = 30
    
    # Retry limits
    MAX_GENERATION_RETRIES = 3
    
    # Common responses
    ERROR_RESPONSE = "I'm sorry, something went wrong. Let's try again."
    TIMEOUT_RESPONSE = "This conversation has timed out. Please start a new one."
</file>

<file path="src/domain/model/meal_suggestion/suggestion_session.py">
"""Suggestion session for tracking user's meal generation flow."""

from dataclasses import dataclass, field
from datetime import datetime, timedelta
from typing import List, Optional


@dataclass
class SuggestionSession:
    """Session tracking for meal suggestion flow (4-hour lifetime)."""

    id: str
    user_id: str
    meal_type: str  # breakfast, lunch, dinner, snack
    meal_portion_type: str  # snack, main, omad
    target_calories: int
    ingredients: List[str]
    cooking_time_minutes: int
    shown_suggestion_ids: List[str] = field(default_factory=list)
    dietary_preferences: List[str] = field(default_factory=list)
    allergies: List[str] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.utcnow)
    expires_at: Optional[datetime] = None

    def add_shown_ids(self, ids: List[str]) -> None:
        """Add newly shown suggestion IDs to exclusion list."""
        self.shown_suggestion_ids.extend(ids)

    def __post_init__(self) -> None:
        """Set expiration if not provided."""
        if self.expires_at is None:
            self.expires_at = self.created_at + timedelta(hours=4)
</file>

<file path="src/domain/ports/user_repository_port.py">
"""
UserRepositoryPort - Interface for user repository operations.
"""
from abc import ABC, abstractmethod
from typing import Optional, List
from datetime import datetime

from src.infra.database.models.user import User, UserProfile


class UserRepositoryPort(ABC):
    """Interface for user repository operations."""
    
    @abstractmethod
    def save(self, user: User) -> User:
        """Save or update a user."""
        pass
    
    @abstractmethod
    def find_by_id(self, user_id: str) -> Optional[User]:
        """Find a user by ID."""
        pass
    
    @abstractmethod
    def find_by_firebase_uid(self, firebase_uid: str) -> Optional[User]:
        """Find a user by Firebase UID."""
        pass
    
    @abstractmethod
    def find_by_email(self, email: str) -> Optional[User]:
        """Find a user by email."""
        pass
    
    @abstractmethod
    def find_all(self, limit: int = 100, offset: int = 0) -> List[User]:
        """Find all users with pagination."""
        pass
    
    @abstractmethod
    def delete(self, user_id: str) -> bool:
        """Delete a user by ID."""
        pass
    
    @abstractmethod
    def update_last_accessed(self, user_id: str, timestamp: datetime) -> bool:
        """Update user's last accessed timestamp."""
        pass
    
    @abstractmethod
    def get_profile(self, user_id: str) -> Optional[UserProfile]:
        """Get user profile by user ID."""
        pass
    
    @abstractmethod
    def update_profile(self, user_id: str, profile: UserProfile) -> UserProfile:
        """Update user profile."""
        pass
</file>

<file path="src/domain/prompts/daily_meal_plan_prompt.py">
"""
Prompt templates for daily meal plan generation.
"""
from typing import Dict, Any

from src.domain.model.meal_planning import MealType
from src.domain.model.meal_planning import SimpleMacroTargets


def build_single_meal_prompt(meal_type: MealType, calorie_target: float, user_preferences: Dict[str, Any]) -> str:
    """Build prompt for generating a single meal."""
    
    # Extract user data
    goal = user_preferences.get('goal', 'maintain_weight')
    dietary_prefs = user_preferences.get('dietary_preferences', [])
    health_conditions = user_preferences.get('health_conditions', [])
    target_macros = user_preferences.get('target_macros', {})
    activity_level = user_preferences.get('activity_level', 'moderately_active')
    
    # Calculate macro targets for this meal
    meal_percentage = calorie_target / user_preferences.get('target_calories', 2000)
    
    # Handle both MacroTargets object and dict format
    if isinstance(target_macros, SimpleMacroTargets):
        protein_target = target_macros.protein * meal_percentage
        carbs_target = target_macros.carbs * meal_percentage
        fat_target = target_macros.fat * meal_percentage
    else:
        # Legacy dict format
        protein_target = target_macros.get('protein_grams', 50) * meal_percentage
        carbs_target = target_macros.get('carbs_grams', 250) * meal_percentage
        fat_target = target_macros.get('fat_grams', 65) * meal_percentage
    
    # Build dietary restrictions string
    dietary_str = ", ".join(dietary_prefs) if dietary_prefs else "none"
    health_str = ", ".join(health_conditions) if health_conditions else "none"
    
    # Goal-specific guidance
    goal_guidance = {
        'lose_weight': "Focus on high-volume, low-calorie foods with plenty of fiber and protein for satiety",
        'gain_weight': "Include calorie-dense, nutritious foods with healthy fats and complex carbs",
        'build_muscle': "Emphasize high protein content with complete amino acids",
        'maintain_weight': "Create balanced meals with appropriate portions"
    }
    
    return f"""Generate a {meal_type.value} meal suggestion with these requirements:

User Profile:
- Fitness Goal: {goal} - {goal_guidance.get(goal, 'balanced nutrition')}
- Activity Level: {activity_level}
- Dietary Restrictions: {dietary_str}
- Health Conditions: {health_str}

Nutritional Targets for this meal:
- Calories: {int(calorie_target)} (±50 calories)
- Protein: {int(protein_target)}g
- Carbs: {int(carbs_target)}g
- Fat: {int(fat_target)}g

Requirements:
1. The meal should be practical and use common ingredients
2. Cooking time should be reasonable for {meal_type.value}
3. Must respect all dietary restrictions
4. Should support the user's fitness goal
5. Include variety and flavor

Return ONLY a JSON object with this structure:
{{
    "name": "Meal name",
    "description": "Brief appealing description",
    "prep_time": 10,
    "cook_time": 20,
    "calories": {int(calorie_target)},
    "protein": {int(protein_target)},
    "carbs": {int(carbs_target)},
    "fat": {int(fat_target)},
    "ingredients": ["ingredient 1 with amount", "ingredient 2 with amount"],
    "instructions": ["Step 1", "Step 2"],
    "is_vegetarian": true/false,
    "is_vegan": true/false,
    "is_gluten_free": true/false,
    "cuisine_type": "cuisine type"
}}"""


def build_ingredient_based_meal_prompt(meal_type: MealType, calorie_target: int, request_data: Dict[str, Any]) -> str:
    """Build prompt for ingredient-based meal generation."""
    
    available_ingredients = request_data.get('available_ingredients', [])
    available_seasonings = request_data.get('available_seasonings', [])
    dietary_preferences = request_data.get('dietary_preferences', [])
    allergies = request_data.get('allergies', [])
    
    # Format ingredients list
    ingredients_text = ", ".join(available_ingredients)
    seasonings_text = ", ".join(available_seasonings) if available_seasonings else "basic seasonings"
    
    prompt = f"""Create a {meal_type.value} recipe using these available ingredients: {ingredients_text}
Available seasonings: {seasonings_text}
Target calories: {calorie_target}

IMPORTANT: Only use the ingredients listed above. Do not add any other ingredients.
"""
    
    if dietary_preferences:
        prompt += f"Dietary preferences: {', '.join(dietary_preferences)}\n"
    
    if allergies:
        prompt += f"Allergies to avoid: {', '.join(allergies)}\n"
    
    prompt += f"""
Create a simple, practical recipe that:
- Uses ONLY the available ingredients listed above
- Creates a balanced and nutritious {meal_type.value}
- Is easy to prepare
- CRITICAL: NEVER use any ingredients that match the allergies listed above

Respond with valid JSON only:
{{
    "name": "Recipe Name",
    "description": "Brief description",
    "calories": {calorie_target},
    "protein": 25.0,
    "carbs": 35.0,
    "fat": 15.0,
    "prep_time": 15,
    "cook_time": 20,
    "ingredients": ["chicken", "broccoli", "rice"],
    "instructions": ["step 1", "step 2"],
    "is_vegetarian": false,
    "is_vegan": false,
    "is_gluten_free": true,
    "cuisine_type": "International"
}}"""
    
    return prompt


def get_system_message() -> str:
    """Get system message for daily meal planning."""
    return "You are a professional nutritionist creating personalized meal suggestions."


def build_quick_meal_suggestions_prompt(
    meal_type: str,
    ingredients: list[str],
    time_filter: str | None = None,
    count: int = 6
) -> str:
    """
    Build prompt for quick meal suggestions with enriched output.

    Args:
        meal_type: Type of meal (breakfast, lunch, dinner, snack)
        ingredients: List of available/desired ingredients
        time_filter: Optional time constraint (any, quick, moderate, extended)
        count: Number of meal ideas to generate (default 6)

    Returns:
        Prompt string for AI generation
    """

    # Build ingredients text
    ingredients_text = ", ".join(ingredients) if ingredients else "any common ingredients"

    # Build time constraint section
    time_constraint = ""
    if time_filter and time_filter != "any":
        time_limits = {
            "quick": ("under 15 minutes", 15),
            "moderate": ("15-30 minutes", 30),
            "extended": ("30-60 minutes", 60),
        }
        description, max_time = time_limits.get(time_filter, ("any time", 999))
        time_constraint = f"""
Time Constraint: {description}
- All meals MUST be completable within {max_time} minutes total
- Prioritize quick cooking methods if needed
"""

    return f"""Generate {count} quick {meal_type} meal ideas using these ingredients: {ingredients_text}
{time_constraint}
Requirements:
1. Each meal should prominently feature the provided ingredients
2. Include practical, achievable recipes
3. Vary the cooking styles and cuisines
4. Be creative but realistic

For each meal, provide:
- name: Catchy meal name
- description: Short tagline (10 words max)
- time_minutes: Total cooking time in minutes
- calories: Estimated calories
- protein_g, carbs_g, fat_g: Macros in grams
- pairs_with: List of 3-5 complementary ingredients that would enhance this meal
- quick_recipe: List of 4-6 simple cooking steps
- tags: List of relevant tags like "quick", "high-protein", "low-carb", etc.

Return ONLY a JSON object with this structure:
{{
    "meals": [
        {{
            "name": "Meal Name",
            "description": "Quick, flavorful tagline",
            "time_minutes": 15,
            "calories": 400,
            "protein_g": 30.0,
            "carbs_g": 40.0,
            "fat_g": 12.0,
            "pairs_with": ["avocado", "lemon", "cherry tomatoes"],
            "quick_recipe": [
                "Season the protein with salt and pepper",
                "Heat pan with olive oil",
                "Cook until golden",
                "Serve with sides"
            ],
            "tags": ["quick", "high-protein", "low-carb"]
        }}
    ]
}}

Generate exactly {count} different meal ideas."""
</file>

<file path="src/domain/prompts/meal_suggestion_prompt.py">
"""
Prompt for generating meal suggestions.
"""
from typing import List, Optional


def generate_meal_suggestion_prompt(
    meal_type: str,
    calorie_target: int,
    ingredients: List[str],
    time_available_minutes: Optional[int],
    dietary_preferences: List[str],
    exclude_names: List[str]
) -> tuple[str, str]:
    """
    Generate prompt for creating exactly 3 meal suggestions.
    
    Args:
        meal_type: Type of meal (breakfast, lunch, dinner, snack)
        calorie_target: Target calories for the meal
        ingredients: Available ingredients
        time_available_minutes: Time constraint in minutes
        dietary_preferences: Dietary preferences
        exclude_names: Meal names to exclude (for regeneration)
    
    Returns:
        Tuple of (prompt, system_message)
    """
    
    # Build system message
    system_message = """You are a professional nutritionist and chef assistant.
Generate exactly 3 meal suggestions based on the user's requirements.
Each suggestion should be realistic, nutritious, and delicious.
Return ONLY valid JSON with no additional text or markdown formatting."""
    
    # Build user prompt
    prompt_parts = [
        f"Generate exactly 3 different {meal_type} meal suggestions with the following requirements:",
        f"\n**Target Calories per Meal:** {calorie_target} calories (±50 calories is acceptable)",
    ]
    
    # Add ingredients constraint
    if ingredients:
        ingredients_str = ", ".join(ingredients)
        prompt_parts.append(f"\n**Available Ingredients:** {ingredients_str}")
        prompt_parts.append("Try to use these ingredients, but you can add common pantry items.")
    
    # Add time constraint
    if time_available_minutes:
        prompt_parts.append(f"\n**Time Constraint:** Total cooking time (prep + cook) must be ≤ {time_available_minutes} minutes")
    
    # Add dietary preferences
    if dietary_preferences:
        prefs_str = ", ".join(dietary_preferences)
        prompt_parts.append(f"\n**Dietary Preferences:** {prefs_str}")
    
    # Add exclusion list
    if exclude_names:
        exclude_str = ", ".join(exclude_names)
        prompt_parts.append(f"\n**Exclude these meals (already suggested):** {exclude_str}")
        prompt_parts.append("Generate completely different meals from these.")
    
    # Add output format requirements
    prompt_parts.append("""

**Output Format:**
Return a JSON object with this exact structure:
{
  "suggestions": [
    {
      "name": "Meal Name",
      "description": "Brief appetizing description (1-2 sentences)",
      "prep_time": 10,
      "cook_time": 15,
      "calories": 520,
      "protein": 35.0,
      "carbs": 45.0,
      "fat": 18.0,
      "ingredients": ["ingredient with portion", "another ingredient with portion"],
      "seasonings": ["seasoning 1", "seasoning 2"],
      "instructions": ["Step 1", "Step 2", "Step 3"],
      "is_vegetarian": false,
      "is_vegan": false,
      "is_gluten_free": false,
      "cuisine_type": "Italian"
    }
  ]
}

**Important Requirements:**
1. Generate EXACTLY 3 suggestions in the "suggestions" array
2. Each meal should be unique and different from the others
3. Include specific portions for ingredients (e.g., "200g chicken breast", "1 cup rice")
4. Ensure prep_time + cook_time meets the time constraint if specified
5. Calories should be close to the target (within ±50 calories)
6. Macros (protein, carbs, fat) should be realistic and add up correctly
7. Instructions should be clear and actionable
8. Set dietary flags (is_vegetarian, is_vegan, is_gluten_free) accurately
9. Specify cuisine_type (e.g., Italian, Asian, Mexican, American, Mediterranean)
""")
    
    prompt = "".join(prompt_parts)
    
    return prompt, system_message
</file>

<file path="src/domain/services/conversation/conversation_handler.py">
"""Conversation state handler logic."""
import logging
from typing import Optional, Tuple

from src.domain.model.conversation import Conversation, ConversationContext, ConversationState
from src.domain.model.meal_planning import (
    UserPreferences, DietaryPreference, FitnessGoal, PlanDuration, MealPlan, MealType
)
from src.domain.services.conversation.conversation_parser import ConversationParser
from src.domain.services.conversation.conversation_formatter import ConversationFormatter
from src.domain.services.meal_plan_service import MealPlanService

logger = logging.getLogger(__name__)


class ConversationHandler:
    """Handles conversation state transitions and responses."""

    def __init__(self, meal_plan_service: MealPlanService):
        self.meal_plan_service = meal_plan_service
        self.parser = ConversationParser()
        self.formatter = ConversationFormatter()

    def handle_greeting(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle initial greeting."""
        response = ("Great! Let's plan your meals. First, could you tell me your "
                   "**dietary preferences or restrictions**? (For example: vegan, gluten-free, keto, etc.)")
        conversation.update_state(ConversationState.ASKING_DIETARY_PREFERENCES)
        return response, True, None

    def handle_dietary_preferences(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle dietary preferences input."""
        preferences = self.parser.parse_dietary_preferences(user_message)
        conversation.context.dietary_preferences = preferences

        response = (f"Got it – {self.formatter.format_list(preferences)}. 👍 "
                   "Next, do you have any **food allergies** I should know about?")
        conversation.update_state(ConversationState.ASKING_ALLERGIES)
        return response, True, None

    def handle_allergies(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle allergies input."""
        allergies = self.parser.parse_allergies(user_message)
        conversation.context.allergies = allergies

        if allergies:
            response = "Perfect. I'll make sure to avoid those. "
        else:
            response = "Perfect. "

        response += "Now, what are your **health or fitness goals**? (For example: weight loss, muscle gain, maintenance...)"
        conversation.update_state(ConversationState.ASKING_FITNESS_GOALS)
        return response, True, None

    def handle_fitness_goals(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle fitness goals input."""
        goal = self.parser.parse_fitness_goal(user_message)
        conversation.context.fitness_goal = goal

        nutrition_focus = {
            FitnessGoal.BULK.value: "I'll make sure to include high-protein options",
            FitnessGoal.CUT.value: "I'll focus on balanced, calorie-controlled meals",
            FitnessGoal.RECOMP.value: "I'll create well-balanced, high-protein meals",
        }

        default_msg = "I'll create appropriate meals for your goal"
        response = (f"Great, thanks! {nutrition_focus.get(goal, default_msg)}. "
                   "How many **meals per day** would you like me to plan?")
        conversation.update_state(ConversationState.ASKING_MEAL_COUNT)
        return response, True, None

    def handle_meal_count(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle meal count input."""
        meals, snacks = self.parser.parse_meal_count(user_message)
        conversation.context.meals_per_day = meals
        conversation.context.snacks_per_day = snacks

        response = (f"Okay. And are we planning for **just one day or a full week** of meals?")
        conversation.update_state(ConversationState.ASKING_PLAN_DURATION)
        return response, True, None

    def handle_plan_duration(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle plan duration input."""
        duration = self.parser.parse_plan_duration(user_message)
        conversation.context.plan_duration = duration

        duration_text = "week-long" if duration == PlanDuration.WEEKLY.value else "daily"
        response = (f"Excellent. I'll prepare a {duration_text} meal plan with {conversation.context.meals_per_day} meals "
                   f"and {conversation.context.snacks_per_day} snacks per day. "
                   "One more thing: how much **time do you usually have to cook** each meal?")
        conversation.update_state(ConversationState.ASKING_COOKING_TIME)
        return response, True, None

    def handle_cooking_time(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle cooking time input."""
        weekday_time, weekend_time = self.parser.parse_cooking_time(user_message)
        conversation.context.cooking_time_weekday = weekday_time
        conversation.context.cooking_time_weekend = weekend_time

        response = ("Understood. I'll keep weeknight recipes quick and use the weekends for anything that takes longer. 🤗 "
                   "Lastly, any specific **ingredients or cuisines you love or want to avoid**?")
        conversation.update_state(ConversationState.ASKING_CUISINE_PREFERENCES)
        return response, True, None

    def handle_cuisine_preferences(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle cuisine preferences input."""
        favorites, dislikes = self.parser.parse_cuisine_preferences(user_message)
        conversation.context.favorite_cuisines = favorites
        conversation.context.disliked_ingredients = dislikes

        summary = self.formatter.build_preferences_summary(conversation.context)
        response = (f"Thanks for the details! 🎉 Let's recap quickly: {summary} Sound good?")
        conversation.update_state(ConversationState.CONFIRMING_PREFERENCES)
        return response, True, None

    def handle_confirmation(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle confirmation."""
        if self.parser.is_affirmative(user_message):
            response = "Perfect! Give me a moment to generate your personalized meal plan... 🤖🍳"
            conversation.update_state(ConversationState.GENERATING_PLAN)
            return self.handle_plan_generation(conversation, user_message)
        else:
            response = "No problem! What would you like me to change?"
            return response, True, None

    def handle_plan_generation(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Generate the meal plan."""
        try:
            preferences = self._create_user_preferences(conversation.context)
            meal_plan = self.meal_plan_service.generate_meal_plan(
                user_id=conversation.user_id,
                preferences=preferences
            )

            conversation.context.current_meal_plan = meal_plan.plan_id
            response = self.formatter.format_meal_plan_response(meal_plan)
            conversation.update_state(ConversationState.SHOWING_PLAN)

            return response, True, meal_plan.plan_id

        except Exception as e:
            logger.error(f"Error generating meal plan: {str(e)}")
            response = ("I'm sorry, I encountered an error while generating your meal plan. "
                       "Let's try again. What type of meals would you like?")
            conversation.update_state(ConversationState.ASKING_DIETARY_PREFERENCES)
            return response, True, None

    def handle_showing_plan(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle user response after showing plan."""
        if "change" in user_message.lower() or "swap" in user_message.lower() or "replace" in user_message.lower():
            response = ("Sure! Which meal would you like to change? Please specify the day and meal "
                       "(e.g., 'Monday dinner' or 'Tuesday breakfast')")
            conversation.update_state(ConversationState.ADJUSTING_MEAL)
            return response, True, conversation.context.current_meal_plan
        elif self.parser.is_negative(user_message):
            response = "I'm sorry the plan doesn't meet your needs. Would you like to start over with different preferences?"
            return response, True, conversation.context.current_meal_plan
        else:
            response = ("Great! I'm glad you're happy with the meal plan. I'll save this weekly plan for you. "
                       "You can always come back and ask me to regenerate or tweak meals if your preferences "
                       "or schedule change. Enjoy your meals! 🥦💪")
            conversation.update_state(ConversationState.COMPLETED)
            return response, False, conversation.context.current_meal_plan

    def handle_meal_adjustment(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle meal adjustment requests."""
        response = ("I'll generate a new option for that meal. "
                   "Would you prefer any specific cuisine or have any additional requirements for this meal?")
        conversation.update_state(ConversationState.SHOWING_PLAN)
        return response, True, conversation.context.current_meal_plan

    def handle_completed(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """Handle completed state."""
        response = "Thank you! Feel free to start a new conversation if you need another meal plan."
        return response, False, conversation.context.current_meal_plan

    def _create_user_preferences(self, context: ConversationContext) -> UserPreferences:
        """Create UserPreferences from conversation context."""
        dietary_prefs = []
        for pref in context.dietary_preferences or ["none"]:
            try:
                dietary_prefs.append(DietaryPreference(pref))
            except ValueError:
                dietary_prefs.append(DietaryPreference.NONE)

        fitness_goal = FitnessGoal(context.fitness_goal or "general_health")
        plan_duration = PlanDuration(context.plan_duration or "weekly")

        return UserPreferences(
            dietary_preferences=dietary_prefs,
            allergies=context.allergies or [],
            fitness_goal=fitness_goal,
            meals_per_day=context.meals_per_day or 3,
            snacks_per_day=context.snacks_per_day or 0,
            cooking_time_weekday=context.cooking_time_weekday or 30,
            cooking_time_weekend=context.cooking_time_weekend or 60,
            favorite_cuisines=context.favorite_cuisines or [],
            disliked_ingredients=context.disliked_ingredients or [],
            plan_duration=plan_duration
        )
</file>

<file path="src/domain/services/conversation/conversation_parser.py">
"""Conversation input parsing logic."""

import re
from typing import List, Tuple
from src.domain.model.meal_planning import FitnessGoal, PlanDuration


class ConversationParser:
    """Parses user input in conversations."""

    @staticmethod
    def parse_dietary_preferences(message: str) -> List[str]:
        """Parse dietary preferences from user message."""
        message_lower = message.lower()
        preferences = []

        preference_keywords = {
            "vegan": ["vegan"],
            "vegetarian": ["vegetarian"],
            "gluten_free": ["gluten-free", "gluten free", "celiac"],
            "keto": ["keto", "ketogenic"],
            "paleo": ["paleo"],
            "low_carb": ["low-carb", "low carb"],
            "dairy_free": ["dairy-free", "dairy free", "lactose"],
            "pescatarian": ["pescatarian", "fish"],
        }

        for pref, keywords in preference_keywords.items():
            if any(keyword in message_lower for keyword in keywords):
                preferences.append(pref)

        if not preferences and ("none" in message_lower or "no" in message_lower):
            preferences.append("none")

        return preferences if preferences else ["none"]

    @staticmethod
    def parse_allergies(message: str) -> List[str]:
        """Parse allergies from user message."""
        message_lower = message.lower()

        if "no" in message_lower or "none" in message_lower:
            return []

        # Common allergens
        allergens = [
            "nuts",
            "peanuts",
            "shellfish",
            "fish",
            "eggs",
            "milk",
            "dairy",
            "soy",
            "wheat",
            "gluten",
            "sesame",
            "tree nuts",
        ]

        found_allergies = []
        for allergen in allergens:
            if allergen in message_lower:
                found_allergies.append(allergen)

        return found_allergies

    @staticmethod
    def parse_fitness_goal(message: str) -> str:
        """Parse fitness goal from user message."""
        message_lower = message.lower()

        if (
            "muscle" in message_lower
            or "gain" in message_lower
            or "bulk" in message_lower
        ):
            return FitnessGoal.BULK.value
        elif (
            "loss" in message_lower or "lose" in message_lower or "cut" in message_lower
        ):
            return FitnessGoal.CUT.value
        elif (
            "recomp" in message_lower
            or "recomposition" in message_lower
            or "tone" in message_lower
        ):
            return FitnessGoal.RECOMP.value
        else:
            # Default to recomp (balanced approach)
            return FitnessGoal.RECOMP.value

    @staticmethod
    def parse_meal_count(message: str) -> Tuple[int, int]:
        """Parse meal and snack count from user message."""
        # Extract numbers from message
        numbers = re.findall(r"\d+", message)

        meals = 3  # default
        snacks = 0  # default

        if numbers:
            meals = int(numbers[0])
            if len(numbers) > 1:
                snacks = int(numbers[1])
            elif "snack" in message.lower():
                # If they mention snacks but only one number, assume 2 snacks
                snacks = 2

        # Reasonable limits
        meals = max(1, min(6, meals))
        snacks = max(0, min(4, snacks))

        return meals, snacks

    @staticmethod
    def parse_plan_duration(message: str) -> str:
        """Parse plan duration from user message."""
        message_lower = message.lower()

        if "week" in message_lower or "weekly" in message_lower:
            return PlanDuration.WEEKLY.value
        elif "day" in message_lower or "daily" in message_lower:
            return PlanDuration.DAILY.value
        else:
            # Default to weekly
            return PlanDuration.WEEKLY.value

    @staticmethod
    def parse_cooking_time(message: str) -> Tuple[int, int]:
        """Parse cooking time from user message."""
        # Extract numbers
        numbers = re.findall(r"\d+", message)

        weekday_time = 30  # default
        weekend_time = 60  # default

        if numbers:
            weekday_time = int(numbers[0])
            if len(numbers) > 1:
                weekend_time = int(numbers[1])
            else:
                # If only one time given, assume more time on weekends
                weekend_time = int(weekday_time * 1.5)

        return weekday_time, weekend_time

    @staticmethod
    def parse_cuisine_preferences(message: str) -> Tuple[List[str], List[str]]:
        """Parse cuisine preferences and dislikes from user message."""
        message_lower = message.lower()

        # Common cuisines
        cuisines = [
            "italian",
            "mexican",
            "asian",
            "chinese",
            "japanese",
            "thai",
            "indian",
            "mediterranean",
            "american",
            "french",
            "greek",
            "spanish",
        ]

        favorites = []
        for cuisine in cuisines:
            if cuisine in message_lower:
                favorites.append(cuisine.capitalize())

        # Parse dislikes
        dislikes = []
        if (
            "avoid" in message_lower
            or "don't like" in message_lower
            or "dislike" in message_lower
        ):
            # Simple parsing - in production, use NLP
            dislike_section = (
                message_lower.split("avoid")[-1]
                if "avoid" in message_lower
                else message_lower
            )

            # Common ingredients to check
            ingredients = [
                "tofu",
                "mushroom",
                "onion",
                "garlic",
                "spicy",
                "dairy",
                "egg",
            ]
            for ingredient in ingredients:
                if ingredient in dislike_section:
                    dislikes.append(ingredient)

        return favorites, dislikes

    @staticmethod
    def is_affirmative(message: str) -> bool:
        """Check if message is affirmative."""
        affirmative_words = [
            "yes",
            "yeah",
            "yep",
            "sure",
            "ok",
            "okay",
            "correct",
            "right",
            "sounds good",
            "perfect",
            "great",
        ]
        return any(word in message.lower() for word in affirmative_words)

    @staticmethod
    def is_negative(message: str) -> bool:
        """Check if message is negative."""
        negative_words = ["no", "nope", "not", "wrong", "incorrect", "bad"]
        return any(word in message.lower() for word in negative_words)
</file>

<file path="src/domain/services/meal_suggestion/suggestion_prompt_builder.py">
"""Prompt building for meal suggestions."""
from typing import Dict, Any, Optional, TYPE_CHECKING
from src.domain.model.meal_planning import MealType, SimpleMacroTargets

if TYPE_CHECKING:
    from src.domain.model.meal_suggestion import SuggestionSession
    from src.domain.services.meal_suggestion.recipe_search_service import RecipeSearchResult


class SuggestionPromptBuilder:
    """Builds prompts for meal suggestion generation."""

    @staticmethod
    def build_meal_suggestion_prompt(
        meal_type: MealType, calorie_target: float, user_preferences: Dict
    ) -> str:
        """Build prompt for single meal generation."""
        # Extract user data
        goal = user_preferences.get('goal', 'maintain_weight')
        dietary_prefs = user_preferences.get('dietary_preferences', [])
        health_conditions = user_preferences.get('health_conditions', [])
        target_macros = user_preferences.get('target_macros', {})
        activity_level = user_preferences.get('activity_level', 'moderately_active')

        # Calculate macro targets for this meal
        total_target_calories = user_preferences.get('target_calories')
        if not total_target_calories:
            raise ValueError("target_calories is required in user_preferences")
        meal_percentage = calorie_target / total_target_calories

        # Handle both MacroTargets object and dict format
        if isinstance(target_macros, SimpleMacroTargets):
            protein_target = target_macros.protein * meal_percentage
            carbs_target = target_macros.carbs * meal_percentage
            fat_target = target_macros.fat * meal_percentage
        else:
            # Legacy dict format
            protein_target = target_macros.get('protein_grams', 50) * meal_percentage
            carbs_target = target_macros.get('carbs_grams', 250) * meal_percentage
            fat_target = target_macros.get('fat_grams', 65) * meal_percentage

        # Build dietary restrictions string
        dietary_str = ", ".join(dietary_prefs) if dietary_prefs else "none"
        health_str = ", ".join(health_conditions) if health_conditions else "none"

        # Goal-specific guidance
        goal_guidance = {
            'lose_weight': "Focus on high-volume, low-calorie foods with plenty of fiber and protein for satiety",
            'gain_weight': "Include calorie-dense, nutritious foods with healthy fats and complex carbs",
            'build_muscle': "Emphasize high protein content with complete amino acids",
            'maintain_weight': "Create balanced meals with appropriate portions"
        }

        prompt = f"""Generate a {meal_type.value} meal suggestion with these requirements:

User Profile:
- Fitness Goal: {goal} - {goal_guidance.get(goal, 'balanced nutrition')}
- Activity Level: {activity_level}
- Dietary Restrictions: {dietary_str}
- Health Conditions: {health_str}

Nutritional Targets for this meal:
- Calories: {int(calorie_target)} (±50 calories)
- Protein: {int(protein_target)}g
- Carbs: {int(carbs_target)}g
- Fat: {int(fat_target)}g

Requirements:
1. The meal should be practical and use common ingredients
2. Cooking time should be reasonable for {meal_type.value}
3. Must respect all dietary restrictions
4. Should support the user's fitness goal
5. Include variety and flavor

Return ONLY a JSON object with this structure:
{{
    "name": "Meal name",
    "description": "Brief appealing description",
    "prep_time": 10,
    "cook_time": 20,
    "calories": {int(calorie_target)},
    "protein": {int(protein_target)},
    "carbs": {int(carbs_target)},
    "fat": {int(fat_target)},
    "ingredients": ["ingredient 1 with amount", "ingredient 2 with amount"],
    "instructions": ["Step 1", "Step 2"],
    "is_vegetarian": true/false,
    "is_vegan": true/false,
    "is_gluten_free": true/false,
    "cuisine_type": "cuisine type"
}}"""

        return prompt

    @staticmethod
    def build_unified_meal_prompt(meal_distribution: Dict[MealType, float], user_preferences: Dict) -> str:
        """Build a unified prompt for generating all daily meals at once."""
        # Extract user data
        goal = user_preferences.get('goal', 'maintain_weight')
        dietary_prefs = user_preferences.get('dietary_preferences', [])
        health_conditions = user_preferences.get('health_conditions', [])
        target_macros = user_preferences.get('target_macros', {})
        activity_level = user_preferences.get('activity_level', 'moderately_active')
        target_calories = user_preferences.get('target_calories', 2000)

        # Build dietary restrictions string
        dietary_str = ", ".join(dietary_prefs) if dietary_prefs else "none"
        health_str = ", ".join(health_conditions) if health_conditions else "none"

        # Goal-specific guidance
        goal_guidance = {
            'lose_weight': "Focus on high-volume, low-calorie foods with plenty of fiber and protein for satiety",
            'gain_weight': "Include calorie-dense, nutritious foods with healthy fats and complex carbs",
            'build_muscle': "Emphasize high protein content with complete amino acids",
            'maintain_weight': "Create balanced meals with appropriate portions"
        }

        # Build meal targets string
        meal_targets = []
        for meal_type, calorie_target in meal_distribution.items():
            meal_percentage = calorie_target / target_calories

            # Handle both MacroTargets object and dict format
            if isinstance(target_macros, SimpleMacroTargets):
                protein_target = target_macros.protein * meal_percentage
                carbs_target = target_macros.carbs * meal_percentage
                fat_target = target_macros.fat * meal_percentage
            else:
                # Legacy dict format
                protein_target = target_macros.get('protein_grams', 50) * meal_percentage
                carbs_target = target_macros.get('carbs_grams', 250) * meal_percentage
                fat_target = target_macros.get('fat_grams', 65) * meal_percentage

            meal_targets.append(f"""
{meal_type.value.title()}:
- Calories: {int(calorie_target)} (±50 calories)
- Protein: {int(protein_target)}g
- Carbs: {int(carbs_target)}g
- Fat: {int(fat_target)}g""")

        meal_targets_str = "\n".join(meal_targets)

        prompt = f"""Generate a complete daily meal plan with these requirements:

User Profile:
- Fitness Goal: {goal} - {goal_guidance.get(goal, 'balanced nutrition')}
- Activity Level: {activity_level}
- Dietary Restrictions: {dietary_str}
- Health Conditions: {health_str}
- Total Daily Calories: {int(target_calories)}

Nutritional Targets for each meal:
{meal_targets_str}

Requirements:
1. All meals should be practical and use common ingredients
2. Cooking times should be reasonable for each meal type
3. Must respect all dietary restrictions across all meals
4. Should support the user's fitness goal
5. Include variety and flavor across the day
6. Ensure meals complement each other for a balanced day

Return ONLY a JSON object with this structure:
{{
    "meals": [
        {{
            "meal_type": "breakfast",
            "name": "Meal name",
            "description": "Brief appealing description",
            "prep_time": 10,
            "cook_time": 20,
            "calories": 500,
            "protein": 25,
            "carbs": 60,
            "fat": 15,
            "ingredients": ["ingredient 1 with amount", "ingredient 2 with amount"],
            "instructions": ["Step 1", "Step 2"],
            "is_vegetarian": true/false,
            "is_vegan": true/false,
            "is_gluten_free": true/false,
            "cuisine_type": "cuisine type"
        }},
        // ... repeat for each meal type
    ]
}}"""

        return prompt


def build_single_meal_prompt(
    session: "SuggestionSession",
    meal_index: int,
    inspiration_recipe: Optional["RecipeSearchResult"] = None,
) -> str:
    """
    Build compact prompt for generating a single meal.
    Target: ~500 output tokens for fast generation.

    Args:
        session: User's session with preferences
        meal_index: Which meal (0, 1, 2) for variety
        inspiration_recipe: Optional (DEPRECATED - not used)

    Returns:
        Compact prompt string
    """
    ingredients_list = session.ingredients[:8] if session.ingredients else []
    ingredients_str = ", ".join(ingredients_list) if ingredients_list else "common ingredients"

    # REMOVED: Pinecone inspiration (using pure AI prompts for variety instead)

    # Identify protein ingredients for variety guidance
    protein_keywords = ["chicken", "beef", "pork", "fish", "salmon", "tuna", "shrimp", "tofu", "egg", "lamb", "turkey"]
    proteins_available = [ing for ing in ingredients_list if any(p in ing.lower() for p in protein_keywords)]

    # Subtle variety through protein rotation (if multiple proteins available)
    protein_hint = ""
    if len(proteins_available) > 1:
        suggested_protein = proteins_available[meal_index % len(proteins_available)]
        protein_hint = f"Consider featuring {suggested_protein} as the main protein"

    # REMOVED: Style hints (Asian, Mediterranean, etc.) - creates bias
    # REMOVED: Naming hints (Herb-Crusted, Golden, etc.) - creates repetitive patterns

    constraints = []
    if hasattr(session, "allergies") and session.allergies:
        constraints.append(f"⚠️ MUST AVOID: {', '.join(session.allergies)}")
    if hasattr(session, "dietary_preferences") and session.dietary_preferences:
        constraints.append(f"Dietary preferences: {', '.join(session.dietary_preferences)}")

    constraints_str = "\n".join(constraints) if constraints else ""

    return f"""Generate 1 complete {session.meal_type} meal (~{session.target_calories} cal, ≤{session.cooking_time_minutes}min).

INGREDIENTS: {ingredients_str}
{constraints_str}
{protein_hint}

OUTPUT (compact JSON, no whitespace):
{{
  "name": "Dish Name",
  "description": "Brief appetizing description",
  "ingredients": [
    {{"name": "ingredient1", "amount": 200, "unit": "g"}},
    {{"name": "ingredient2", "amount": 100, "unit": "g"}},
    {{"name": "ingredient3", "amount": 150, "unit": "g"}},
    {{"name": "ingredient4", "amount": 1, "unit": "tbsp"}}
  ],
  "recipe_steps": [
    {{"step": 1, "instruction": "Action", "duration_minutes": 5}},
    {{"step": 2, "instruction": "Action", "duration_minutes": 10}},
    {{"step": 3, "instruction": "Action", "duration_minutes": 8}}
  ],
  "prep_time_minutes": 20
}}

CRITICAL RULES:
1. MUST include ALL fields: name, description, ingredients (3-8 items), recipe_steps (2-6 steps), prep_time_minutes
2. MUST complete entire JSON - do NOT truncate
3. Name: Natural dish name (NOT "Quick/Speedy/Power Bowl"). Examples: "Garlic Butter Salmon", "Herb Chicken", "Spicy Beef"
4. Ingredients: Use from INGREDIENTS list, exact amounts (g/ml/tbsp/tsp)
5. Recipe steps: Clear instructions with duration_minutes
6. Return ONLY valid JSON, no markdown/extra text
7. NO calories/protein/carbs/fat fields

⚠️ COMPLETE THE ENTIRE JSON BEFORE STOPPING - all arrays must close properly!

"""


def build_meal_names_prompt(
    session: "SuggestionSession",
) -> str:
    """
    Phase 1: Generate 4 diverse meal names (concise prompt for speed).

    Args:
        session: User's session with preferences

    Returns:
        Prompt for generating 4 meal names
    """
    ingredients_list = session.ingredients[:4] if session.ingredients else []
    ingredients_str = ", ".join(ingredients_list) if ingredients_list else "common ingredients"

    constraints = []
    if hasattr(session, "allergies") and session.allergies:
        constraints.append(f"Avoid: {', '.join(session.allergies)}")
    if hasattr(session, "dietary_preferences") and session.dietary_preferences:
        constraints.append(f"Vegetarian" if "vegetarian" in " ".join(session.dietary_preferences).lower() else "Diet: OK")

    constraints_str = " | " + " | ".join(constraints) if constraints else ""

    return f"""Generate 4 different {session.meal_type} names, ~{session.target_calories}cal, ≤{session.cooking_time_minutes}min.
Ingredients: {ingredients_str}{constraints_str}
Cuisines: 4 distinct (Asian, Mediterranean, Latin, American)
Names: Natural, concise (max 5 words), no "Quick/Healthy/Power" tags."""


def build_recipe_details_prompt(
    meal_name: str,
    session: "SuggestionSession",
) -> str:
    """
    Phase 2: Generate full recipe details for a specific meal name (with structured output schema).
    
    Args:
        meal_name: The meal name to generate recipe for
        session: User's session with preferences
        
    Returns:
        Prompt for generating recipe details
    """
    ingredients_list = session.ingredients[:6] if session.ingredients else []
    ingredients_str = ", ".join(ingredients_list) if ingredients_list else "any ingredients"
    
    constraints_parts = []
    if hasattr(session, "allergies") and session.allergies:
        constraints_parts.append(f"⚠️ AVOID: {', '.join(session.allergies)}")
    if hasattr(session, "dietary_preferences") and session.dietary_preferences:
        constraints_parts.append(f"Diet: {', '.join(session.dietary_preferences)}")
    
    constraints_str = " | ".join(constraints_parts) if constraints_parts else ""
    
    return f"""Generate complete recipe details for: "{meal_name}"

Available ingredients: {ingredients_str}{' | ' + constraints_str if constraints_str else ''}
Target: ~{session.target_calories} calories | ≤{session.cooking_time_minutes} minutes cooking time

CRITICAL - Portion Sizing:
- This meal should be approximately {session.target_calories} calories total
- Use APPROPRIATE portion sizes (e.g., for 800 cal lunch: ~200g protein, ~150g carbs, ~100g vegetables)
- For lower calorie targets (<600 cal), use smaller portions (e.g., 150g protein, 100g carbs)
- For higher calorie targets (>1000 cal), use larger portions (e.g., 300g protein, 200g carbs)

Requirements:
- Recipe must match the meal name "{meal_name}" exactly
- Use 3-8 ingredients from the available list with specific amounts (g, ml, tbsp, tsp)
- Provide 2-6 clear, actionable recipe steps with duration for each step
- Description should highlight the meal's key flavors and appeal
- Total prep_time_minutes must be ≤{session.cooking_time_minutes}

NOTE: Do NOT include nutrition data in response - backend calculates it automatically.

"""
</file>

<file path="src/domain/services/bmr_calculator.py">
"""
BMR (Basal Metabolic Rate) calculation services.

Provides different formulas for calculating BMR based on available user data:
- Mifflin-St Jeor: Standard formula using age, weight, height, and sex
- Katch-McArdle: More accurate formula using lean body mass (requires body fat %)
"""
from abc import ABC, abstractmethod

from src.domain.model.user import Sex


class BMRCalculator(ABC):
    """Abstract base class for BMR calculation strategies."""
    
    @abstractmethod
    def calculate(
        self,
        weight_kg: float,
        height_cm: float,
        age: int,
        sex: Sex,
        body_fat_pct: float | None = None
    ) -> float:
        """Calculate BMR based on user attributes."""
        pass
    
    @abstractmethod
    def get_formula_name(self) -> str:
        """Return the name of the formula used."""
        pass


class MifflinStJeorCalculator(BMRCalculator):
    """
    Mifflin-St Jeor BMR Calculator.
    
    Standard formula for calculating BMR without body composition data.
    Based on age, weight, height, and biological sex.
    
    Formula:
    - Men: BMR = 10 * weight(kg) + 6.25 * height(cm) - 5 * age + 5
    - Women: BMR = 10 * weight(kg) + 6.25 * height(cm) - 5 * age - 161
    """
    
    def calculate(
        self,
        weight_kg: float,
        height_cm: float,
        age: int,
        sex: Sex,
        body_fat_pct: float | None = None
    ) -> float:
        """Calculate BMR using Mifflin-St Jeor equation."""
        base = 10 * weight_kg + 6.25 * height_cm - 5 * age
        
        if sex == Sex.MALE:
            return base + 5
        else:  # Female
            return base - 161
    
    def get_formula_name(self) -> str:
        """Return formula name."""
        return "Mifflin-St Jeor"


class KatchMcArdleCalculator(BMRCalculator):
    """
    Katch-McArdle BMR Calculator.
    
    More accurate formula that accounts for body composition.
    Requires body fat percentage measurement.
    
    Formula:
    - BMR = 370 + (21.6 * lean_mass_kg)
    - Where: lean_mass_kg = weight_kg * (1 - body_fat_pct / 100)
    
    This formula is generally more accurate than Mifflin-St Jeor because it
    accounts for lean body mass, which is the primary determinant of metabolic rate.
    """
    
    def calculate(
        self,
        weight_kg: float,
        height_cm: float,
        age: int,
        sex: Sex,
        body_fat_pct: float | None = None
    ) -> float:
        """Calculate BMR using Katch-McArdle equation."""
        if body_fat_pct is None:
            raise ValueError("Katch-McArdle formula requires body fat percentage")
        
        # Calculate lean body mass
        lean_mass_kg = weight_kg * (1 - body_fat_pct / 100)
        
        # Katch-McArdle formula
        return 370 + (21.6 * lean_mass_kg)
    
    def get_formula_name(self) -> str:
        """Return formula name."""
        return "Katch-McArdle"


class BMRCalculatorFactory:
    """
    Factory for selecting the appropriate BMR calculator.
    
    Strategy:
    - If body fat % is available: Use Katch-McArdle (more accurate)
    - If body fat % is not available: Use Mifflin-St Jeor (standard approach)
    """
    
    @staticmethod
    def get_calculator(has_body_fat: bool) -> BMRCalculator:
        """
        Get the appropriate BMR calculator based on available data.
        
        Args:
            has_body_fat: Whether body fat percentage is available
            
        Returns:
            BMRCalculator instance (Katch-McArdle if body fat available, else Mifflin-St Jeor)
        """
        if has_body_fat:
            return KatchMcArdleCalculator()
        else:
            return MifflinStJeorCalculator()
</file>

<file path="src/domain/services/conversation_service.py">
"""Service for managing meal planning conversations."""
import logging
from typing import Optional, Tuple

from src.domain.model.conversation import Conversation, ConversationState, MessageRole
from src.domain.services.conversation.conversation_handler import ConversationHandler
from src.domain.services.meal_plan_service import MealPlanService

logger = logging.getLogger(__name__)


class ConversationService:
    """Service for managing meal planning conversations."""

    def __init__(self, meal_plan_service: MealPlanService):
        self.handler = ConversationHandler(meal_plan_service)
        self.state_handlers = {
            ConversationState.GREETING: self.handler.handle_greeting,
            ConversationState.ASKING_DIETARY_PREFERENCES: self.handler.handle_dietary_preferences,
            ConversationState.ASKING_ALLERGIES: self.handler.handle_allergies,
            ConversationState.ASKING_FITNESS_GOALS: self.handler.handle_fitness_goals,
            ConversationState.ASKING_MEAL_COUNT: self.handler.handle_meal_count,
            ConversationState.ASKING_PLAN_DURATION: self.handler.handle_plan_duration,
            ConversationState.ASKING_COOKING_TIME: self.handler.handle_cooking_time,
            ConversationState.ASKING_CUISINE_PREFERENCES: self.handler.handle_cuisine_preferences,
            ConversationState.CONFIRMING_PREFERENCES: self.handler.handle_confirmation,
            ConversationState.GENERATING_PLAN: self.handler.handle_plan_generation,
            ConversationState.SHOWING_PLAN: self.handler.handle_showing_plan,
            ConversationState.ADJUSTING_MEAL: self.handler.handle_meal_adjustment,
            ConversationState.COMPLETED: self.handler.handle_completed
        }

    def start_conversation(self, user_id: str) -> Conversation:
        """Start a new meal planning conversation."""
        conversation = Conversation(user_id=user_id)

        greeting = ("Hi there! 👋 I'd be happy to help you plan your meals. "
                   "To get started, could you tell me your **dietary preferences or restrictions**? "
                   "(For example: vegan, gluten-free, keto, etc.)")

        conversation.add_message(MessageRole.ASSISTANT, greeting)
        conversation.update_state(ConversationState.ASKING_DIETARY_PREFERENCES)

        return conversation

    def process_message(self, conversation: Conversation, user_message: str) -> Tuple[str, bool, Optional[str]]:
        """
        Process a user message and return assistant response.

        Returns:
            Tuple of (assistant_message, requires_input, meal_plan_id)
        """
        conversation.add_message(MessageRole.USER, user_message)

        handler = self.state_handlers.get(conversation.state)
        if not handler:
            logger.error(f"No handler for state: {conversation.state}")
            return "I'm sorry, something went wrong. Let's start over.", True, None

        assistant_message, requires_input, meal_plan_id = handler(conversation, user_message)
        conversation.add_message(MessageRole.ASSISTANT, assistant_message)

        return assistant_message, requires_input, meal_plan_id
</file>

<file path="src/domain/services/meal_plan_orchestration_service.py">
"""
Meal plan orchestration service.
Uses the unified LLM adapter with different prompts for different meal plan types.
"""
import logging
from datetime import date
from typing import Dict, Any

from src.domain.model.meal_planning import (
    DailyMealPlan, MealGenerationRequest, MealGenerationType,
    UserDietaryProfile, UserNutritionTargets, IngredientConstraints,
    MealGenerationContext, MealType
)
from src.domain.ports.meal_generation_service_port import MealGenerationServicePort
from src.domain.services.fallback_meal_service import FallbackMealService
from src.domain.services.meal_distribution_service import MealDistributionService
from src.domain.services.meal_type_determination_service import MealTypeDeterminationService
from src.domain.services.prompt_generation_service import PromptGenerationService
from src.domain.services.meal_plan.meal_plan_validator import MealPlanValidator
from src.domain.services.meal_plan.meal_plan_generator import MealPlanGenerator
from src.domain.services.meal_plan.meal_plan_formatter import MealPlanFormatter
from src.domain.services.meal_plan.request_builder import RequestBuilder

logger = logging.getLogger(__name__)


class MealPlanOrchestrationService:
    """
    Orchestrates meal plan generation using unified LLM service with different prompts.
    Handles all business logic while delegating LLM calls to the adapter.
    """

    def __init__(self, meal_generation_service: MealGenerationServicePort):
        self.meal_generation_service = meal_generation_service
        self.meal_distribution_service = MealDistributionService()
        self.meal_type_service = MealTypeDeterminationService()
        self.fallback_service = FallbackMealService()
        self.prompt_service = PromptGenerationService()

        # New extracted components
        self.validator = MealPlanValidator()
        self.generator = MealPlanGenerator(
            meal_generation_service, self.prompt_service, self.fallback_service
        )
        self.formatter = MealPlanFormatter()
        self.request_builder = RequestBuilder(self.meal_distribution_service, self.meal_type_service)

    def generate_weekly_ingredient_based_plan(self, request_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate weekly meal plan based on ingredients."""
        # Convert request data to domain model using request builder
        generation_request = self.request_builder.build_generation_request(
            request_data, MealGenerationType.WEEKLY_INGREDIENT_BASED
        )

        # Create generation context using request builder
        context = self.request_builder.create_generation_context(generation_request, request_data)

        try:
            # Generate prompt using domain service
            prompt, system_message = self.prompt_service.generate_prompt_and_system_message(context)

            # Generate using unified LLM service
            raw_data = self.meal_generation_service.generate_meal_plan(prompt, system_message, "json")

            # Validate using validator
            result = self.validator.validate_weekly_response(raw_data, request_data)
            if not result.is_valid:
                logger.warning(f"Validation warnings: {result.errors}")

            # Transform using formatter
            flat_meals = self.formatter.flatten_week(raw_data["week"])

            # Validate and adjust nutritional targets using formatter
            validated_meals = self.formatter.validate_and_adjust_weekly_nutrition(flat_meals, generation_request)

            return self.formatter.format_weekly_response(validated_meals, request_data)

        except Exception as e:
            logger.error(f"Error generating weekly meal plan: {str(e)}")
            logger.info("Falling back to individual daily meal generation")

            # Fallback: Generate day by day using generator
            fallback_meals = self.generator.generate_weekly_fallback(context, generation_request, request_data)

            # Convert generation_request back to request_data format for compatibility
            request_data_for_fallback = self.request_builder.convert_request_to_dict(generation_request, request_data)

            # Validate and adjust nutritional targets for fallback meals
            validated_meals = self.formatter.validate_and_adjust_weekly_nutrition(
                fallback_meals, generation_request
            )

            return self.formatter.format_weekly_response(validated_meals, request_data_for_fallback)

    def generate_daily_ingredient_based_plan(self, request_data: Dict[str, Any]) -> DailyMealPlan:
        """Generate daily meal plan based on ingredients."""
        # Convert request data to domain model using request builder
        generation_request = self.request_builder.build_generation_request(
            request_data, MealGenerationType.DAILY_INGREDIENT_BASED
        )

        # Create generation context using request builder
        context = self.request_builder.create_generation_context(generation_request)

        # Generate meals using generator
        return self.generator.generate_daily_plan(generation_request, context)

    def generate_daily_plan(self, user_preferences: Dict[str, Any]) -> Dict[str, Any]:
        """Generate daily meal plan based on user preferences (non-ingredient based)."""
        # Convert request data to domain model using request builder
        generation_request = self.request_builder.build_generation_request(
            user_preferences, MealGenerationType.DAILY_PROFILE_BASED
        )

        # Create generation context using request builder
        context = self.request_builder.create_generation_context(generation_request)

        # Generate prompt using domain service
        prompt, system_message = self.prompt_service.generate_prompt_and_system_message(context)

        try:
            # Generate all meals using unified LLM service
            response_data = self.meal_generation_service.generate_meal_plan(prompt, system_message, "json")

            # Validate structure
            if "meals" not in response_data or not isinstance(response_data["meals"], list):
                raise ValueError("Response missing 'meals' array")

            # Convert to domain models using generator
            generated_meals = []
            for meal_data in response_data["meals"]:
                meal_type = MealType(meal_data.get("meal_type", "breakfast"))
                generated_meal = self.generator._convert_to_generated_meal(meal_data, meal_type)
                generated_meals.append(generated_meal)

            # Create daily meal plan domain model
            daily_plan = DailyMealPlan(
                user_id=generation_request.user_profile.user_id,
                plan_date=date.today(),
                meals=generated_meals
            )

            # Return the domain model directly
            return daily_plan

        except Exception as e:
            logger.error(f"Error generating unified daily meal plan: {str(e)}")
            # Fallback to individual meal generation
            logger.info("Falling back to individual meal generation")
            fallback_request_data = {
                **user_preferences,
                "available_ingredients": ["chicken", "rice", "vegetables", "eggs", "milk", "bread", "fruits"],
                "available_seasonings": ["salt", "pepper", "herbs", "spices"]
            }
            return self.generate_daily_ingredient_based_plan(fallback_request_data)
</file>

<file path="src/domain/services/revenuecat_service.py">
"""
Service for interacting with RevenueCat REST API.

RevenueCat is the source of truth for subscription status.
"""
import logging
import os
from datetime import datetime
from typing import Optional, Dict

import httpx

logger = logging.getLogger(__name__)


class RevenueCatService:
    """
    Service for checking subscription status via RevenueCat API.
    
    Use this for critical premium checks.
    """
    
    BASE_URL = "https://api.revenuecat.com/v1"
    
    def __init__(self, api_key: str = None):
        self.api_key = api_key or os.getenv("REVENUECAT_SECRET_API_KEY", "")
    
    async def get_subscriber_info(self, app_user_id: str) -> Optional[Dict]:
        """
        Get subscriber info from RevenueCat.
        
        Args:
            app_user_id: Your user ID (same as user.id)
            
        Returns:
            Subscriber data including entitlements and subscriptions
        """
        url = f"{self.BASE_URL}/subscribers/{app_user_id}"
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json"
        }
        
        try:
            async with httpx.AsyncClient() as client:
                response = await client.get(url, headers=headers, timeout=10.0)
                
                if response.status_code == 404:
                    logger.info(f"Subscriber not found in RevenueCat: {app_user_id}")
                    return None
                
                response.raise_for_status()
                return response.json()
                
        except httpx.HTTPError as e:
            logger.error(f"RevenueCat API error: {e}")
            return None
    
    async def is_premium_active(self, app_user_id: str) -> bool:
        """
        Check if user has active premium subscription in RevenueCat.
        
        This is the source of truth for premium status.
        """
        subscriber_info = await self.get_subscriber_info(app_user_id)
        
        if not subscriber_info:
            return False
        
        subscriber = subscriber_info.get("subscriber", {})
        entitlements = subscriber.get("entitlements", {})
        
        # Check if "premium" entitlement exists and is active
        if "premium" not in entitlements:
            return False
        
        premium = entitlements["premium"]
        expires_date_str = premium.get("expires_date")
        
        # NULL expires_date means lifetime access
        if expires_date_str is None:
            return True
        
        # Check if not expired
        try:
            expires_date = datetime.fromisoformat(expires_date_str.replace('Z', '+00:00'))
            return datetime.now(expires_date.tzinfo) < expires_date
        except Exception as e:
            logger.error(f"Error parsing expires_date: {e}")
            return False
    
    async def get_subscription_info(self, app_user_id: str) -> Optional[Dict]:
        """
        Get active subscription details.
        
        Returns product_id, expires_date, platform if user has active subscription.
        """
        subscriber_info = await self.get_subscriber_info(app_user_id)
        
        if not subscriber_info:
            return None
        
        subscriber = subscriber_info.get("subscriber", {})
        subscriptions = subscriber.get("subscriptions", {})
        
        # Find active subscription
        for product_id, sub_data in subscriptions.items():
            expires_date_str = sub_data.get("expires_date")
            
            if expires_date_str:
                try:
                    expires_date = datetime.fromisoformat(expires_date_str.replace('Z', '+00:00'))
                    if datetime.now(expires_date.tzinfo) < expires_date:
                        return {
                            "product_id": product_id,
                            "expires_date": expires_date,
                            "store": sub_data.get("store"),
                            "is_active": True
                        }
                except Exception:
                    continue
        
        return None
</file>

<file path="src/domain/services/user_profile_service.py">
"""
Shared user profile service for meal plan handlers.
Follows clean architecture principles.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.app.handlers.query_handlers import GetUserTdeeQueryHandler
from src.app.queries.tdee.get_user_tdee_query import GetUserTdeeQuery
from src.domain.model.meal_planning import UserPreferences, DietaryPreference, FitnessGoal, PlanDuration
from src.infra.database.models.user import UserProfile

logger = logging.getLogger(__name__)


class UserProfileService:
    """Shared service for user profile operations in meal planning."""
    
    def __init__(self, db: Session):
        self.db = db
    
    async def get_user_profile_or_defaults(self, user_id: str) -> Dict[str, Any]:
        """Get user profile data or provide sensible defaults."""
        profile = self.db.query(UserProfile).filter(
            UserProfile.user_id == user_id,
            UserProfile.is_current == True
        ).first()
        
        if profile:
            # Import here to avoid circular dependency
            tdee_handler = GetUserTdeeQueryHandler(self.db)
            tdee_query = GetUserTdeeQuery(user_id=user_id)
            tdee_result = await tdee_handler.handle(tdee_query)

            return {
                'dietary_preferences': profile.dietary_preferences or [],
                'allergies': profile.allergies or [],
                'target_calories': tdee_result['target_calories'],
                'target_protein': tdee_result['macros']['protein'],
                'target_carbs': tdee_result['macros']['carbs'],
                'target_fat': tdee_result['macros']['fat'],
                'meals_per_day': profile.meals_per_day,
                'include_snacks': profile.snacks_per_day > 0,
                'age': profile.age,
                'gender': profile.gender,
                'activity_level': profile.activity_level,
                'fitness_goal': profile.fitness_goal,
                'health_conditions': profile.health_conditions or []
            }
        else:
            # Default values when no profile exists
            return {
                'dietary_preferences': [],
                'allergies': [],
                'target_calories': 2000,
                'target_protein': 150,
                'target_carbs': 250,
                'target_fat': 70,
                'meals_per_day': 3,
                'include_snacks': True,
                'age': 30,
                'gender': 'male',
                'activity_level': 'moderate',
                'fitness_goal': 'recomp',
                'health_conditions': []
            }
    
    def create_user_preferences_from_data(self, data: Dict[str, Any], plan_duration: PlanDuration = PlanDuration.DAILY) -> UserPreferences:
        """Create UserPreferences domain object from profile data."""
        # Convert string dietary preferences to domain enums
        valid_prefs = []
        for pref in data.get('dietary_preferences', []):
            try:
                valid_prefs.append(DietaryPreference(pref))
            except ValueError:
                logger.warning(f"Unknown dietary preference: {pref} – skipped")
        
        return UserPreferences(
            dietary_preferences=valid_prefs,
            allergies=data.get('allergies', []),
            fitness_goal=FitnessGoal(data.get('fitness_goal', 'recomp')),
            meals_per_day=data.get('meals_per_day', 3),
            snacks_per_day=1 if data.get('include_snacks', False) else 0,
            cooking_time_weekday=30,  # Default
            cooking_time_weekend=45,  # Default
            favorite_cuisines=data.get('favorite_cuisines', []),
            disliked_ingredients=data.get('disliked_ingredients', []),
            plan_duration=plan_duration
        )
</file>

<file path="src/infra/adapters/cloudinary_image_store.py">
import logging
import os
import uuid
from typing import Optional

import cloudinary
import cloudinary.api
import cloudinary.exceptions
import cloudinary.uploader
import cloudinary.utils
from dotenv import load_dotenv

from src.domain.ports.image_store_port import ImageStorePort

# Load environment variables if not already loaded
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CloudinaryImageStore(ImageStorePort):
    """
    Implementation of ImageStorePort using Cloudinary cloud service.
    
    This class implements US-1.3 - Save the raw image bytes securely.
    """
    
    def __init__(self):
        """Initialize Cloudinary configuration."""
        cloud_name = os.getenv("CLOUDINARY_CLOUD_NAME")
        api_key = os.getenv("CLOUDINARY_API_KEY")
        api_secret = os.getenv("CLOUDINARY_API_SECRET")
        
        logger.info(f"Initializing CloudinaryImageStore with cloud_name: {cloud_name}")
        
        use_mock = bool(int(os.getenv("USE_MOCK_STORAGE", "0")))
        logger.info(f"USE_MOCK_STORAGE is set to: {use_mock}")
        
        if not all([cloud_name, api_key, api_secret]):
            raise ValueError("Missing Cloudinary configuration. Make sure CLOUDINARY_CLOUD_NAME, CLOUDINARY_API_KEY, and CLOUDINARY_API_SECRET are set in .env file")
        
        # Configure Cloudinary
        cloudinary.config(
            cloud_name=cloud_name,
            api_key=api_key,
            api_secret=api_secret
        )
        
        logger.info("CloudinaryImageStore initialized successfully")
    
    def save(self, image_bytes: bytes, content_type: str) -> str:
        """
        Save image bytes to Cloudinary.
        
        Args:
            image_bytes: The raw bytes of the image
            content_type: MIME type of the image ("image/jpeg" or "image/png")
            
        Returns:
            A unique image ID (UUID string)
            
        Raises:
            ValueError: If content_type is not supported or image is invalid
        """
        logger.info(f"Saving image of type {content_type}, size {len(image_bytes)} bytes")
        
        # Validate content type
        if content_type not in ["image/jpeg", "image/png"]:
            raise ValueError(f"Unsupported content type: {content_type}")
        
        # Generate a UUID for the image
        image_id = str(uuid.uuid4())
        logger.info(f"Generated image_id: {image_id}")
        
        # Determine file extension from content type
        if content_type == "image/jpeg":
            file_extension = "jpg"
        elif content_type == "image/png":
            file_extension = "png"
        else:
            file_extension = "jpg"  # Default fallback
        
        # Upload to Cloudinary
        # Use the image_id with extension as the public_id in Cloudinary
        folder = "mealtrack"  # Use a folder for organization
        
        try:
            # Upload the image with explicit format
            logger.info(f"Uploading to Cloudinary with public_id: {folder}/{image_id}")
            response = cloudinary.uploader.upload(
                image_bytes,
                public_id=f"{folder}/{image_id}",
                resource_type="image",
                format=file_extension,  # Explicitly set the format
                overwrite=True
            )

            response_url = response.get('secure_url')

            if (response_url):
                logger.info(f"Upload successful. Cloudinary URL: {response_url}")
                return response_url
            else:
                logger.info(f"'secure_url' not found in Cloudinary response. Returning fallback image_id: {image_id}")
                return image_id

        except Exception as e:
            logger.error(f"Error uploading to Cloudinary: {str(e)}")
            raise
    
    def load(self, image_id: str) -> Optional[bytes]:
        """
        Load image bytes by ID from Cloudinary.
        
        Args:
            image_id: The ID of the image to load
            
        Returns:
            The raw bytes of the image if found, None otherwise
        """
        import requests
        
        logger.info(f"Loading image with ID: {image_id}")
        
        # Get the URL for the image
        url = self.get_url(image_id)
        
        if not url:
            logger.error(f"No URL found for image ID: {image_id}")
            return None
        
        # Fetch the image from Cloudinary
        try:
            logger.info(f"Fetching image from URL: {url}")
            response = requests.get(url)
            if response.status_code == 200:
                logger.info("Image successfully fetched")
                return response.content
            else:
                logger.error(f"Failed to fetch image. Status code: {response.status_code}")
        except Exception as e:
            logger.error(f"Error fetching image: {str(e)}")
            pass
        
        return None
    
    def get_url(self, image_id: str) -> Optional[str]:
        """
        Gets a URL for accessing the image from Cloudinary.
        
        Args:
            image_id: The ID of the image
            
        Returns:
            URL to access the image if available, None otherwise
        """
        logger.info(f"Getting URL for image ID: {image_id}")
        folder = "mealtrack"  # Same folder used in save method
        public_id = f"{folder}/{image_id}"
        
        try:
            # Get resource details from Cloudinary API to get the correct version and format
            resource = cloudinary.api.resource(public_id)
            
            # Extract the secure_url which includes the version number
            secure_url = resource.get('secure_url')
            if secure_url:
                logger.info(f"Found Cloudinary URL: {secure_url}")
                return secure_url
            else:
                logger.error(f"No secure_url found in Cloudinary resource for {public_id}")
                return None
                
        except cloudinary.exceptions.NotFound:
            logger.error(f"Image not found in Cloudinary: {public_id}")
            return None
        except Exception as e:
            logger.error(f"Error getting Cloudinary resource: {str(e)}")
            
            # Fallback to manual URL construction (without version)
            logger.info("Falling back to manual URL construction")
            cloud_name = os.getenv("CLOUDINARY_CLOUD_NAME")
            if not cloud_name:
                logger.error("CLOUDINARY_CLOUD_NAME not found in environment")
                return None
            
            # Try both common formats
            formats_to_try = ["jpg", "png"]
            
            for fmt in formats_to_try:
                # Build the direct Cloudinary URL (without version as fallback)
                url = f"https://res.cloudinary.com/{cloud_name}/image/upload/{folder}/{image_id}.{fmt}"
                
                logger.info(f"Trying fallback URL: {url}")
                
                # Check if the URL is accessible
                try:
                    import requests
                    response = requests.head(url, timeout=5)
                    if response.status_code == 200:
                        logger.info(f"Found working fallback URL: {url}")
                        return url
                except (requests.exceptions.RequestException, Exception) as e:
                    logger.debug(f"URL check failed for {url}: {e}")
                    continue
            
            return None
    
    def delete(self, image_id: str) -> bool:
        """
        Delete an image by ID from Cloudinary.
        
        Args:
            image_id: The ID of the image to delete
            
        Returns:
            True if deleted successfully, False otherwise
        """
        logger.info(f"Deleting image with ID: {image_id}")
        folder = "mealtrack"  # Same folder used in other methods
        
        try:
            # Delete the image from Cloudinary
            response = cloudinary.uploader.destroy(f"{folder}/{image_id}")
            success = response.get("result") == "ok"
            logger.info(f"Delete result: {success}")
            return success
        except Exception as e:
            logger.error(f"Error deleting image: {str(e)}")
            return False
</file>

<file path="src/infra/cache/cache_service.py">
"""
High-level cache service that handles serialization and metrics.
"""
from __future__ import annotations

import json
from datetime import datetime
from typing import Any, Awaitable, Callable, Optional, TypeVar

from pydantic import BaseModel

from src.infra.cache.metrics import CacheMonitor
from src.infra.cache.redis_client import RedisClient

T = TypeVar("T")


class CacheService:
    """Cache service implementing the cache-aside pattern."""

    def __init__(
        self,
        redis_client: RedisClient,
        default_ttl: int = 3600,
        monitor: Optional[CacheMonitor] = None,
        enabled: bool = True,
    ):
        self.redis = redis_client
        self.default_ttl = default_ttl
        self.monitor = monitor
        self.enabled = enabled

    async def get_json(self, key: str) -> Optional[Any]:
        """Retrieve and deserialize a cached JSON payload."""
        if not self.enabled:
            return None

        raw = await self.redis.get(key)
        if raw is None:
            if self.monitor:
                self.monitor.record_miss()
            return None

        if self.monitor:
            self.monitor.record_hit()

        try:
            return json.loads(raw)
        except json.JSONDecodeError:
            return None

    async def set_json(self, key: str, value: Any, ttl: Optional[int] = None) -> bool:
        """Serialize and cache a value."""
        if not self.enabled:
            return False

        payload: str
        if isinstance(value, BaseModel):
            payload = value.model_dump_json()
        else:
            payload = json.dumps(value, default=_json_serializer)

        return await self.redis.set(key, payload, ttl or self.default_ttl)

    async def get_or_set(
        self,
        key: str,
        factory: Callable[[], Awaitable[T]],
        ttl: Optional[int] = None,
    ) -> Optional[T]:
        """
        Cache-aside helper that fetches data from cache or executes the factory.
        """
        cached = await self.get_json(key)
        if cached is not None:
            return cached  # type: ignore[return-value]

        value = await factory()
        if value is not None:
            await self.set_json(key, value, ttl)
        return value

    async def invalidate(self, key: str) -> bool:
        """Remove a cached value."""
        if not self.enabled:
            return False
        return await self.redis.delete(key)

    async def invalidate_pattern(self, pattern: str) -> int:
        """Remove all cache keys matching a pattern."""
        if not self.enabled:
            return 0
        return await self.redis.delete_pattern(pattern)


def _json_serializer(value: Any) -> Any:
    """Helper to serialize objects that aren't JSON-serializable by default."""
    if isinstance(value, BaseModel):
        return value.model_dump()
    if isinstance(value, datetime):
        return value.isoformat() + 'Z'
    raise TypeError(f"Object of type {value.__class__.__name__} is not JSON serializable")
</file>

<file path="src/infra/database/models/chat/message.py">
"""
Database model for chat messages.
"""
from datetime import datetime
from sqlalchemy import Column, String, DateTime, Text, ForeignKey, Index
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class ChatMessage(Base, BaseMixin):
    """Database model for chat messages."""
    __tablename__ = 'chat_messages'
    
    # Relationships
    thread_id = Column(String(36), ForeignKey('chat_threads.id', ondelete='CASCADE'), nullable=False, index=True)
    
    # Message data
    role = Column(String(20), nullable=False)  # 'user', 'assistant', 'system'
    content = Column(Text, nullable=False)
    
    # JSON metadata for extensibility (tokens, model info, etc.) - use metadata_ to avoid SQLAlchemy reserved word
    metadata_ = Column('metadata', Text, nullable=True)  # Store as JSON string
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False, index=True)
    
    # Relationships
    thread = relationship("ChatThread", back_populates="messages")
    
    # Indexes for efficient queries
    __table_args__ = (
        Index('ix_chat_messages_thread_created', 'thread_id', 'created_at'),
    )
    
    def __repr__(self):
        return f"<ChatMessage(id={self.id}, thread_id={self.thread_id}, role={self.role})>"
    
    def to_domain(self):
        """Convert database model to domain model."""
        from src.domain.model.chat import Message, MessageRole
        import json
        
        # Parse metadata
        metadata_dict = {}
        if self.metadata_:
            try:
                metadata_dict = json.loads(self.metadata_)
            except (json.JSONDecodeError, TypeError):
                metadata_dict = {}
        
        # Parse role
        role = MessageRole.USER
        if self.role == 'assistant':
            role = MessageRole.ASSISTANT
        elif self.role == 'system':
            role = MessageRole.SYSTEM
        
        return Message(
            message_id=self.id,
            thread_id=self.thread_id,
            role=role,
            content=self.content,
            created_at=self.created_at,
            metadata=metadata_dict
        )
</file>

<file path="src/infra/database/models/chat/thread.py">
"""
Database model for chat threads.
"""
from datetime import datetime
from sqlalchemy import Column, String, Boolean, DateTime, Text, ForeignKey
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class ChatThread(Base, BaseMixin):
    """Database model for conversation threads."""
    __tablename__ = 'chat_threads'
    
    # Relationships
    user_id = Column(String(36), ForeignKey('users.id'), nullable=False, index=True)
    
    # Thread metadata
    title = Column(String(255), nullable=True)
    status = Column(String(20), nullable=False, default='active', index=True)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # JSON metadata for extensibility (use metadata_ to avoid SQLAlchemy reserved word)
    metadata_ = Column('metadata', Text, nullable=True)  # Store as JSON string
    
    # Timestamps
    created_at = Column(DateTime, default=datetime.utcnow, nullable=False)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow, nullable=False)
    
    # Relationships
    user = relationship("User", backref="chat_threads")
    messages = relationship(
        "ChatMessage",
        back_populates="thread",
        cascade="all, delete-orphan",
        order_by="ChatMessage.created_at"
    )
    
    def __repr__(self):
        return f"<ChatThread(id={self.id}, user_id={self.user_id}, title={self.title})>"
    
    def to_domain(self):
        """Convert database model to domain model."""
        from src.domain.model.chat import Thread, ThreadStatus
        import json
        
        # Parse metadata
        metadata_dict = {}
        if self.metadata_:
            try:
                metadata_dict = json.loads(self.metadata_)
            except (json.JSONDecodeError, TypeError):
                metadata_dict = {}
        
        # Parse status
        status = ThreadStatus.ACTIVE
        if self.status == 'archived':
            status = ThreadStatus.ARCHIVED
        elif self.status == 'deleted':
            status = ThreadStatus.DELETED
        
        # Convert messages if loaded
        messages = []
        if hasattr(self, 'messages') and self.messages:
            messages = [msg.to_domain() for msg in self.messages]
        
        return Thread(
            thread_id=self.id,
            user_id=self.user_id,
            title=self.title,
            status=status,
            created_at=self.created_at,
            updated_at=self.updated_at,
            metadata=metadata_dict,
            messages=messages
        )
</file>

<file path="src/infra/database/models/meal/meal_image.py">
"""
Meal image model for storing image metadata.
"""
from sqlalchemy import Column, String, Integer

from src.infra.database.config import Base
from src.infra.database.models.base import TimestampMixin


class MealImage(Base, TimestampMixin):
    """Database model for meal images."""
    
    __tablename__ = 'mealimage'
    
    # Primary key
    image_id = Column(String(36), primary_key=True)
    format = Column(String(10), nullable=False)  # jpeg, png, etc.
    size_bytes = Column(Integer, nullable=False)
    width = Column(Integer, nullable=True)  # Changed to nullable
    height = Column(Integer, nullable=True)  # Changed to nullable
    url = Column(String(255), nullable=True)  # Optional URL to the image
    
    def to_domain(self):
        """Convert DB model to domain model."""
        from src.domain.model.meal import MealImage as DomainMealImage
        
        return DomainMealImage(
            image_id=self.image_id,
            format=self.format,
            size_bytes=self.size_bytes,
            width=self.width,
            height=self.height,
            url=self.url
        )
    
    @classmethod
    def from_domain(cls, domain_model):
        """Create DB model from domain model."""
        # Convert UUID objects to strings to ensure compatibility with MySQL
        return cls(
            image_id=str(domain_model.image_id),
            format=domain_model.format,
            size_bytes=domain_model.size_bytes,
            width=getattr(domain_model, "width", None),
            height=getattr(domain_model, "height", None),
            url=getattr(domain_model, "url", None)
        )
</file>

<file path="src/infra/database/models/notification/user_fcm_token.py">
"""
User FCM token model for push notifications.
"""
from sqlalchemy import Column, String, Boolean, Enum

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class UserFcmToken(Base, BaseMixin):
    """User FCM token table for push notification delivery."""
    __tablename__ = 'user_fcm_tokens'
    
    # User relationship
    user_id = Column(String(36), nullable=False, index=True)
    
    # FCM token data
    fcm_token = Column(String(255), nullable=False, unique=True)
    device_type = Column(Enum('ios', 'android', name='device_type_enum'), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    
    # Relationships - removed to avoid circular import issues
    
    def to_domain(self):
        """Convert database model to domain model."""
        from src.domain.model.notification import UserFcmToken as DomainUserFcmToken, DeviceType
        
        device_type = DeviceType.IOS if self.device_type == 'ios' else DeviceType.ANDROID
        
        return DomainUserFcmToken(
            token_id=self.id,
            user_id=self.user_id,
            fcm_token=self.fcm_token,
            device_type=device_type,
            is_active=self.is_active,
            created_at=self.created_at,
            updated_at=self.updated_at
        )
</file>

<file path="src/infra/database/models/user/user.py">
"""
Core user model for authentication and account management.
"""
from datetime import datetime

from sqlalchemy import Column, String, Boolean, DateTime, Text, Index, Enum
from sqlalchemy.orm import relationship

from src.api.schemas.common.auth_enums import AuthProviderEnum
from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class User(Base, BaseMixin):
    """Core user table for authentication and account management."""
    __tablename__ = 'users'
    
    # Firebase Integration
    firebase_uid = Column(String(36), unique=True, nullable=False, index=True)
    
    # Basic Information
    email = Column(String(255), unique=True, nullable=False)
    username = Column(String(100), unique=True, nullable=False)
    first_name = Column(String(100), nullable=True)
    last_name = Column(String(100), nullable=True)
    
    # Authentication & OAuth
    password_hash = Column(String(255), nullable=False)
    phone_number = Column(String(20), nullable=True)
    display_name = Column(String(100), nullable=True)
    photo_url = Column(Text, nullable=True)
    provider = Column(Enum(AuthProviderEnum), nullable=False, default=AuthProviderEnum.GOOGLE)  # phone, google
    
    # Status & Activity
    is_active = Column(Boolean, default=True, nullable=False)
    onboarding_completed = Column(Boolean, default=False, nullable=False)
    last_accessed = Column(DateTime, default=datetime.now, nullable=False)
    
    # Timezone (IANA format, e.g., "America/Los_Angeles")
    timezone = Column(String(50), nullable=False, server_default='UTC')
    
    # Indexes for performance
    __table_args__ = (
        Index('idx_firebase_uid', 'firebase_uid'),
        Index('idx_provider', 'provider'),
        Index('idx_onboarding_completed', 'onboarding_completed'),
        Index('idx_users_timezone', 'timezone'),
    )
    
    # Relationships
    profiles = relationship("UserProfile", back_populates="user", cascade="all, delete-orphan")
    subscriptions = relationship("Subscription", back_populates="user", cascade="all, delete-orphan")
    
    @property
    def current_profile(self):
        """Get the current active profile."""
        return next((p for p in self.profiles if p.is_current), None)
    
    def get_active_subscription(self):
        """Get user's active subscription, if any."""
        for subscription in self.subscriptions:
            if subscription.is_active():
                return subscription
        return None
    
    def is_premium(self) -> bool:
        """
        Check if user has active premium subscription.
        
        Note: This checks local cache. For real-time validation,
        use RevenueCat API via the RevenueCatService.
        """
        return self.get_active_subscription() is not None
</file>

<file path="src/infra/database/models/subscription.py">
"""
Subscription model for tracking user subscriptions.
"""
from datetime import datetime

from sqlalchemy import Column, String, DateTime, Boolean, Enum, ForeignKey, Index
from sqlalchemy.orm import relationship

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class Subscription(Base, BaseMixin):
    """
    Stores subscription records synced from RevenueCat.
    
    RevenueCat is the source of truth - this table caches key data.
    """
    __tablename__ = 'subscriptions'
    
    # User relationship
    user_id = Column(String(36), ForeignKey('users.id', ondelete='CASCADE'), nullable=False)
    
    # RevenueCat data
    revenuecat_subscriber_id = Column(String(255), nullable=False, index=True)
    product_id = Column(String(255), nullable=False)  # "premium_monthly" or "premium_yearly"
    platform = Column(Enum('ios', 'android', 'web'), nullable=False)
    
    # Subscription status
    status = Column(
        Enum('active', 'expired', 'cancelled', 'billing_issue'),
        nullable=False,
        default='active'
    )
    purchased_at = Column(DateTime, nullable=False)
    expires_at = Column(DateTime, nullable=True)
    cancelled_at = Column(DateTime, nullable=True)
    
    # Store metadata
    store_transaction_id = Column(String(255), nullable=True)
    is_sandbox = Column(Boolean, default=False, nullable=False)
    
    # Relationships
    user = relationship("User", back_populates="subscriptions")
    
    # Indexes
    __table_args__ = (
        Index('idx_user_id_status', 'user_id', 'status'),
        Index('idx_expires_at', 'expires_at'),
        Index('idx_revenuecat_subscriber_id', 'revenuecat_subscriber_id'),
    )
    
    def is_active(self) -> bool:
        """Check if subscription is currently active."""
        if self.status != 'active':
            return False
        if self.expires_at and datetime.now() > self.expires_at:
            return False
        return True
    
    def is_monthly(self) -> bool:
        """Check if this is a monthly subscription."""
        return 'monthly' in self.product_id.lower()
    
    def is_yearly(self) -> bool:
        """Check if this is a yearly subscription."""
        return 'yearly' in self.product_id.lower() or 'annual' in self.product_id.lower()
</file>

<file path="src/infra/database/uow.py">
"""
Unit of Work pattern implementation for managing database transactions.
"""
from typing import TypeVar

from sqlalchemy.orm import Session

from src.infra.repositories.subscription_repository import SubscriptionRepository
from src.infra.repositories.user_repository import UserRepository

T = TypeVar('T')


class UnitOfWork:
    """
    Unit of Work pattern for managing database transactions.
    
    Ensures all repository operations within a context are committed or rolled back together.
    """
    
    def __init__(self, session: Session = None):
        self.session = session
        
    def __enter__(self):
        """Enter context - start transaction."""
        if not self.session:
            # Default session handling - import here to avoid circular imports
            from src.infra.database.config import SessionLocal
            self.session = SessionLocal()
            
        # Initialize repositories
        self.users = UserRepository(self.session)
        self.subscriptions = SubscriptionRepository(self.session)
        
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        """Exit context - commit or rollback transaction."""
        if exc_type:
            self.rollback()
        else:
            self.commit()
        self.session.close()
    
    async def __aenter__(self):
        """Support async context manager for compatibility."""
        return self.__enter__()
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Support async context manager for compatibility."""
        return self.__exit__(exc_type, exc_val, exc_tb)
    
    def commit(self):
        """Commit the transaction."""
        self.session.commit()
    
    async def commit_async(self):
        """Async wrapper for commit."""
        self.commit()
    
    def rollback(self):
        """Rollback the transaction."""
        self.session.rollback()
    
    async def rollback_async(self):
        """Async wrapper for rollback."""
        self.rollback()
    
    def refresh(self, obj):
        """Refresh an object from the database."""
        self.session.refresh(obj)
</file>

<file path="src/infra/repositories/base.py">
"""
Base repository class for common database operations.
"""
from typing import TypeVar, Generic, Type, Optional, List
from uuid import uuid4

from sqlalchemy.orm import Session

T = TypeVar('T')


class BaseRepository(Generic[T]):
    """Base repository with common CRUD operations."""
    
    def __init__(self, model_class: Type[T], session: Session):
        self.model_class = model_class
        self.session = session
    
    def get(self, id: str) -> Optional[T]:
        """Get entity by ID."""
        return self.session.query(self.model_class).filter(
            self.model_class.id == id
        ).first()
    
    def get_all(self) -> List[T]:
        """Get all entities."""
        return self.session.query(self.model_class).all()
    
    def add(self, entity: T) -> T:
        """Add new entity."""
        if hasattr(entity, 'id') and not entity.id:
            entity.id = str(uuid4())
        self.session.add(entity)
        self.session.flush()
        return entity
    
    def update(self, entity: T) -> T:
        """Update entity."""
        self.session.add(entity)
        self.session.flush()
        return entity
    
    def delete(self, id: str) -> bool:
        """Delete entity by ID."""
        entity = self.get(id)
        if entity:
            self.session.delete(entity)
            self.session.flush()
            return True
        return False
    
    # Async wrappers for compatibility
    async def get_async(self, id: str) -> Optional[T]:
        """Async wrapper for get."""
        return self.get(id)
    
    async def add_async(self, entity: T) -> T:
        """Async wrapper for add."""
        return self.add(entity)
</file>

<file path="src/infra/repositories/chat_repository.py">
"""
Chat repository implementation using SQLAlchemy.
"""
import json
import logging
from typing import List, Optional
from datetime import datetime

from sqlalchemy.orm import Session
from sqlalchemy import func

from src.domain.model.chat import Thread, Message, ThreadStatus
from src.domain.ports.chat_repository_port import ChatRepositoryPort
from src.infra.database.models.chat import ChatThread, ChatMessage

logger = logging.getLogger(__name__)


class ChatRepository(ChatRepositoryPort):
    """SQL implementation of ChatRepositoryPort."""
    
    def __init__(self, db: Optional[Session] = None):
        """
        Initialize repository with optional database session.
        
        If db is None, the repository will create its own session for each operation.
        If db is provided, the repository will use it and NOT manage its lifecycle.
        The session lifecycle should be managed by the caller (e.g., FastAPI dependency).
        """
        self.db = db
    
    def save_thread(self, thread: Thread) -> Thread:
        """Save a thread and return the saved thread."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            # Check if thread exists
            existing = db.query(ChatThread).filter(ChatThread.id == thread.thread_id).first()
            
            if existing:
                # Update existing thread
                existing.title = thread.title
                existing.status = str(thread.status).lower()
                existing.is_active = thread.status == ThreadStatus.ACTIVE
                existing.updated_at = thread.updated_at
                
                if thread.metadata:
                    existing.metadata_ = json.dumps(thread.metadata)
                
                db_thread = existing
            else:
                # Create new thread
                db_thread = ChatThread(
                    id=thread.thread_id,
                    user_id=thread.user_id,
                    title=thread.title,
                    status=str(thread.status).lower(),
                    is_active=thread.status == ThreadStatus.ACTIVE,
                    metadata_=json.dumps(thread.metadata) if thread.metadata else None,
                    created_at=thread.created_at,
                    updated_at=thread.updated_at
                )
                db.add(db_thread)
            
            db.commit()
            db.refresh(db_thread)
            
            return db_thread.to_domain()
        
        except Exception as e:
            db.rollback()
            logger.error(f"Error saving thread: {e}")
            raise e
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def find_thread_by_id(self, thread_id: str) -> Optional[Thread]:
        """Find a thread by its ID."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            db_thread = db.query(ChatThread).filter(ChatThread.id == thread_id).first()
            
            if not db_thread:
                return None
            
            return db_thread.to_domain()
        
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def find_threads_by_user(
        self,
        user_id: str,
        include_deleted: bool = False,
        limit: int = 50,
        offset: int = 0
    ) -> List[Thread]:
        """Find all threads for a user with pagination."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            # Create subquery for message counts to avoid N+1 queries
            message_count_subquery = (
                db.query(func.count(ChatMessage.id))
                .filter(ChatMessage.thread_id == ChatThread.id)
                .correlate(ChatThread)
                .scalar_subquery()
            )
            
            query = db.query(
                ChatThread,
                message_count_subquery.label('message_count')
            ).filter(ChatThread.user_id == user_id)
            
            if not include_deleted:
                query = query.filter(ChatThread.status != 'deleted')
            
            query = query.order_by(ChatThread.updated_at.desc())
            query = query.limit(limit).offset(offset)
            
            results = query.all()
            
            # Convert to domain models with message counts
            threads = []
            for db_thread, message_count in results:
                domain_thread = db_thread.to_domain()
                # Cache message count to avoid N+1 queries when to_dict() calls get_message_count()
                # This allows get_message_count() to return the count without loading all messages
                object.__setattr__(domain_thread, '_cached_message_count', message_count or 0)
                threads.append(domain_thread)
            
            return threads
        
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def delete_thread(self, thread_id: str) -> bool:
        """Delete a thread (soft delete)."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            db_thread = db.query(ChatThread).filter(ChatThread.id == thread_id).first()
            
            if not db_thread:
                return False
            
            db_thread.status = 'deleted'
            db_thread.is_active = False
            db_thread.updated_at = datetime.utcnow()
            
            db.commit()
            return True
        
        except Exception as e:
            db.rollback()
            logger.error(f"Error deleting thread: {e}")
            raise e
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def save_message(self, message: Message) -> Message:
        """Save a message and return the saved message."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            # Check if message exists
            existing = db.query(ChatMessage).filter(ChatMessage.id == message.message_id).first()
            
            if existing:
                # Update existing message (though messages should be immutable)
                existing.content = message.content
                if message.metadata:
                    existing.metadata_ = json.dumps(message.metadata)
                db_message = existing
            else:
                # Create new message
                db_message = ChatMessage(
                    id=message.message_id,
                    thread_id=message.thread_id,
                    role=str(message.role).lower(),
                    content=message.content,
                    metadata_=json.dumps(message.metadata) if message.metadata else None,
                    created_at=message.created_at
                )
                db.add(db_message)
            
            # Update thread's updated_at
            db_thread = db.query(ChatThread).filter(ChatThread.id == message.thread_id).first()
            if db_thread:
                db_thread.updated_at = datetime.utcnow()
            
            db.commit()
            db.refresh(db_message)
            
            return db_message.to_domain()
        
        except Exception as e:
            db.rollback()
            logger.error(f"Error saving message: {e}")
            raise e
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def find_messages_by_thread(
        self,
        thread_id: str,
        limit: int = 100,
        offset: int = 0
    ) -> List[Message]:
        """Find all messages for a thread with pagination."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            query = db.query(ChatMessage).filter(ChatMessage.thread_id == thread_id)
            query = query.order_by(ChatMessage.created_at.asc())
            query = query.limit(limit).offset(offset)
            
            db_messages = query.all()
            
            return [message.to_domain() for message in db_messages]
        
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def count_user_threads(self, user_id: str, include_deleted: bool = False) -> int:
        """Count total threads for a user."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            query = db.query(func.count(ChatThread.id)).filter(ChatThread.user_id == user_id)
            
            if not include_deleted:
                query = query.filter(ChatThread.status != 'deleted')
            
            return query.scalar() or 0
        
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
    
    def count_thread_messages(self, thread_id: str) -> int:
        """Count total messages in a thread."""
        # Use provided session or create one for this operation
        if self.db:
            db = self.db
        else:
            from src.infra.database.config import SessionLocal
            db = SessionLocal()
        
        try:
            return db.query(func.count(ChatMessage.id)).filter(
                ChatMessage.thread_id == thread_id
            ).scalar() or 0
        
        finally:
            # Only close if we created the session
            if not self.db:
                db.close()
</file>

<file path="src/infra/repositories/meal_plan_repository.py">
"""
Meal Plan Repository for persisting meal plans.
"""

from typing import Optional

from sqlalchemy.orm import Session, selectinload

from src.domain.model.meal_planning import MealPlan
from src.infra.database.config import SessionLocal
from src.infra.database.models.enums import FitnessGoalEnum, PlanDurationEnum, MealTypeEnum
from src.infra.database.models.meal_planning.meal_plan import MealPlan as DBMealPlan
from src.infra.database.models.meal_planning.meal_plan_day import MealPlanDay as DBMealPlanDay
from src.infra.database.models.meal_planning.planned_meal import PlannedMeal as DBPlannedMeal

_MEAL_PLAN_LOAD_OPTIONS = (
    selectinload(DBMealPlan.days).selectinload(DBMealPlanDay.meals),
)


class MealPlanRepository:
    """Repository for meal plan persistence operations."""
    
    def __init__(self, db: Session = None):
        self.db = db
    
    def _get_db(self):
        if self.db:
            return self.db
        else:
            return SessionLocal()
    
    def _close_db_if_created(self, db):
        if self.db is None and db is not None:
            db.close()
    
    def save(self, meal_plan: MealPlan) -> MealPlan:
        """Save a meal plan to the database."""
        db = self._get_db()
        
        try:
            # Create DB MealPlan
            db_meal_plan = DBMealPlan(
                id=meal_plan.plan_id,
                user_id=meal_plan.user_id,
                dietary_preferences=[pref.value for pref in meal_plan.preferences.dietary_preferences],
                allergies=meal_plan.preferences.allergies,
                fitness_goal=FitnessGoalEnum(meal_plan.preferences.fitness_goal.value),
                meals_per_day=meal_plan.preferences.meals_per_day,
                snacks_per_day=meal_plan.preferences.snacks_per_day,
                cooking_time_weekday=meal_plan.preferences.cooking_time_weekday,
                cooking_time_weekend=meal_plan.preferences.cooking_time_weekend,
                favorite_cuisines=meal_plan.preferences.favorite_cuisines,
                disliked_ingredients=meal_plan.preferences.disliked_ingredients,
                plan_duration=PlanDurationEnum(meal_plan.preferences.plan_duration.value)
            )
            db.add(db_meal_plan)
            
            # Create days and meals
            for day in meal_plan.days:
                db_day = DBMealPlanDay(
                    meal_plan_id=db_meal_plan.id,
                    date=day.date
                )
                db.add(db_day)
                
                for meal in day.meals:
                    db_meal = DBPlannedMeal(
                        day_id=db_day.id,
                        meal_type=MealTypeEnum(meal.meal_type.value),
                        name=meal.name,
                        description=meal.description,
                        prep_time=meal.prep_time,
                        cook_time=meal.cook_time,
                        calories=meal.calories,
                        protein=meal.protein,
                        carbs=meal.carbs,
                        fat=meal.fat,
                        ingredients=meal.ingredients,
                        instructions=meal.instructions,
                        is_vegetarian=meal.is_vegetarian,
                        is_vegan=meal.is_vegan,
                        is_gluten_free=meal.is_gluten_free,
                        cuisine_type=meal.cuisine_type
                    )
                    db.add(db_meal)
            
            db.commit()
            db.refresh(db_meal_plan)
            return meal_plan
        except Exception as e:
            db.rollback()
            raise e
        finally:
            self._close_db_if_created(db)
    
    def find_by_id(self, plan_id: str) -> Optional[MealPlan]:
        """Find a meal plan by ID."""
        db = self._get_db()
        
        try:
            db_plan = (
                db.query(DBMealPlan)
                .options(*_MEAL_PLAN_LOAD_OPTIONS)
                .filter(DBMealPlan.id == plan_id)
                .first()
            )
            if db_plan:
                # TODO: Map back to domain model - for now return the DB model
                return db_plan
            return None
        finally:
            self._close_db_if_created(db)
</file>

<file path="src/infra/repositories/meal_repository.py">
import logging
from datetime import datetime
from typing import List, Optional, Dict, Any

from sqlalchemy.orm import Session, joinedload, selectinload

from src.domain.model.meal import Meal, MealStatus, MealImage
from src.domain.model.nutrition import Macros, Micros, Nutrition, FoodItem
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.infra.database.config import SessionLocal
from src.infra.database.models.meal.meal import Meal as DBMeal
from src.infra.database.models.meal.meal_image import MealImage as DBMealImage
from src.infra.database.models.nutrition.nutrition import Nutrition as DBNutrition

logger = logging.getLogger(__name__)

_MEAL_LOAD_OPTIONS = (
    joinedload(DBMeal.image),
    selectinload(DBMeal.nutrition).selectinload(DBNutrition.food_items),
)


# For development, we'll use an in-memory store
# In a real application, this would be replaced with a database
class MealRepository(MealRepositoryPort):
    """Implementation of the meal repository using SQLAlchemy."""
    
    def __init__(self, db: Session = None):
        """Initialize with optional session dependency."""
        self.db = db
    
    def _get_db(self):
        """Get a database session, creating one if needed."""
        if self.db:
            return self.db
        else:
            return SessionLocal()
    
    def _close_db_if_created(self, db):
        """Close the database session if we created it."""
        if self.db is None and db is not None:
            db.close()
    
    def save(self, meal: Meal) -> Meal:
        """Save a meal to the database."""
        db = self._get_db()
        
        try:
            # Check if meal already exists
            existing_meal = db.query(DBMeal).filter(DBMeal.meal_id == meal.meal_id).first()
            
            if existing_meal:
                # Update existing meal
                from src.infra.mappers import MealStatusMapper

                # Handle nutrition data with smart sync
                if meal.nutrition and not existing_meal.nutrition:
                    # Create new nutrition
                    db_nutrition = DBNutrition.from_domain(meal.nutrition, meal_id=meal.meal_id)
                    existing_meal.nutrition = db_nutrition
                elif meal.nutrition and existing_meal.nutrition:
                    # Update existing nutrition in place
                    self._update_nutrition(db, existing_meal.nutrition, meal.nutrition, meal.meal_id)

                # Update other meal fields
                existing_meal.status = MealStatusMapper.to_db(meal.status)
                existing_meal.dish_name = getattr(meal, "dish_name", None)
                existing_meal.ready_at = getattr(meal, "ready_at", None)
                existing_meal.error_message = getattr(meal, "error_message", None)
                existing_meal.raw_ai_response = getattr(meal, "raw_gpt_json", None)
                existing_meal.updated_at = getattr(meal, "updated_at", None) or datetime.now()
                existing_meal.last_edited_at = getattr(meal, "last_edited_at", None)
                existing_meal.edit_count = getattr(meal, "edit_count", 0)
                existing_meal.is_manually_edited = getattr(meal, "is_manually_edited", False)

                db.commit()
                return meal
            else:
                # Create new meal
                db_meal = DBMeal.from_domain(meal)
                
                # Check if image exists
                existing_image = db.query(DBMealImage).filter(
                    DBMealImage.image_id == meal.image.image_id
                ).first()
                
                if not existing_image:
                    db_image = DBMealImage.from_domain(meal.image)
                    db.add(db_image)
                
                db.add(db_meal)
                db.commit()
                return meal
        except Exception as e:
            db.rollback()
            raise e
        finally:
            self._close_db_if_created(db)
    
    def find_by_id(self, meal_id: str) -> Optional[Meal]:
        """Find a meal by ID."""
        db = self._get_db()
        
        try:
            db_meal = (
                db.query(DBMeal)
                .options(*_MEAL_LOAD_OPTIONS)
                .filter(DBMeal.meal_id == meal_id)
                .first()
            )
            
            if db_meal:
                return db_meal.to_domain()
            else:
                return None
        finally:
            self._close_db_if_created(db)
    
    def find_by_status(self, status: MealStatus, limit: int = 10) -> List[Meal]:
        """Find meals by status."""
        db = self._get_db()

        try:
            from src.infra.mappers import MealStatusMapper

            db_meals = (
                db.query(DBMeal)
                .options(*_MEAL_LOAD_OPTIONS)
                .filter(DBMeal.status == MealStatusMapper.to_db(status))
                .order_by(DBMeal.created_at)  # Oldest first
                .limit(limit)
                .all()
            )

            return [meal.to_domain() for meal in db_meals]
        finally:
            self._close_db_if_created(db)
    
    def delete(self, meal_id: str) -> bool:
        """Delete a meal by ID."""
        db = self._get_db()
        
        try:
            db_meal = db.query(DBMeal).filter(DBMeal.meal_id == meal_id).first()
            
            if db_meal:
                db.delete(db_meal)
                db.commit()
                return True
            else:
                return False
        except Exception as e:
            db.rollback()
            raise e
        finally:
            self._close_db_if_created(db)
    
    def find_all_paginated(self, offset: int = 0, limit: int = 20) -> List[Meal]:
        """
        Retrieves all meals with pagination.
        
        Args:
            offset: Pagination offset
            limit: Maximum number of results
            
        Returns:
            Paginated list of meals
        """
        all_meals = list(self._meals.values())
        all_meals.sort(key=lambda m: m["created_at"], reverse=True)  # Newest first
        
        paginated_meals = all_meals[offset:offset + limit]
        return [self._meal_from_dict(meal_dict) for meal_dict in paginated_meals]
    
    def count(self) -> int:
        """
        Counts the total number of meals.
        
        Returns:
            Total count
        """
        return len(self._meals)
    
    def find_by_date(self, date, user_id: str = None, limit: int = 50) -> List[Meal]:
        """Find meals created on a specific date, optionally filtered by user."""
        db = self._get_db()
        
        try:
            from datetime import datetime, timedelta
            
            # Create start and end datetime for the date range
            start_datetime = datetime.combine(date, datetime.min.time())
            end_datetime = start_datetime + timedelta(days=1)
            
            # Query meals created within the date range and exclude INACTIVE
            query = (
                db.query(DBMeal)
                .options(*_MEAL_LOAD_OPTIONS)
                .filter(DBMeal.created_at >= start_datetime)
                .filter(DBMeal.created_at < end_datetime)
            )
            
            # Add user filter if provided
            if user_id:
                query = query.filter(DBMeal.user_id == user_id)
            
            from src.infra.database.models.enums import MealStatusEnum
            db_meals = (
                query
                .filter(DBMeal.status != MealStatusEnum.INACTIVE)
                .order_by(DBMeal.created_at.desc())  # Newest first
                .limit(limit)
                .all()
            )
            
            return [meal.to_domain() for meal in db_meals]
        finally:
            self._close_db_if_created(db)
    
    def _meal_from_dict(self, data: Dict[str, Any]) -> Meal:
        """Convert dictionary representation back to Meal object."""
        # Create MealImage
        image_data = data["image"]
        image = MealImage(
            image_id=image_data["image_id"],
            format=image_data["format"],
            size_bytes=image_data["size_bytes"],
            width=image_data.get("width"),
            height=image_data.get("height"),
            url=image_data.get("url")
        )
        
        # Process nutrition if available
        nutrition = None
        if "nutrition" in data:
            nutrition_data = data["nutrition"]
            
            # Create Macros
            macros = Macros(
                protein=nutrition_data["macros"]["protein_g"],
                carbs=nutrition_data["macros"]["carbs_g"],
                fat=nutrition_data["macros"]["fat_g"],
            )
            
            # Create Micros if available
            micros = None
            if "micros" in nutrition_data:
                micros = Micros.from_dict(nutrition_data["micros"])
            
            # Create FoodItems if available
            food_items = None
            if "food_items" in nutrition_data:
                food_items = []
                for item_data in nutrition_data["food_items"]:
                    item_macros = Macros(
                        protein=item_data["macros"]["protein_g"],
                        carbs=item_data["macros"]["carbs_g"],
                        fat=item_data["macros"]["fat_g"],
                    )
                    
                    item_micros = None
                    if "micros" in item_data:
                        item_micros = Micros.from_dict(item_data["micros"])
                        
                    food_item = FoodItem(
                        name=item_data["name"],
                        quantity=item_data["quantity"],
                        unit=item_data["unit"],
                        calories=item_data["calories"],
                        macros=item_macros,
                        micros=item_micros,
                        confidence=item_data["confidence"]
                    )
                    food_items.append(food_item)
            
            # Create Nutrition
            nutrition = Nutrition(
                calories=nutrition_data["calories"],
                macros=macros,
                micros=micros,
                food_items=food_items,
                confidence_score=nutrition_data["confidence_score"]
            )
        
        # Create Meal
        return Meal(
            meal_id=data["meal_id"],
            user_id=data["user_id"],
            status=MealStatus(data["status"]),
            created_at=datetime.fromisoformat(data["created_at"]),
            image=image,
            nutrition=nutrition,
            ready_at=datetime.fromisoformat(data["ready_at"]) if "ready_at" in data else None,
            error_message=data.get("error_message"),
            raw_gpt_json=data.get("raw_gpt_json")
        )

    def _update_nutrition(self, db, db_nutrition, domain_nutrition, meal_id):
        """
        Smart update of nutrition data - updates existing records, adds new, removes deleted.
        Preserves IDs and only changes what's necessary.
        """
        from src.infra.database.models.nutrition.food_item import FoodItem as DBFoodItem

        # Update nutrition fields
        db_nutrition.calories = domain_nutrition.calories
        db_nutrition.protein = domain_nutrition.macros.protein
        db_nutrition.carbs = domain_nutrition.macros.carbs
        db_nutrition.fat = domain_nutrition.macros.fat
        db_nutrition.confidence_score = domain_nutrition.confidence_score

        # Sync food items
        if domain_nutrition.food_items:
            # Get existing item IDs
            existing_items = {item.id: item for item in db_nutrition.food_items}
            new_item_ids = {item.id for item in domain_nutrition.food_items}

            # Remove deleted items
            for item_id in list(existing_items.keys()):
                if item_id not in new_item_ids:
                    db.delete(existing_items[item_id])
                    logger.info(f"Deleted food item: {item_id}")

            # Update or add items
            for domain_item in domain_nutrition.food_items:
                if domain_item.id in existing_items:
                    # Update existing item
                    db_item = existing_items[domain_item.id]
                    db_item.name = domain_item.name
                    db_item.quantity = domain_item.quantity
                    db_item.unit = domain_item.unit
                    db_item.calories = domain_item.calories
                    db_item.protein = domain_item.macros.protein
                    db_item.carbs = domain_item.macros.carbs
                    db_item.fat = domain_item.macros.fat
                    db_item.confidence = domain_item.confidence
                    db_item.fdc_id = getattr(domain_item, 'fdc_id', None)
                    db_item.is_custom = getattr(domain_item, 'is_custom', False)
                    logger.info(f"Updated food item: {domain_item.name}")
                else:
                    # Add new item
                    db_item = DBFoodItem.from_domain(domain_item, nutrition_id=db_nutrition.id)
                    db.add(db_item)
                    logger.info(f"Added food item: {domain_item.name}")
</file>

<file path="src/infra/services/firebase_auth_service.py">
"""Firebase Authentication Service for user management operations."""
import logging
from typing import Optional

import firebase_admin.auth
from firebase_admin import auth
from firebase_admin.auth import UserNotFoundError

logger = logging.getLogger(__name__)


class FirebaseAuthService:
    """Service for managing Firebase Authentication users."""

    @staticmethod
    def delete_firebase_user(firebase_uid: str) -> bool:
        """
        Delete a user from Firebase Authentication.

        Args:
            firebase_uid: The Firebase UID of the user to delete

        Returns:
            bool: True if deletion was successful, False otherwise

        Raises:
            Exception: If an unexpected error occurs during deletion
        """
        try:
            auth.delete_user(firebase_uid)
            logger.info(f"Successfully deleted Firebase user")
            return True

        except UserNotFoundError:
            logger.warning(f"Firebase user not found - may have been already deleted")
            # User already deleted is considered a success for idempotency
            return True

        except Exception as e:
            logger.error(f"Failed to delete Firebase user: {str(e)}")
            raise Exception(f"Failed to delete user from Firebase: {str(e)}")

    @staticmethod
    def get_firebase_user(firebase_uid: str) -> Optional[auth.UserRecord]:
        """
        Get a user from Firebase Authentication.

        Args:
            firebase_uid: The Firebase UID of the user

        Returns:
            Optional[auth.UserRecord]: The user record if found, None otherwise
        """
        try:
            return auth.get_user(firebase_uid)
        except UserNotFoundError:
            logger.warning(f"Firebase user not found")
            return None
        except Exception as e:
            logger.error(f"Failed to get Firebase user: {str(e)}")
            return None

    @staticmethod
    def verify_firebase_user_exists(firebase_uid: str) -> bool:
        """
        Check if a user exists in Firebase Authentication.

        Args:
            firebase_uid: The Firebase UID to check

        Returns:
            bool: True if user exists, False otherwise
        """
        user = FirebaseAuthService.get_firebase_user(firebase_uid)
        return user is not None

    @staticmethod
    def revoke_refresh_tokens(firebase_uid: str) -> bool:
        """
        Revoke all refresh tokens for a Firebase user.
        This invalidates all existing sessions and forces re-authentication.

        Args:
            firebase_uid: The Firebase UID of the user

        Returns:
            bool: True if revocation was successful, False otherwise
        """
        try:
            auth.revoke_refresh_tokens(firebase_uid)
            logger.info(f"Successfully revoked refresh tokens for Firebase user")
            return True

        except UserNotFoundError:
            logger.warning(f"Firebase user not found - tokens already invalidated")
            return True

        except Exception as e:
            logger.error(f"Failed to revoke refresh tokens: {str(e)}")
            return False
</file>

<file path="src/infra/websocket/connection_manager.py">
"""
WebSocket connection manager for real-time chat.
Manages active WebSocket connections and message broadcasting.
"""
import asyncio
import logging
from typing import Dict, Set
from fastapi import WebSocket

logger = logging.getLogger(__name__)


class ConnectionManager:
    """Manages WebSocket connections for real-time chat."""
    
    def __init__(self):
        # Map of thread_id -> set of active WebSocket connections
        self.active_connections: Dict[str, Set[WebSocket]] = {}
        # Map of user_id -> set of active WebSocket connections (for user-level broadcasts)
        self.user_connections: Dict[str, Set[WebSocket]] = {}
        # Lock to protect connection dictionaries from concurrent modifications
        self._lock = asyncio.Lock()
    
    async def connect(self, websocket: WebSocket, thread_id: str, user_id: str):
        """Accept and register a new WebSocket connection."""
        await websocket.accept()
        
        async with self._lock:
            # Add to thread connections
            if thread_id not in self.active_connections:
                self.active_connections[thread_id] = set()
            self.active_connections[thread_id].add(websocket)
            
            # Add to user connections
            if user_id not in self.user_connections:
                self.user_connections[user_id] = set()
            self.user_connections[user_id].add(websocket)
        
        logger.info(f"WebSocket connected for thread {thread_id}, user {user_id}")
    
    async def _remove_connection(self, websocket: WebSocket):
        """Remove a connection from both dictionaries."""
        async with self._lock:
            # Remove from all thread connections
            threads_to_remove = []
            for thread_id, connections in self.active_connections.items():
                if websocket in connections:
                    connections.discard(websocket)
                    if not connections:
                        threads_to_remove.append(thread_id)
            
            # Clean up empty thread entries
            for thread_id in threads_to_remove:
                del self.active_connections[thread_id]
            
            # Remove from all user connections
            users_to_remove = []
            for user_id, connections in self.user_connections.items():
                if websocket in connections:
                    connections.discard(websocket)
                    if not connections:
                        users_to_remove.append(user_id)
            
            # Clean up empty user entries
            for user_id in users_to_remove:
                del self.user_connections[user_id]
    
    async def disconnect(self, websocket: WebSocket, thread_id: str, user_id: str):
        """Unregister a WebSocket connection."""
        await self._remove_connection(websocket)
        logger.info(f"WebSocket disconnected for thread {thread_id}, user {user_id}")
    
    async def send_to_thread(self, thread_id: str, message: dict):
        """Send a message to all connections subscribed to a thread."""
        # Make a copy of connections to avoid iteration issues during concurrent modifications
        async with self._lock:
            if thread_id not in self.active_connections:
                logger.debug(f"No active connections for thread {thread_id}")
                return
            # Create a copy of the set to iterate over safely
            connections_copy = set(self.active_connections[thread_id])
        
        # Send messages outside the lock to avoid blocking other operations
        disconnected = set()
        for connection in connections_copy:
            try:
                await connection.send_json(message)
            except Exception as e:
                logger.error(f"Error sending message to WebSocket: {e}")
                disconnected.add(connection)
        
        # Clean up disconnected connections from both dictionaries
        for connection in disconnected:
            await self._remove_connection(connection)
    
    async def send_to_user(self, user_id: str, message: dict):
        """Send a message to all of a user's connections."""
        # Make a copy of connections to avoid iteration issues during concurrent modifications
        async with self._lock:
            if user_id not in self.user_connections:
                logger.debug(f"No active connections for user {user_id}")
                return
            # Create a copy of the set to iterate over safely
            connections_copy = set(self.user_connections[user_id])
        
        # Send messages outside the lock to avoid blocking other operations
        disconnected = set()
        for connection in connections_copy:
            try:
                await connection.send_json(message)
            except Exception as e:
                logger.error(f"Error sending message to WebSocket: {e}")
                disconnected.add(connection)
        
        # Clean up disconnected connections from both dictionaries
        for connection in disconnected:
            await self._remove_connection(connection)
    
    async def broadcast_message_chunk(self, thread_id: str, chunk: str, metadata: dict):
        """Broadcast a streaming message chunk to all thread subscribers."""
        await self.send_to_thread(thread_id, {
            "type": "message_chunk",
            "thread_id": thread_id,
            "chunk": chunk,
            "metadata": metadata
        })
    
    async def broadcast_message_complete(self, thread_id: str, message: dict):
        """
        Broadcast a completed message to all thread subscribers.
        
        Message includes follow_ups and structured_data when available in metadata.
        """
        # Extract structured data from metadata for convenience
        metadata = message.get("metadata", {})
        follow_ups = metadata.get("follow_ups", [])
        structured_data = metadata.get("structured_data")
        
        await self.send_to_thread(thread_id, {
            "type": "message_complete",
            "thread_id": thread_id,
            "message": message,
            "follow_ups": follow_ups,
            "structured_data": structured_data
        })
    
    async def broadcast_structured_data(self, thread_id: str, structured_data: dict):
        """
        Broadcast structured data (follow-ups, meal suggestions) to all thread subscribers.
        
        This is used to send structured data separately from the main message,
        useful for progressive updates during streaming.
        """
        await self.send_to_thread(thread_id, {
            "type": "structured_data",
            "thread_id": thread_id,
            "data": structured_data
        })
    
    async def broadcast_typing_indicator(self, thread_id: str, is_typing: bool):
        """Broadcast typing indicator to all thread subscribers."""
        await self.send_to_thread(thread_id, {
            "type": "typing_indicator",
            "thread_id": thread_id,
            "is_typing": is_typing
        })
    
    async def get_connection_count(self, thread_id: str = None) -> int:
        """Get number of active connections for a thread or total."""
        async with self._lock:
            if thread_id:
                return len(self.active_connections.get(thread_id, set()))
            return sum(len(conns) for conns in self.active_connections.values())


# Global connection manager instance
chat_connection_manager = ConnectionManager()
</file>

<file path="src/api/mappers/tdee_mapper.py">
"""
Mapper for TDEE calculation DTOs and domain models.
"""
from src.api.mappers.base_mapper import BaseMapper
from src.api.schemas.request import TdeeCalculationRequest
from src.api.schemas.response import (
    TdeeCalculationResponse,
    MacroTargetsResponse
)
from src.domain.model.user import (
    TdeeRequest,
    TdeeResponse,
    Sex,
    ActivityLevel,
    Goal,
    UnitSystem
)


class TdeeMapper(BaseMapper[TdeeRequest, TdeeCalculationRequest, TdeeCalculationResponse]):
    """Mapper for TDEE calculation data transformation."""
    
    def to_domain(self, dto: TdeeCalculationRequest) -> TdeeRequest:
        """
        Convert TdeeCalculationRequest DTO to TdeeRequest domain model.
        
        Args:
            dto: TDEE calculation request DTO
            
        Returns:
            TdeeRequest domain model
        """
        # Map string values to enums
        sex_map = {
            'male': Sex.MALE,
            'female': Sex.FEMALE
        }
        
        activity_map = {
            'sedentary': ActivityLevel.SEDENTARY,
            'light': ActivityLevel.LIGHT,
            'moderate': ActivityLevel.MODERATE,
            'active': ActivityLevel.ACTIVE,
            'extra': ActivityLevel.EXTRA
        }
        
        goal_map = {
            'cut': Goal.CUT,
            'bulk': Goal.BULK,
            'recomp': Goal.RECOMP
        }
        
        unit_map = {
            'metric': UnitSystem.METRIC,
            'imperial': UnitSystem.IMPERIAL
        }
        
        return TdeeRequest(
            age=dto.age,
            sex=sex_map[dto.sex],
            height=dto.height,
            weight=dto.weight,
            body_fat_pct=dto.body_fat_percentage,
            activity_level=activity_map[dto.activity_level],
            goal=goal_map[dto.goal],
            unit_system=unit_map[dto.unit_system]
        )
    
    def to_response_dto(self, domain: TdeeResponse) -> TdeeCalculationResponse:
        """
        Convert TdeeResponse domain model to TdeeCalculationResponse DTO.
        
        Args:
            domain: TDEE response domain model
            
        Returns:
            TdeeCalculationResponse DTO
        """
        # Convert macro targets
        macros_dto = MacroTargetsResponse(
            calories=domain.macros.calories,
            protein=domain.macros.protein,
            fat=domain.macros.fat,
            carbs=domain.macros.carbs
        )
        
        return TdeeCalculationResponse(
            bmr=domain.bmr,
            tdee=domain.tdee,
            macros=macros_dto,
            goal=domain.goal.value  # Convert enum to string
        )
    
    @staticmethod
    def map_to_profile_dict(dto: TdeeCalculationRequest) -> dict:
        """
        Convert TdeeCalculationRequest to profile dictionary for database.
        
        Args:
            dto: TDEE calculation request DTO
            
        Returns:
            Dictionary suitable for UserProfile creation
        """
        return {
            "age": dto.age,
            "gender": dto.sex,
            "height_cm": dto.height if dto.unit_system == "metric" else dto.height * 2.54,
            "weight_kg": dto.weight if dto.unit_system == "metric" else dto.weight * 0.453592,
            "body_fat_percentage": dto.body_fat_percentage
        }
</file>

<file path="src/api/routes/v1/health.py">
"""
Health check endpoints for monitoring and status.
"""

import asyncio
from typing import Any, Dict, Optional

from fastapi import APIRouter
from fastapi.responses import JSONResponse
from sqlalchemy import text

from src.infra.database.config import (
    POOL_MAX_OVERFLOW,
    TOTAL_POOL_CAPACITY,
    engine,
)

router = APIRouter(tags=["Health"])


@router.get("/health")
async def health_check():
    """
    Basic health check endpoint for uptime monitoring.
    """
    return JSONResponse(
        status_code=200,
        content={
            "status": "healthy",
            "message": "API is running",
        },
    )


@router.get("/")
async def root():
    """
    Root endpoint with API information.
    """
    return {
        "name": "MealTrack API",
        "version": "1.0.0",
        "description": "Meal tracking and nutritional analysis API",
        "documentation": {
            "swagger": "/docs",
            "redoc": "/redoc",
        },
    }


@router.get("/health/db-pool")
async def database_pool_status():
    """
    Inspect SQLAlchemy connection pool metrics.
    """
    try:
        pool = engine.pool
        checked_out = pool.checkedout()
        pool_size = pool.size()
        overflow = pool.overflow()
        available = max(pool_size - checked_out, 0)
        utilization_pct = (checked_out / pool_size) * 100 if pool_size > 0 else 0.0

        return {
            "status": "healthy",
            "pool_size": pool_size,
            "max_overflow": POOL_MAX_OVERFLOW,
            "checked_out": checked_out,
            "available": available,
            "overflow": overflow,
            "total_capacity": TOTAL_POOL_CAPACITY,
            "utilization_pct": round(utilization_pct, 2),
        }
    except Exception as exc:
        return JSONResponse(
            status_code=503,
            content={
                "status": "error",
                "error": str(exc),
            },
        )


@router.get("/health/mysql-connections")
async def mysql_connection_status():
    """
    Return active MySQL connection counts for the application.
    """
    try:
        stats = await _fetch_mysql_connection_stats()
        return {
            "status": "healthy",
            **stats,
        }
    except Exception as exc:
        return JSONResponse(
            status_code=503,
            content={
                "status": "error",
                "error": str(exc),
            },
        )


async def _fetch_mysql_connection_stats() -> Dict[str, Any]:
    username = engine.url.username

    def _query() -> Dict[str, Any]:
        with engine.connect() as connection:
            params = {}
            where_clause = ""
            if username:
                where_clause = "WHERE user = :user"
                params["user"] = username

            active_result = connection.execute(
                text(
                    f"SELECT COUNT(*) AS count FROM information_schema.processlist {where_clause}"
                ),
                params,
            )
            active_connections = active_result.scalar_one()

            max_conn_row = connection.execute(
                text("SHOW VARIABLES LIKE 'max_connections'")
            ).fetchone()
            max_connections: Optional[int] = None
            if max_conn_row and len(max_conn_row) > 1:
                try:
                    max_connections = int(max_conn_row[1])
                except (TypeError, ValueError):
                    max_connections = None

            utilization_pct: Optional[float] = None
            if max_connections:
                utilization_pct = (active_connections / max_connections) * 100

            return {
                "active_connections": active_connections,
                "pool_capacity": TOTAL_POOL_CAPACITY,
                "max_connections": max_connections,
                "utilization_pct": (
                    round(utilization_pct, 2) if utilization_pct is not None else None
                ),
            }

    return await asyncio.to_thread(_query)


@router.get("/health/notifications")
async def notification_health_check():
    """
    Health check for push notification system.
    Checks: Firebase SDK init, APNS config status, token stats.
    """
    try:
        from src.infra.services.firebase_service import FirebaseService
        from src.infra.database.config import SessionLocal
        from src.infra.database.models.notification import UserFcmToken as DBToken
        from sqlalchemy import func

        firebase_service = FirebaseService()

        health_status = {
            "status": "healthy",
            "firebase_initialized": firebase_service.is_initialized(),
            "components": {},
        }

        # Check Firebase Admin SDK
        if not firebase_service.is_initialized():
            health_status["status"] = "degraded"
            health_status["components"]["firebase_sdk"] = {
                "status": "error",
                "message": "Firebase Admin SDK not initialized",
            }
        else:
            health_status["components"]["firebase_sdk"] = {
                "status": "healthy",
                "message": "Firebase Admin SDK initialized",
            }

        # Get token stats from database
        db = SessionLocal()
        try:
            total_tokens = db.query(func.count(DBToken.id)).scalar()
            active_tokens = (
                db.query(func.count(DBToken.id)).filter(DBToken.is_active).scalar()
            )
            inactive_tokens = total_tokens - active_tokens

            health_status["components"]["fcm_tokens"] = {
                "status": "healthy",
                "total": total_tokens,
                "active": active_tokens,
                "inactive": inactive_tokens,
                "inactive_rate": (
                    round(inactive_tokens / total_tokens * 100, 2)
                    if total_tokens > 0
                    else 0
                ),
            }

            # Warn if high inactive rate
            if total_tokens > 0 and (inactive_tokens / total_tokens) > 0.5:
                health_status["status"] = "warning"
                health_status["components"]["fcm_tokens"][
                    "message"
                ] = "High inactive token rate"
        finally:
            db.close()

        return JSONResponse(
            status_code=200 if health_status["status"] == "healthy" else 503,
            content=health_status,
        )

    except Exception as e:
        return JSONResponse(
            status_code=503, content={"status": "error", "error": str(e)}
        )
</file>

<file path="src/api/routes/v1/notifications.py">
"""
Notifications API endpoints for push notification management.
"""
from fastapi import APIRouter, Depends

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request.notification_requests import (
    FcmTokenRegistrationRequest,
    FcmTokenDeletionRequest,
    NotificationPreferencesUpdateRequest
)
from src.api.schemas.response.notification_responses import (
    FcmTokenResponse,
    NotificationPreferencesResponse,
    NotificationPreferencesUpdateResponse
)
from src.app.commands.notification import (
    RegisterFcmTokenCommand,
    DeleteFcmTokenCommand,
    UpdateNotificationPreferencesCommand
)
from src.app.queries.notification import GetNotificationPreferencesQuery
from src.infra.event_bus import EventBus

router = APIRouter(prefix="/v1/notifications", tags=["Notifications"])


@router.post("/tokens", response_model=FcmTokenResponse)
async def register_fcm_token(
    request: FcmTokenRegistrationRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Register an FCM token for push notifications.
    
    This endpoint allows mobile apps to register their FCM tokens
    for receiving push notifications.
    """
    try:
        command = RegisterFcmTokenCommand(
            user_id=user_id,
            fcm_token=request.fcm_token,
            device_type=request.device_type,
            timezone=request.timezone
        )
        
        result = await event_bus.send(command)
        
        return FcmTokenResponse(
            success=result["success"],
            message=result["message"]
        )
        
    except Exception as e:
        raise handle_exception(e)


@router.delete("/tokens", response_model=FcmTokenResponse)
async def delete_fcm_token(
    request: FcmTokenDeletionRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    # Get user_id from dev auth bypass
    """
    Delete an FCM token (used during logout).
    
    This endpoint allows mobile apps to unregister their FCM tokens
    when users log out.
    """
    try:
        command = DeleteFcmTokenCommand(
            user_id=user_id,
            fcm_token=request.fcm_token
        )
        
        result = await event_bus.send(command)
        
        return FcmTokenResponse(
            success=result["success"],
            message=result["message"]
        )
        
    except Exception as e:
        raise handle_exception(e)


@router.get("/preferences", response_model=NotificationPreferencesResponse)
async def get_notification_preferences(
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    # Get user_id from dev auth bypass
    """
    Get user's notification preferences.
    
    Returns the current notification preferences for the user.
    If no preferences exist, creates and returns default preferences.
    """
    try:
        query = GetNotificationPreferencesQuery(user_id=user_id)
        
        result = await event_bus.send(query)
        
        return NotificationPreferencesResponse(**result)
        
    except Exception as e:
        raise handle_exception(e)


@router.put("/preferences", response_model=NotificationPreferencesUpdateResponse)
async def update_notification_preferences(
    request: NotificationPreferencesUpdateRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Update user's notification preferences.
    
    Updates the notification preferences for the user.
    Only provided fields will be updated.
    """
    try:
        command = UpdateNotificationPreferencesCommand(
            user_id=user_id,
            meal_reminders_enabled=request.meal_reminders_enabled,
            water_reminders_enabled=request.water_reminders_enabled,
            sleep_reminders_enabled=request.sleep_reminders_enabled,
            progress_notifications_enabled=request.progress_notifications_enabled,
            reengagement_notifications_enabled=request.reengagement_notifications_enabled,
            breakfast_time_minutes=request.breakfast_time_minutes,
            lunch_time_minutes=request.lunch_time_minutes,
            dinner_time_minutes=request.dinner_time_minutes,
            water_reminder_interval_hours=request.water_reminder_interval_hours,
            sleep_reminder_time_minutes=request.sleep_reminder_time_minutes,
        )
        
        result = await event_bus.send(command)
        
        return NotificationPreferencesUpdateResponse(
            success=result["success"],
            preferences=NotificationPreferencesResponse(**result["preferences"])
        )
        
    except Exception as e:
        raise handle_exception(e)
</file>

<file path="src/api/routes/v1/webhooks.py">
"""
Webhook handlers for RevenueCat events.

Syncs subscription data to local database.
"""
import logging
import os
import uuid
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, Request, HTTPException, Header

from src.infra.database.models.subscription import Subscription
from src.infra.database.models.user.user import User
from src.infra.database.uow import UnitOfWork

router = APIRouter(prefix="/v1/webhooks", tags=["Webhooks"])
logger = logging.getLogger(__name__)


@router.post("/revenuecat")
async def revenuecat_webhook(
    request: Request,
    authorization: Optional[str] = Header(None)
):
    """
    Handle RevenueCat webhook events.
    
    This keeps your local database in sync with RevenueCat.
    """
    
    # Verify authorization (if configured)
    webhook_secret = os.getenv("REVENUECAT_WEBHOOK_SECRET", "")
    if webhook_secret:
        if authorization != webhook_secret:
            logger.warning("Invalid RevenueCat webhook authorization")
            raise HTTPException(status_code=401, detail="Unauthorized")
    
    # Parse webhook payload
    try:
        payload = await request.json()
    except Exception as e:
        logger.error(f"Failed to parse webhook: {e}")
        raise HTTPException(status_code=400, detail="Invalid JSON")
    
    # Extract event data
    event = payload.get("event", {})
    event_type = event.get("type")
    app_user_id = event.get("app_user_id")
    
    logger.info(f"RevenueCat webhook: {event_type} for user {app_user_id}")
    
    # Get user
    with UnitOfWork() as uow:
        # Find user by firebase_uid (app_user_id from RevenueCat)
        user = uow.session.query(User).filter_by(firebase_uid=app_user_id).first()
        if not user:
            logger.warning(f"User not found: {app_user_id}")
            return {"status": "user_not_found"}
        
        # Handle events
        try:
            if event_type == "INITIAL_PURCHASE":
                handle_purchase(uow, user, event)
                
            elif event_type == "RENEWAL":
                handle_renewal(uow, user, event)
                
            elif event_type == "CANCELLATION":
                handle_cancellation(uow, user, event)
                
            elif event_type == "EXPIRATION":
                handle_expiration(uow, user, event)
                
            elif event_type == "BILLING_ISSUE":
                handle_billing_issue(uow, user, event)
                
            elif event_type == "PRODUCT_CHANGE":
                handle_product_change(uow, user, event)
            
            else:
                logger.info(f"Unhandled event type: {event_type}")
            
            uow.commit()
            
        except Exception as e:
            logger.error(f"Error handling webhook event {event_type}: {e}")
            uow.rollback()
            raise
    
    return {"status": "success"}


def handle_purchase(uow, user, event):
    """Handle initial purchase."""
    logger.info(f"Creating subscription for user {user.id}")
    
    # Check if subscription already exists
    existing = get_subscription_by_revenuecat_id(
        uow, 
        event.get("app_user_id")
    )
    
    if existing:
        logger.warning(f"Subscription already exists for {user.id}, updating instead")
        handle_renewal(uow, user, event)
        return
    
    # Create new subscription record
    subscription = Subscription(
        id=str(uuid.uuid4()),
        user_id=user.id,
        revenuecat_subscriber_id=event.get("app_user_id"),
        product_id=event.get("product_id"),
        platform=parse_platform(event.get("store")),
        status="active",
        purchased_at=parse_timestamp(event.get("purchased_at_ms")) or datetime.now(),
        expires_at=parse_timestamp(event.get("expiration_at_ms")),
        store_transaction_id=event.get("transaction_id"),
        is_sandbox=event.get("environment") == "SANDBOX",
    )
    
    uow.session.add(subscription)
    logger.info(f"User {user.id} purchased {subscription.product_id}")


def handle_renewal(uow, user, event):
    """Handle subscription renewal."""
    subscription = get_subscription_by_revenuecat_id(
        uow,
        event.get("app_user_id")
    )
    
    if subscription:
        subscription.expires_at = parse_timestamp(event.get("expiration_at_ms"))
        subscription.status = "active"
        subscription.updated_at = datetime.now()
        logger.info(f"User {user.id} renewed subscription until {subscription.expires_at}")
    else:
        logger.warning(f"Subscription not found for renewal, creating new one")
        handle_purchase(uow, user, event)


def handle_cancellation(uow, user, event):
    """Handle subscription cancellation."""
    subscription = get_subscription_by_revenuecat_id(
        uow,
        event.get("app_user_id")
    )
    
    if subscription:
        subscription.status = "cancelled"
        subscription.cancelled_at = datetime.now()
        subscription.updated_at = datetime.now()
        # Note: User still has access until expires_at
        logger.info(f"User {user.id} cancelled subscription (expires {subscription.expires_at})")


def handle_expiration(uow, user, event):
    """Handle subscription expiration."""
    subscription = get_subscription_by_revenuecat_id(
        uow,
        event.get("app_user_id")
    )
    
    if subscription:
        subscription.status = "expired"
        subscription.updated_at = datetime.now()
        logger.info(f"User {user.id} subscription expired")


def handle_billing_issue(uow, user, event):
    """Handle billing issues."""
    subscription = get_subscription_by_revenuecat_id(
        uow,
        event.get("app_user_id")
    )
    
    if subscription:
        subscription.status = "billing_issue"
        subscription.updated_at = datetime.now()
        logger.warning(f"Billing issue for user {user.id}")
        # TODO: Send notification to user


def handle_product_change(uow, user, event):
    """Handle product change (e.g., monthly to yearly)."""
    subscription = get_subscription_by_revenuecat_id(
        uow,
        event.get("app_user_id")
    )
    
    if subscription:
        subscription.product_id = event.get("product_id")
        subscription.expires_at = parse_timestamp(event.get("expiration_at_ms"))
        subscription.status = "active"
        subscription.updated_at = datetime.now()
        logger.info(f"User {user.id} changed to {subscription.product_id}")


def get_subscription_by_revenuecat_id(uow, revenuecat_id: str):
    """Get subscription by RevenueCat subscriber ID."""
    return uow.subscriptions.get_by_revenuecat_id(revenuecat_id)


def parse_platform(store: str) -> str:
    """Parse store name to platform."""
    if not store:
        return "ios"
    
    store_upper = store.upper()
    store_map = {
        "APP_STORE": "ios",
        "PLAY_STORE": "android", 
        "STRIPE": "web",
        "MAC_APP_STORE": "ios",
    }
    return store_map.get(store_upper, "ios")


def parse_timestamp(ms: Optional[int]) -> Optional[datetime]:
    """Parse millisecond timestamp to datetime."""
    if ms is None:
        return None
    try:
        return datetime.fromtimestamp(ms / 1000)
    except Exception as e:
        logger.error(f"Error parsing timestamp {ms}: {e}")
        return None


@router.get("/revenuecat/health")
async def webhook_health():
    """Health check for webhook."""
    return {"status": "ok", "service": "revenuecat_webhook"}
</file>

<file path="src/api/schemas/request/meal_suggestion_requests.py">
"""
Request schemas for meal suggestion generation.
"""

import warnings
from datetime import datetime
from enum import Enum
from typing import List, Literal, Optional

from pydantic import BaseModel, Field, field_validator


class MealSizeEnum(str, Enum):
    """DEPRECATED: T-shirt sizing for meal portions. Use MealPortionTypeEnum."""

    S = "S"  # 10% of daily TDEE
    M = "M"  # 20%
    L = "L"  # 40%
    XL = "XL"  # 60%
    OMAD = "OMAD"  # 100%


class MealPortionTypeEnum(str, Enum):
    """Simplified meal portion types (replaces MealSizeEnum)."""

    SNACK = "snack"  # Fixed ~150-300 kcal
    MAIN = "main"  # Calculated from TDEE / meals_per_day
    OMAD = "omad"  # Full daily target


def map_legacy_size_to_type(size: MealSizeEnum) -> MealPortionTypeEnum:
    """Map legacy meal size to new portion type."""
    mapping = {
        MealSizeEnum.S: MealPortionTypeEnum.SNACK,
        MealSizeEnum.M: MealPortionTypeEnum.SNACK,
        MealSizeEnum.L: MealPortionTypeEnum.MAIN,
        MealSizeEnum.XL: MealPortionTypeEnum.MAIN,
        MealSizeEnum.OMAD: MealPortionTypeEnum.OMAD,
    }
    return mapping[size]


class CookingTimeEnum(int, Enum):
    """Predefined cooking time options."""

    QUICK = 20
    MEDIUM = 30
    STANDARD = 45
    LONG = 60


class MealSuggestionRequest(BaseModel):
    """
    Request schema for generating meal suggestions.

    Generates exactly 3 meal suggestions based on:
    - meal_type, meal_portion_type (or legacy meal_size), ingredients, cooking_time
    """

    meal_type: Literal["breakfast", "lunch", "dinner", "snack"] = Field(
        ..., description="Type of meal to generate suggestions for"
    )
    # NEW: Simplified portion type (preferred)
    meal_portion_type: Optional[MealPortionTypeEnum] = Field(
        None,
        description="Portion type: snack (~225 kcal), main (TDEE-based), omad (full daily)",
    )
    # DEPRECATED: Keep for backward compatibility
    meal_size: Optional[MealSizeEnum] = Field(
        None, description="DEPRECATED: Use meal_portion_type instead"
    )
    ingredients: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Optional list of available ingredients (max 20)",
    )
    ingredient_image_url: Optional[str] = Field(
        None, description="Optional photo of ingredients for AI recognition"
    )
    cooking_time_minutes: CookingTimeEnum = Field(
        ..., description="Cooking time constraint (20/30/45/60 minutes)"
    )
    dietary_preferences: List[str] = Field(
        default_factory=list,
        description="Optional dietary preferences (e.g., vegetarian, vegan, halal)",
    )
    calorie_target: Optional[int] = Field(
        None,
        gt=0,
        description="Optional calorie target override (calculated from portion type if not provided)",
    )
    exclude_ids: List[str] = Field(
        default_factory=list,
        description="List of meal IDs to exclude (for regeneration)",
    )

    @field_validator("meal_size", mode="before")
    @classmethod
    def warn_deprecated_meal_size(cls, v):
        if v is not None:
            warnings.warn(
                "meal_size is deprecated, use meal_portion_type instead",
                DeprecationWarning,
                stacklevel=2,
            )
        return v

    def get_effective_portion_type(self) -> MealPortionTypeEnum:
        """Get effective portion type, preferring new field over legacy."""
        if self.meal_portion_type is not None:
            return self.meal_portion_type
        if self.meal_size is not None:
            return map_legacy_size_to_type(self.meal_size)
        # Default based on meal_type
        if self.meal_type == "snack":
            return MealPortionTypeEnum.SNACK
        return MealPortionTypeEnum.MAIN

    class Config:
        json_schema_extra = {
            "example": {
                "meal_type": "lunch",
                "meal_portion_type": "main",
                "ingredients": ["chicken breast", "broccoli", "rice"],
                "cooking_time_minutes": 30,
            }
        }


class RegenerateSuggestionsRequest(BaseModel):
    """Request to regenerate 3 NEW meal ideas (excludes shown)."""

    session_id: str = Field(..., description="Suggestion session ID")
    exclude_ids: List[str] = Field(
        default_factory=list, description="Suggestion IDs to exclude from regeneration"
    )

    class Config:
        json_schema_extra = {
            "example": {
                "session_id": "session_abc123",
                "exclude_ids": ["meal_lunch_1234", "meal_lunch_5678"],
            }
        }


class AcceptSuggestionRequest(BaseModel):
    """Request to accept suggestion with portion multiplier."""

    portion_multiplier: int = Field(
        default=1, ge=1, le=4, description="Portion multiplier (1x, 2x, 3x, 4x)"
    )
    consumed_at: Optional[datetime] = Field(
        None, description="Optional consumption timestamp (defaults to now)"
    )

    class Config:
        json_schema_extra = {
            "example": {"portion_multiplier": 2, "consumed_at": "2025-12-30T12:00:00Z"}
        }


class RejectSuggestionRequest(BaseModel):
    """Request to reject suggestion with optional feedback."""

    feedback: Optional[str] = Field(
        None,
        max_length=500,
        description="Optional feedback on why suggestion was rejected",
    )

    class Config:
        json_schema_extra = {"example": {"feedback": "Too spicy for my taste"}}


class SaveMealSuggestionRequest(BaseModel):
    """
    Request schema for saving a selected meal suggestion to meal history.
    (LEGACY - use AcceptSuggestionRequest instead)
    """

    suggestion_id: str = Field(..., description="ID of the suggestion to save")
    name: str = Field(..., description="Name of the meal")
    description: str = Field(default="", description="Description of the meal")
    meal_type: Literal["breakfast", "lunch", "dinner", "snack"] = Field(
        ..., description="Type of meal"
    )
    estimated_cook_time_minutes: int = Field(
        ..., description="Total cooking time in minutes"
    )
    calories: int = Field(..., description="Calories for the meal")
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams")
    fat: float = Field(..., description="Fat in grams")
    portion_multiplier: int = Field(
        default=1,
        ge=1,
        le=4,
        description="Portion multiplier (1x, 2x, 3x, 4x) - scales macros before saving",
    )
    ingredients_list: List[str] = Field(
        default_factory=list, description="List of ingredients"
    )
    instructions: List[str] = Field(
        default_factory=list, description="Cooking instructions"
    )
    meal_date: Optional[str] = Field(
        None,
        description="Date to save the meal for (YYYY-MM-DD format), defaults to today",
    )

    class Config:
        json_schema_extra = {
            "example": {
                "suggestion_id": "meal_lunch_1234",
                "name": "Grilled Chicken with Rice",
                "description": "Healthy high-protein lunch",
                "meal_type": "lunch",
                "estimated_cook_time_minutes": 25,
                "calories": 520,
                "protein": 45.0,
                "carbs": 55.0,
                "fat": 12.0,
                "portion_multiplier": 1,
                "ingredients_list": ["chicken breast", "brown rice", "broccoli"],
                "instructions": ["Grill chicken", "Cook rice", "Steam broccoli"],
                "meal_date": "2024-01-15",
            }
        }
</file>

<file path="src/api/schemas/response/meal_suggestion_responses.py">
"""
Response schemas for meal suggestion generation (Phase 06).
"""

from datetime import datetime
from typing import List, Optional

from pydantic import BaseModel, Field


class MacrosSchema(BaseModel):
    """Macronutrient information."""

    calories: int = Field(..., description="Total calories")
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams")
    fat: float = Field(..., description="Fat in grams")


class MacroEstimateResponse(BaseModel):
    """Alias for MacrosSchema for consistency."""

    calories: int = Field(..., description="Total calories")
    protein: float = Field(..., description="Protein in grams")
    carbs: float = Field(..., description="Carbohydrates in grams")
    fat: float = Field(..., description="Fat in grams")


class IngredientResponse(BaseModel):
    """Ingredient with amount and unit."""

    name: str = Field(..., description="Ingredient name")
    amount: float = Field(..., description="Amount/quantity")
    unit: str = Field(..., description="Unit (g, ml, tbsp, etc)")


class RecipeStepResponse(BaseModel):
    """Single recipe step with numbered instruction."""

    step: int = Field(..., description="Step number (1-indexed)")
    instruction: str = Field(..., description="Step instruction")
    duration_minutes: Optional[int] = Field(None, description="Duration for this step")


class MealSuggestionResponse(BaseModel):
    """
    A single meal suggestion with full recipe details (Phase 06).
    """

    id: str = Field(..., description="Unique identifier for this suggestion")
    meal_name: str = Field(..., description="Name of the meal")
    description: str = Field(..., description="Brief description of the meal")
    macros: MacroEstimateResponse = Field(
        ..., description="Macronutrient breakdown (base portion)"
    )
    ingredients: List[IngredientResponse] = Field(
        ..., description="List of ingredients with amounts"
    )
    recipe_steps: List[RecipeStepResponse] = Field(
        ..., description="Numbered cooking steps"
    )
    prep_time_minutes: int = Field(
        ..., description="Total prep time (includes cooking)"
    )
    confidence_score: float = Field(
        default=0.9, ge=0.0, le=1.0, description="AI confidence score (0.0-1.0)"
    )


# Alias for backward compatibility
MealSuggestionItem = MealSuggestionResponse


class SuggestionsListResponse(BaseModel):
    """
    Response containing 1-3 meal suggestions (Phase 06).
    Note: May return fewer than 3 if some generations fail.
    """

    session_id: str = Field(..., description="Suggestion session ID for tracking")
    meal_type: str = Field(
        ..., description="Type of meal (breakfast, lunch, dinner, snack)"
    )
    meal_portion_type: str = Field(
        ..., description="Portion type: snack, main, or omad"
    )
    target_calories: int = Field(
        ..., description="Calculated target calories for this portion type"
    )
    suggestions: List[MealSuggestionResponse] = Field(
        ..., min_length=1, max_length=3, description="1-3 meal suggestions (may be partial if generation fails)"
    )
    suggestion_count: int = Field(
        ..., ge=1, le=3, description="Number of suggestions returned (1-3)"
    )
    expires_at: datetime = Field(
        ..., description="Session expiration timestamp (4 hours)"
    )


# Alias for backward compatibility
MealSuggestionsResponse = SuggestionsListResponse


class AcceptedMealResponse(BaseModel):
    """Response after accepting suggestion with portion multiplier."""

    meal_id: str = Field(..., description="ID of saved meal in history")
    meal_name: str = Field(..., description="Name of the meal")
    macros: MacroEstimateResponse = Field(
        ..., description="Adjusted macros (after portion multiplier)"
    )
    saved_at: datetime = Field(..., description="Timestamp when meal was saved")

    class Config:
        json_schema_extra = {
            "example": {
                "meal_id": "meal_12345",
                "meal_name": "Grilled Chicken Rice Bowl",
                "macros": {"protein": 70.0, "carbs": 80.0, "fat": 30.0},
                "saved_at": "2025-12-30T12:00:00Z",
            }
        }


class SaveMealSuggestionResponse(BaseModel):
    """
    Response after saving a meal suggestion to history.
    (LEGACY - use AcceptedMealResponse instead)
    """

    success: bool = Field(..., description="Whether the save was successful")
    message: str = Field(..., description="Status message")
    meal_id: Optional[str] = Field(
        None, description="ID of the saved meal in the database"
    )
    meal_date: str = Field(..., description="Date the meal was saved for (YYYY-MM-DD)")

    class Config:
        json_schema_extra = {
            "example": {
                "success": True,
                "message": "Meal suggestion saved successfully to your meal history",
                "meal_id": "12345",
                "meal_date": "2024-01-15",
            }
        }
</file>

<file path="src/api/schemas/response/user_responses.py">
"""
User management response schemas for Firebase integration.
"""
from datetime import datetime
from typing import Optional

from pydantic import BaseModel, EmailStr, Field

from ..common.auth_enums import AuthProviderEnum


class SubscriptionInfo(BaseModel):
    """Subscription information."""
    product_id: str = Field(..., description="Subscription product ID (premium_monthly or premium_yearly)")
    status: str = Field(..., description="Subscription status (active, cancelled, expired, billing_issue)")
    expires_at: Optional[datetime] = Field(None, description="Subscription expiration date")
    is_monthly: bool = Field(..., description="Whether this is a monthly subscription")
    is_yearly: bool = Field(..., description="Whether this is a yearly subscription")
    platform: str = Field(..., description="Platform (ios, android, web)")


class UserProfileResponse(BaseModel):
    """Response containing user profile information."""
    id: str = Field(..., description="User internal ID")
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    email: EmailStr = Field(..., description="User email address")
    username: str = Field(..., description="Username")
    first_name: Optional[str] = Field(None, description="First name")
    last_name: Optional[str] = Field(None, description="Last name")
    phone_number: Optional[str] = Field(None, description="Phone number")
    display_name: Optional[str] = Field(None, description="Display name")
    photo_url: Optional[str] = Field(None, description="Profile photo URL")
    provider: AuthProviderEnum = Field(..., description="Authentication provider")
    is_active: bool = Field(..., description="Whether user account is active")
    onboarding_completed: bool = Field(..., description="Whether user completed onboarding")
    last_accessed: Optional[datetime] = Field(None, description="Last accessed timestamp")
    created_at: datetime = Field(..., description="Account creation timestamp")
    updated_at: datetime = Field(..., description="Last update timestamp")
    
    # Premium subscription fields
    is_premium: bool = Field(..., description="Whether user has active premium subscription")
    subscription: Optional[SubscriptionInfo] = Field(None, description="Active subscription details if any")


class UserSyncResponse(BaseModel):
    """Response from user sync operation."""
    user: UserProfileResponse = Field(..., description="User profile data")
    created: bool = Field(..., description="Whether user was newly created")
    updated: bool = Field(..., description="Whether existing user was updated")
    message: str = Field(..., description="Operation result message")


class UserStatusResponse(BaseModel):
    """Response containing user status information."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    onboarding_completed: bool = Field(..., description="Whether user completed onboarding")
    is_active: bool = Field(..., description="Whether user account is active")
    last_accessed: Optional[datetime] = Field(None, description="Last accessed timestamp")


class UserUpdateResponse(BaseModel):
    """Response from user update operations."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    updated: bool = Field(..., description="Whether update was successful")
    message: str = Field(..., description="Operation result message")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Update timestamp")


class OnboardingCompletionResponse(BaseModel):
    """Response from onboarding completion operation."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    onboarding_completed: bool = Field(..., description="Current onboarding completion status")
    updated: bool = Field(..., description="Whether update was successful")
    message: str = Field(..., description="Operation result message")


class UserMetricsResponse(BaseModel):
    """Response containing user's current metrics for settings display."""
    user_id: str = Field(..., description="User internal ID")
    age: int = Field(..., description="User age")
    gender: str = Field(..., description="User gender")
    height_cm: float = Field(..., description="Height in centimeters")
    weight_kg: float = Field(..., description="Current weight in kilograms")
    body_fat_percentage: Optional[float] = Field(None, description="Body fat percentage")
    activity_level: str = Field(..., description="Activity level")
    fitness_goal: str = Field(..., description="Current fitness goal")
    target_weight_kg: Optional[float] = Field(None, description="Target weight in kilograms")
    updated_at: datetime = Field(..., description="Last update timestamp")


class UserDeleteResponse(BaseModel):
    """Response from user account deletion operation."""
    firebase_uid: str = Field(..., description="Firebase user unique identifier")
    deleted: bool = Field(..., description="Whether deletion was successful")
    message: str = Field(..., description="Operation result message")
</file>

<file path="src/app/commands/meal_suggestion/__init__.py">
"""
Commands for meal suggestion operations.
"""
from .generate_meal_suggestions_command import GenerateMealSuggestionsCommand
from .save_meal_suggestion_command import SaveMealSuggestionCommand
from .regenerate_suggestions_command import RegenerateSuggestionsCommand
from .accept_suggestion_command import AcceptSuggestionCommand
from .reject_suggestion_command import RejectSuggestionCommand
from .discard_session_command import DiscardSessionCommand

__all__ = [
    'GenerateMealSuggestionsCommand',
    'SaveMealSuggestionCommand',
    'RegenerateSuggestionsCommand',
    'AcceptSuggestionCommand',
    'RejectSuggestionCommand',
    'DiscardSessionCommand'
]
</file>

<file path="src/app/commands/meal_suggestion/generate_meal_suggestions_command.py">
"""
Command for generating meal suggestions.
"""
from dataclasses import dataclass
from typing import List, Optional

from src.app.events.base import Command


@dataclass
class GenerateMealSuggestionsCommand(Command):
    """
    Command to generate exactly 3 meal suggestions based on user inputs.
    
    Supports optional ingredients, time constraints, dietary preferences,
    and calorie targets. Also supports regeneration by excluding previous suggestions.
    """
    
    # User identification
    user_id: str
    
    # Required input
    meal_type: str  # breakfast, lunch, dinner, snack

    meal_portion_type: str  # snack, main, omad
    
    # Optional inputs
    ingredients: List[str]  # Available ingredients
    time_available_minutes: Optional[int]  # Time constraint
    exclude_ids: List[str]  # Meal IDs to exclude (for regeneration)
    
    def __post_init__(self):
        """Validate command data."""
        valid_meal_types = ["breakfast", "lunch", "dinner", "snack"]
        if self.meal_type not in valid_meal_types:
            raise ValueError(f"meal_type must be one of {valid_meal_types}")
        
        valid_portion_types = ["snack", "main", "omad"]
        if self.meal_portion_type not in valid_portion_types:
            raise ValueError(f"meal_portion_type must be one of {valid_portion_types}")
        
        if (len(self.ingredients) < 1):
            raise ValueError("ingredients list must contain at least 1 item")
        
        if len(self.ingredients) > 20:
            raise ValueError("ingredients list cannot exceed 20 items")
        
        if self.time_available_minutes is not None and self.time_available_minutes <= 0:
            raise ValueError("time_available_minutes must be greater than 0")
</file>

<file path="src/app/commands/user/update_user_metrics_command.py">
"""
Command to update user metrics (weight, activity level, body fat).
"""
from dataclasses import dataclass


@dataclass
class UpdateUserMetricsCommand:
    """Update user metrics (including fitness goal) and trigger TDEE recalculation."""
    user_id: str
    weight_kg: float | None = None
    activity_level: str | None = None
    body_fat_percent: float | None = None
    fitness_goal: str | None = None
    override: bool = False
</file>

<file path="src/app/handlers/command_handlers/add_custom_ingredient_command_handler.py">
"""
Handler for adding custom ingredients to meals.
"""
import logging
from datetime import datetime
from typing import Dict, Any, Optional

from src.app.commands.meal import AddCustomIngredientCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_service import MealService
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService

logger = logging.getLogger(__name__)


@handles(AddCustomIngredientCommand)
class AddCustomIngredientCommandHandler(EventHandler[AddCustomIngredientCommand, Dict[str, Any]]):
    """Handler for adding custom ingredients to meals."""

    def __init__(self, meal_repository: MealRepositoryPort = None, cache_service: Optional[CacheService] = None):
        self.meal_repository = meal_repository
        self.meal_service = MealService(meal_repository) if meal_repository else None
        self.cache_service = cache_service

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.meal_repository = kwargs.get('meal_repository', self.meal_repository)
        if self.meal_repository:
            self.meal_service = MealService(self.meal_repository)
        self.cache_service = kwargs.get('cache_service', self.cache_service)

    async def handle(self, command: AddCustomIngredientCommand) -> Dict[str, Any]:
        """Handle adding custom ingredient to meal."""
        if not self.meal_service:
            raise RuntimeError("Meal service not configured")
        
        updated_meal = self.meal_service.add_custom_ingredient(
            meal_id=command.meal_id,
            name=command.name,
            quantity=command.quantity,
            unit=command.unit,
            nutrition=command.nutrition
        )
        
        await self._invalidate_daily_macros(updated_meal)

        return {
            "success": True,
            "meal_id": updated_meal.meal_id,
            "message": f"Added custom ingredient: {command.name}"
        }

    async def _invalidate_daily_macros(self, meal):
        if not self.cache_service or not meal:
            return
        created_at = meal.created_at or datetime.utcnow()
        cache_key, _ = CacheKeys.daily_macros(meal.user_id, created_at.date())
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/create_manual_meal_command_handler.py">
"""
Command handler for creating manual meals from selected USDA foods.
"""
import uuid
from datetime import datetime
from typing import Any, List, Optional
from uuid import uuid4

from src.app.commands.meal.create_manual_meal_command import CreateManualMealCommand
from src.app.events.base import EventHandler
from src.domain.model.meal import Meal, MealStatus
from src.domain.model.meal import MealImage
from src.domain.model.nutrition import Macros
from src.domain.model.nutrition import Nutrition, FoodItem as DomainFoodItem
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService


class CreateManualMealCommandHandler(EventHandler[CreateManualMealCommand, Any]):
    def __init__(self, meal_repository, food_data_service, mapping_service, cache_service: Optional[CacheService] = None):
        self.meal_repository = meal_repository
        self.food_data_service = food_data_service
        self.mapping_service = mapping_service
        self.cache_service = cache_service

    async def handle(self, event: CreateManualMealCommand):
        # Aggregate items with the same fdc_id first
        from collections import defaultdict
        aggregated_items = defaultdict(lambda: {"quantity": 0.0, "unit": "g"})
        
        for item in event.items:
            aggregated_items[item.fdc_id]["quantity"] += item.quantity
            aggregated_items[item.fdc_id]["unit"] = item.unit
        
        # Fetch details for all unique items
        fdc_ids = list(aggregated_items.keys())
        details_list = await self.food_data_service.get_multiple_foods(fdc_ids)
        details_by_id = {d.get("fdcId"): d for d in details_list}

        # Calculate nutrition
        total_calories = 0.0
        total_protein = 0.0
        total_carbs = 0.0
        total_fat = 0.0
        food_items: List[DomainFoodItem] = []

        for fdc_id, item_data in aggregated_items.items():
            details = details_by_id.get(fdc_id) or {}
            mapped = self.mapping_service.map_food_details(details)
            base_serving = float(mapped.get("serving_size") or 100.0)
            quantity = item_data["quantity"]
            factor = (quantity / base_serving) if base_serving > 0 else 0.0

            calories = float(mapped.get("calories") or 0.0) * factor
            protein = float(mapped["macros"].get("protein") or 0.0) * factor
            carbs = float(mapped["macros"].get("carbs") or 0.0) * factor
            fat = float(mapped["macros"].get("fat") or 0.0) * factor

            total_calories += calories
            total_protein += protein
            total_carbs += carbs
            total_fat += fat

            food_items.append(
                DomainFoodItem(
                    id=uuid.uuid4(),
                    name=mapped.get("name"),
                    quantity=quantity,
                    unit=item_data["unit"],
                    calories=calories,
                    macros=Macros(
                        protein=protein,
                        carbs=carbs,
                        fat=fat,
                    ),
                    micros=None,
                    confidence=1.0,
                    fdc_id=fdc_id,
                )
            )

        nutrition = Nutrition(
            calories=round(total_calories, 1),
            macros=Macros(
                protein=round(total_protein, 1),
                carbs=round(total_carbs, 1),
                fat=round(total_fat, 1),
            ),
            food_items=food_items,
            confidence_score=1.0,
        )

        # Determine the meal date - use target_date if provided, otherwise use now
        meal_date = event.target_date if event.target_date else datetime.now().date()
        meal_datetime = datetime.combine(meal_date, datetime.now().time())
        
        meal = Meal(
            meal_id=str(uuid4()),
            user_id=event.user_id,
            status=MealStatus.READY,
            created_at=meal_datetime,
            image=MealImage(
                image_id=str(uuid4()),
                format="jpeg",
                size_bytes=1,
                url=None,
            ),
            dish_name=event.dish_name,
            nutrition=nutrition,
            ready_at=meal_datetime,
            meal_type=event.meal_type,
        )

        saved_meal = self.meal_repository.save(meal)
        await self._invalidate_daily_macros(event.user_id, meal_date)
        return saved_meal

    async def _invalidate_daily_macros(self, user_id, target_date):
        if not self.cache_service:
            return
        cache_key, _ = CacheKeys.daily_macros(user_id, target_date)
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/app/handlers/command_handlers/generate_meal_suggestions_command_handler.py">
"""
GenerateMealSuggestionsCommandHandler - Handler for generating meal suggestions.
"""
import logging
from typing import List, Tuple

from src.app.commands.meal_suggestion import GenerateMealSuggestionsCommand
from src.app.events.base import EventHandler, handles
from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService
from src.domain.model.meal_suggestion import MealSuggestion, SuggestionSession

logger = logging.getLogger(__name__)


@handles(GenerateMealSuggestionsCommand)
class GenerateMealSuggestionsCommandHandler(
    EventHandler[GenerateMealSuggestionsCommand, Tuple[SuggestionSession, List[MealSuggestion]]]
):
    """Handler for generating exactly 3 meal suggestions."""

    def __init__(self, service: SuggestionOrchestrationService):
        self.service = service

    async def handle(
        self, command: GenerateMealSuggestionsCommand
    ) -> Tuple[SuggestionSession, List[MealSuggestion]]:
        """
        Generate meal suggestions based on user inputs.

        Args:
            command: GenerateMealSuggestionsCommand with user inputs

        Returns:
            Tuple of (SuggestionSession, List[MealSuggestion])
        """
        return await self.service.generate_suggestions(
            user_id=command.user_id,
            meal_type=command.meal_type,
            meal_portion_type=command.meal_portion_type,
            ingredients=command.ingredients,
            cooking_time_minutes=command.time_available_minutes,
        )
</file>

<file path="src/app/handlers/command_handlers/register_fcm_token_command_handler.py">
"""
Handler for registering FCM tokens.
"""

import logging
from typing import Any, Dict, Optional

from sqlalchemy.orm import Session

from src.app.commands.notification import RegisterFcmTokenCommand
from src.app.events.base import EventHandler, handles
from src.domain.model.notification import UserFcmToken, DeviceType
from src.domain.ports.notification_repository_port import NotificationRepositoryPort
from src.domain.services.timezone_utils import is_valid_timezone
from src.infra.repositories.user_repository import UserRepository

logger = logging.getLogger(__name__)


@handles(RegisterFcmTokenCommand)
class RegisterFcmTokenCommandHandler(
    EventHandler[RegisterFcmTokenCommand, Dict[str, Any]]
):
    """Handler for registering FCM tokens."""

    def __init__(
        self,
        notification_repository: NotificationRepositoryPort = None,
        db: Optional[Session] = None
    ):
        self.notification_repository = notification_repository
        self.db = db
        self.user_repository = UserRepository(db) if db else None

    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        self.notification_repository = kwargs.get(
            "notification_repository", self.notification_repository
        )
        self.db = kwargs.get("db", self.db)
        if self.db:
            self.user_repository = UserRepository(self.db)

    async def handle(self, command: RegisterFcmTokenCommand) -> Dict[str, Any]:
        """Handle FCM token registration with old token cleanup."""
        if not self.notification_repository:
            raise RuntimeError("Notification repository not configured")

        try:
            device_type = (
                DeviceType.IOS if command.device_type == "ios" else DeviceType.ANDROID
            )

            # 1. Deactivate OLD tokens for this user+device (token refresh scenario)
            existing_tokens = (
                self.notification_repository.find_active_fcm_tokens_by_user(
                    command.user_id
                )
            )
            deactivated_count = 0
            for old_token in existing_tokens:
                # Deactivate tokens of same device type (new token replaces old)
                if (
                    old_token.device_type == device_type
                    and old_token.fcm_token != command.fcm_token
                ):
                    self.notification_repository.deactivate_fcm_token(
                        old_token.fcm_token
                    )
                    deactivated_count += 1
                    logger.info(f"Deactivated old FCM token for user {command.user_id}")

            # 2. Create/update new token
            fcm_token = UserFcmToken.create_new(
                user_id=command.user_id,
                fcm_token=command.fcm_token,
                device_type=device_type,
            )

            saved_token = self.notification_repository.save_fcm_token(fcm_token)

            # 3. Update user timezone if provided and valid
            if command.timezone and self.user_repository:
                if is_valid_timezone(command.timezone):
                    self.user_repository.update_user_timezone(command.user_id, command.timezone)
                    logger.info(f"Updated timezone for user {command.user_id}: {command.timezone}")
                else:
                    logger.warning(f"Invalid timezone from user {command.user_id}: {command.timezone}")

            logger.info(
                f"FCM token registered for user {command.user_id}, "
                f"deactivated {deactivated_count} old tokens"
            )

            return {
                "success": True,
                "message": "Token registered successfully",
                "token_id": saved_token.token_id,
                "deactivated_old_tokens": deactivated_count,
            }
        except Exception as e:
            logger.error(f"Error registering FCM token: {e}")
            raise e
</file>

<file path="src/app/handlers/command_handlers/save_meal_suggestion_command_handler.py">
"""
SaveMealSuggestionCommandHandler - Handler for saving meal suggestions to history.
"""
import logging
from datetime import datetime
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.app.commands.meal_suggestion import SaveMealSuggestionCommand
from src.app.events.base import EventHandler, handles
from src.infra.database.config import get_db
from src.infra.database.models.enums import MealTypeEnum, PlanDurationEnum, FitnessGoalEnum
from src.infra.database.models.meal_planning import (
    MealPlan as MealPlanORM,
    MealPlanDay as MealPlanDayORM,
    PlannedMeal as PlannedMealORM
)
from src.infra.repositories.user_repository import UserRepository

logger = logging.getLogger(__name__)


@handles(SaveMealSuggestionCommand)
class SaveMealSuggestionCommandHandler(EventHandler[SaveMealSuggestionCommand, Dict[str, Any]]):
    """Handler for saving a meal suggestion to user's meal history."""
    
    def __init__(self, db: Session = None, user_repository=None):
        self.db = db
        self.user_repository = user_repository
    
    def set_dependencies(self, **kwargs):
        """Set dependencies for dependency injection."""
        if 'db' in kwargs:
            self.db = kwargs['db']
        if 'user_repository' in kwargs:
            self.user_repository = kwargs['user_repository']
    
    async def handle(self, command: SaveMealSuggestionCommand) -> Dict[str, Any]:
        """
        Save a meal suggestion to the user's meal history.
        
        Args:
            command: SaveMealSuggestionCommand with suggestion data
        
        Returns:
            Dict with success status, message, meal_id, and meal_date
        """
        db = self.db or next(get_db())
        user_repo = self.user_repository or UserRepository(db)
        
        try:
            # Fetch user to get preferences
            user = user_repo.find_by_id(command.user_id)
            
            if not user:
                raise ValueError(f"User {command.user_id} not found")
            
            # Get user profile for preferences
            user_profile = user.profiles[0] if user.profiles else None
            
            # Create or find existing meal plan for this date
            meal_plan_orm = self._get_or_create_meal_plan(
                db, command.user_id, command.meal_date, user_profile
            )
            
            # Get or create day plan for the date
            day_plan_orm = self._get_or_create_day_plan(
                db, meal_plan_orm.id, command.meal_date
            )
            
            # Create the planned meal
            meal_orm = PlannedMealORM(
                day_id=day_plan_orm.id,
                meal_type=MealTypeEnum(command.meal_type),
                name=command.name,
                description=command.description,
                prep_time=command.estimated_cook_time_minutes // 2,  # Estimate prep as half
                cook_time=command.estimated_cook_time_minutes // 2,  # Estimate cook as half
                calories=command.calories,
                protein=command.protein,
                carbs=command.carbs,
                fat=command.fat,
                ingredients=command.ingredients_list,
                seasonings=[],  # Seasonings included in ingredients_list
                instructions=command.instructions,
                is_vegetarian="vegetarian" in [tag.lower() for tag in command.instructions] if command.instructions else False,
                is_vegan="vegan" in [tag.lower() for tag in command.instructions] if command.instructions else False,
                is_gluten_free="gluten-free" in [tag.lower() for tag in command.instructions] if command.instructions else False,
                cuisine_type="International"
            )
            
            db.add(meal_orm)
            db.commit()
            db.refresh(meal_orm)
            
            logger.info(
                f"Saved meal suggestion '{command.name}' for user {command.user_id} "
                f"on {command.meal_date}"
            )
            
            return {
                "success": True,
                "message": "Meal suggestion saved successfully to your meal history",
                "meal_id": str(meal_orm.id),
                "meal_date": command.meal_date.isoformat()
            }
            
        except Exception as e:
            logger.error(f"Error saving meal suggestion: {str(e)}")
            if db:
                db.rollback()
            raise
        finally:
            if self.db is None and db:
                db.close()
    
    def _get_or_create_meal_plan(
        self, 
        db: Session, 
        user_id: str, 
        meal_date, 
        user_profile
    ) -> MealPlanORM:
        """
        Get existing meal plan for the date or create a new one.
        
        Args:
            db: Database session
            user_id: User identifier
            meal_date: Date for the meal
            user_profile: User profile with preferences
        
        Returns:
            MealPlanORM instance
        """
        # Try to find existing meal plan for this user and date
        existing_plan = (
            db.query(MealPlanORM)
            .join(MealPlanDayORM)
            .filter(
                MealPlanORM.user_id == user_id,
                MealPlanDayORM.date == meal_date
            )
            .first()
        )
        
        if existing_plan:
            return existing_plan
        
        # Create new meal plan
        dietary_prefs = []
        allergies = []
        fitness_goal = FitnessGoalEnum.recomp
        meals_per_day = 3
        snacks_per_day = 0
        
        if user_profile:
            dietary_prefs = user_profile.dietary_preferences or []
            allergies = user_profile.allergies or []
            fitness_goal = FitnessGoalEnum(user_profile.fitness_goal) if user_profile.fitness_goal else FitnessGoalEnum.recomp
            meals_per_day = user_profile.meals_per_day or 3
            snacks_per_day = user_profile.snacks_per_day or 0
        
        meal_plan_orm = MealPlanORM(
            user_id=user_id,
            dietary_preferences=dietary_prefs,
            allergies=allergies,
            fitness_goal=fitness_goal,
            meals_per_day=meals_per_day,
            snacks_per_day=snacks_per_day,
            cooking_time_weekday=30,
            cooking_time_weekend=60,
            favorite_cuisines=[],
            disliked_ingredients=[],
            plan_duration=PlanDurationEnum.daily
        )
        
        db.add(meal_plan_orm)
        db.flush()
        
        return meal_plan_orm
    
    def _get_or_create_day_plan(
        self, 
        db: Session, 
        meal_plan_id: int, 
        meal_date
    ) -> MealPlanDayORM:
        """
        Get existing day plan or create a new one.
        
        Args:
            db: Database session
            meal_plan_id: Meal plan ID
            meal_date: Date for the day plan
        
        Returns:
            MealPlanDayORM instance
        """
        # Try to find existing day plan
        existing_day = (
            db.query(MealPlanDayORM)
            .filter(
                MealPlanDayORM.meal_plan_id == meal_plan_id,
                MealPlanDayORM.date == meal_date
            )
            .first()
        )
        
        if existing_day:
            return existing_day
        
        # Create new day plan
        day_plan_orm = MealPlanDayORM(
            meal_plan_id=meal_plan_id,
            date=meal_date
        )
        
        db.add(day_plan_orm)
        db.flush()
        
        return day_plan_orm
</file>

<file path="src/app/handlers/query_handlers/get_user_profile_query_handler.py">
"""
GetUserProfileQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.user import GetUserProfileQuery
from src.domain.model.user import ActivityLevel, Sex
from src.domain.model.user import TdeeRequest, UnitSystem, Goal
from src.domain.services.tdee_service import TdeeCalculationService
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)


@handles(GetUserProfileQuery)
class GetUserProfileQueryHandler(EventHandler[GetUserProfileQuery, Dict[str, Any]]):
    """Handler for getting user profile with TDEE calculation."""

    def __init__(self, db: Session = None, tdee_service: TdeeCalculationService = None):
        self.db = db
        self.tdee_service = tdee_service or TdeeCalculationService()

    def set_dependencies(self, db: Session, tdee_service: TdeeCalculationService = None):
        """Set dependencies for dependency injection."""
        self.db = db
        if tdee_service:
            self.tdee_service = tdee_service

    async def handle(self, query: GetUserProfileQuery) -> Dict[str, Any]:
        """Get user profile with calculated TDEE."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get user profile
        profile = self.db.query(UserProfile).filter(
            UserProfile.user_id == query.user_id
        ).first()

        if not profile:
            raise ResourceNotFoundException(f"Profile for user {query.user_id} not found")

            # Map profile data to TDEE request
        sex = Sex.MALE if profile.gender.lower() == "male" else Sex.FEMALE

        activity_map = {
            "sedentary": ActivityLevel.SEDENTARY,
            "light": ActivityLevel.LIGHT,
            "moderate": ActivityLevel.MODERATE,
            "active": ActivityLevel.ACTIVE,
            "extra": ActivityLevel.EXTRA
        }

        goal_map = {
            "cut": Goal.CUT,
            "bulk": Goal.BULK,
            "recomp": Goal.RECOMP
        }

        tdee_request = TdeeRequest(
            age=profile.age,
            sex=sex,
            height=profile.height_cm,
            weight=profile.weight_kg,
            activity_level=activity_map.get(profile.activity_level, ActivityLevel.MODERATE),
            goal=goal_map.get(profile.fitness_goal, Goal.RECOMP),
            body_fat_pct=profile.body_fat_percentage,
            unit_system=UnitSystem.METRIC
        )

        tdee_result = self.tdee_service.calculate_tdee(tdee_request)

        return {
            "profile": {
                "id": profile.id,
                "user_id": profile.user_id,
                "age": profile.age,
                "gender": profile.gender,
                "height_cm": profile.height_cm,
                "weight_kg": profile.weight_kg,
                "body_fat_percentage": profile.body_fat_percentage,
                "activity_level": profile.activity_level,
                "fitness_goal": profile.fitness_goal,
                "target_weight_kg": profile.target_weight_kg,
                "meals_per_day": profile.meals_per_day,
                "snacks_per_day": profile.snacks_per_day,
                "dietary_preferences": profile.dietary_preferences or [],
                "health_conditions": profile.health_conditions or [],
                "allergies": profile.allergies or [],
                "created_at": profile.created_at.isoformat() if profile.created_at else None,
                "updated_at": profile.updated_at.isoformat() if profile.updated_at else None
            },
            "tdee": tdee_result
        }
</file>

<file path="src/app/queries/user/__init__.py">
"""User queries."""
from .get_user_metrics_query import GetUserMetricsQuery
from .get_user_profile_query import GetUserProfileQuery
from .get_user_by_firebase_uid_query import GetUserByFirebaseUidQuery
from .get_user_onboarding_status_query import GetUserOnboardingStatusQuery

__all__ = [
    "GetUserProfileQuery",
    "GetUserMetricsQuery",
    "GetUserByFirebaseUidQuery",
    "GetUserOnboardingStatusQuery",
]
</file>

<file path="src/domain/mappers/activity_goal_mapper.py">
"""
Centralized mapper for activity levels and fitness goals.
Ensures consistent mapping across the entire application.
"""

from typing import Dict

from src.domain.model.user import ActivityLevel, Goal


class ActivityGoalMapper:
    """Centralized mapper for activity levels and fitness goals."""

    # Activity level mappings - all variations map to canonical enum values
    ACTIVITY_LEVEL_MAP: Dict[str, ActivityLevel] = {
        # Canonical values
        "sedentary": ActivityLevel.SEDENTARY,
        "light": ActivityLevel.LIGHT,
        "moderate": ActivityLevel.MODERATE,
        "active": ActivityLevel.ACTIVE,
        "extra": ActivityLevel.EXTRA,
        # Alternative names (with underscore)
        "lightly_active": ActivityLevel.LIGHT,
        "moderately_active": ActivityLevel.MODERATE,
        "very_active": ActivityLevel.ACTIVE,
        "extra_active": ActivityLevel.EXTRA,
    }

    # Goal mappings - canonical values only (mobile migration complete)
    GOAL_MAP: Dict[str, Goal] = {
        "cut": Goal.CUT,
        "bulk": Goal.BULK,
        "recomp": Goal.RECOMP,
    }

    @classmethod
    def map_activity_level(cls, activity_level: str) -> ActivityLevel:
        """Map activity level string to enum, with fallback to MODERATE."""
        return cls.ACTIVITY_LEVEL_MAP.get(
            activity_level.lower(), ActivityLevel.MODERATE
        )

    @classmethod
    def map_goal(cls, goal: str) -> Goal:
        """Map goal string to enum, with fallback to RECOMP."""
        return cls.GOAL_MAP.get(goal.lower(), Goal.RECOMP)
</file>

<file path="src/domain/model/ai/__init__.py">
"""
AI bounded context - Domain models for GPT/AI interactions.
"""
from .gpt_response import GPTMacros, GPTFoodItem, GPTAnalysisResponse
from .gpt_response_errors import (
    GPTResponseError,
    GPTResponseFormatError,
    GPTResponseValidationError,
    GPTResponseParsingError,
    GPTResponseIncompleteError,
)

__all__ = [
    'GPTMacros',
    'GPTFoodItem',
    'GPTAnalysisResponse',
    'GPTResponseError',
    'GPTResponseFormatError',
    'GPTResponseValidationError',
    'GPTResponseParsingError',
    'GPTResponseIncompleteError',
]
</file>

<file path="src/domain/model/ai/gpt_response_errors.py">
"""
Custom exceptions for GPT response parsing.

This module defines specific exception types for different parsing failures,
improving error handling and debugging.
"""
from typing import Optional, Dict, Any


class GPTResponseError(Exception):
    """Base exception for all GPT response parsing errors."""
    
    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.details = details or {}


class GPTResponseFormatError(GPTResponseError):
    """
    Raised when the GPT response format is invalid.
    
    This includes missing required fields, wrong structure, etc.
    """
    pass


class GPTResponseValidationError(GPTResponseError):
    """
    Raised when GPT response values fail validation.
    
    This includes out-of-range values, invalid types, etc.
    """
    pass


class GPTResponseParsingError(GPTResponseError):
    """
    Raised when parsing the GPT response fails.
    
    This includes JSON parsing errors, type conversion errors, etc.
    """
    pass


class GPTResponseIncompleteError(GPTResponseError):
    """
    Raised when the GPT response is incomplete or truncated.
    
    This can happen when the response is cut off due to token limits.
    """
    pass


class GPTResponseConfidenceError(GPTResponseError):
    """
    Raised when the GPT response confidence is too low.
    
    This allows handling of low-confidence responses differently.
    """
    
    def __init__(self, message: str, confidence: float, threshold: float = 0.5):
        super().__init__(message, {
            "confidence": confidence,
            "threshold": threshold
        })
        self.confidence = confidence
        self.threshold = threshold
</file>

<file path="src/domain/model/conversation/__init__.py">
"""
Conversation bounded context - Domain models for conversational interactions.
"""
from .conversation import (
    Conversation,
    Message,
    MessageRole,
    ConversationContext,
    ConversationState
)
from .meal_query_response import MealsForDateResponse
from .prompt_context import PromptContext

__all__ = [
    'Conversation',
    'Message',
    'MessageRole',
    'ConversationContext',
    'ConversationState',
    'PromptContext',
    'MealsForDateResponse',
]
</file>

<file path="src/domain/model/conversation/conversation.py">
import uuid
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict


class ConversationState(str, Enum):
    GREETING = "greeting"
    ASKING_DIETARY_PREFERENCES = "asking_dietary_preferences"
    ASKING_ALLERGIES = "asking_allergies"
    ASKING_FITNESS_GOALS = "asking_fitness_goals"
    ASKING_MEAL_COUNT = "asking_meal_count"
    ASKING_PLAN_DURATION = "asking_plan_duration"
    ASKING_COOKING_TIME = "asking_cooking_time"
    ASKING_CUISINE_PREFERENCES = "asking_cuisine_preferences"
    CONFIRMING_PREFERENCES = "confirming_preferences"
    GENERATING_PLAN = "generating_plan"
    SHOWING_PLAN = "showing_plan"
    ADJUSTING_MEAL = "adjusting_meal"
    COMPLETED = "completed"


class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"


@dataclass
class Message:
    """Represents a single message in the conversation"""
    message_id: str
    role: MessageRole
    content: str
    timestamp: datetime
    metadata: Optional[Dict] = None
    
    def __init__(self, role: MessageRole, content: str, metadata: Optional[Dict] = None):
        self.message_id = str(uuid.uuid4())
        self.role = role
        self.content = content
        self.timestamp = datetime.utcnow()
        self.metadata = metadata or {}
    
    def to_dict(self) -> Dict:
        return {
            "message_id": self.message_id,
            "role": self.role.value,
            "content": self.content,
            "timestamp": self.timestamp.isoformat(),
            "metadata": self.metadata
        }


@dataclass
class ConversationContext:
    """Stores the context of the meal planning conversation"""
    dietary_preferences: Optional[List[str]] = None
    allergies: Optional[List[str]] = None
    fitness_goal: Optional[str] = None
    meals_per_day: Optional[int] = None
    snacks_per_day: Optional[int] = None
    plan_duration: Optional[str] = None
    cooking_time_weekday: Optional[int] = None
    cooking_time_weekend: Optional[int] = None
    favorite_cuisines: Optional[List[str]] = None
    disliked_ingredients: Optional[List[str]] = None
    current_meal_plan: Optional[str] = None  # meal_plan_id
    
    def is_complete(self) -> bool:
        """Check if all required information has been collected"""
        required_fields = [
            self.dietary_preferences is not None,
            self.allergies is not None,
            self.fitness_goal is not None,
            self.meals_per_day is not None,
            self.plan_duration is not None,
            self.cooking_time_weekday is not None,
            self.cooking_time_weekend is not None,
            self.favorite_cuisines is not None,
            self.disliked_ingredients is not None
        ]
        return all(required_fields)
    
    def to_dict(self) -> Dict:
        return {
            "dietary_preferences": self.dietary_preferences,
            "allergies": self.allergies,
            "fitness_goal": self.fitness_goal,
            "meals_per_day": self.meals_per_day,
            "snacks_per_day": self.snacks_per_day,
            "plan_duration": self.plan_duration,
            "cooking_time_weekday": self.cooking_time_weekday,
            "cooking_time_weekend": self.cooking_time_weekend,
            "favorite_cuisines": self.favorite_cuisines,
            "disliked_ingredients": self.disliked_ingredients,
            "current_meal_plan": self.current_meal_plan
        }


@dataclass
class Conversation:
    """Represents a meal planning conversation session"""
    conversation_id: str
    user_id: str
    state: ConversationState
    context: ConversationContext
    messages: List[Message]
    created_at: datetime
    updated_at: datetime
    
    def __init__(self, user_id: str):
        self.conversation_id = str(uuid.uuid4())
        self.user_id = user_id
        self.state = ConversationState.GREETING
        self.context = ConversationContext()
        self.messages = []
        self.created_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
    
    def add_message(self, role: MessageRole, content: str, metadata: Optional[Dict] = None) -> Message:
        message = Message(role, content, metadata)
        self.messages.append(message)
        self.updated_at = datetime.utcnow()
        return message
    
    def update_state(self, new_state: ConversationState):
        self.state = new_state
        self.updated_at = datetime.utcnow()
    
    def get_last_assistant_message(self) -> Optional[Message]:
        for message in reversed(self.messages):
            if message.role == MessageRole.ASSISTANT:
                return message
        return None
    
    def get_conversation_history(self) -> List[Dict]:
        return [msg.to_dict() for msg in self.messages]
    
    def to_dict(self) -> Dict:
        return {
            "conversation_id": self.conversation_id,
            "user_id": self.user_id,
            "state": self.state.value,
            "context": self.context.to_dict(),
            "messages": self.get_conversation_history(),
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
</file>

<file path="src/domain/model/conversation/meal_query_response.py">
"""
Domain models for meal query responses.
"""
from dataclasses import dataclass
from datetime import date
from typing import List, Dict, Any

from ..meal_planning import PlannedMeal


@dataclass
class MealsForDateResponse:
    """Response model for getting meals by date query."""
    
    date: date
    day_formatted: str
    meals: List[PlannedMeal]
    total_meals: int
    user_id: str
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API response."""
        return {
            "date": self.date.isoformat(),
            "day_formatted": self.day_formatted,
            "meals": [meal.to_dict() for meal in self.meals],
            "total_meals": self.total_meals,
            "user_id": self.user_id
        }
    
    @classmethod
    def empty_response(cls, user_id: str, query_date: date) -> 'MealsForDateResponse':
        """Create an empty response for when no meals are found."""
        return cls(
            date=query_date,
            day_formatted=query_date.strftime("%A, %B %d, %Y"),
            meals=[],
            total_meals=0,
            user_id=user_id
        )
</file>

<file path="src/domain/model/meal/__init__.py">
"""
Meal bounded context - Domain models for meals and ingredients.
"""
from .ingredient import Ingredient
from .meal import Meal, MealStatus
from .meal_image import MealImage

__all__ = [
    'Meal',
    'MealStatus',
    'MealImage',
    'Ingredient',
]
</file>

<file path="src/domain/model/meal/ingredient.py">
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from ..nutrition import Macros, Micros


@dataclass
class Ingredient:
    """
    Domain model representing an ingredient that belongs to a food item.
    """
    ingredient_id: str
    food_id: str  # Reference to the parent food
    name: str
    quantity: float
    unit: str
    calories: Optional[float] = None
    macros: Optional[Macros] = None
    micros: Optional[Micros] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.ingredient_id)
            uuid.UUID(self.food_id)
        except ValueError as e:
            raise ValueError(f"Invalid UUID format: {e}")
        
        if self.quantity <= 0:
            raise ValueError(f"Quantity must be positive: {self.quantity}")
            
        if self.calories is not None and self.calories < 0:
            raise ValueError(f"Calories cannot be negative: {self.calories}")
    
    @classmethod
    def create_new(cls, food_id: str, name: str, quantity: float, unit: str, **kwargs) -> 'Ingredient':
        """Factory method to create a new ingredient."""
        return cls(
            ingredient_id=str(uuid.uuid4()),
            food_id=food_id,
            name=name,
            quantity=quantity,
            unit=unit,
            created_at=datetime.now(),
            **kwargs
        )
    
    def update_nutritional_info(self, calories: Optional[float], macros: Optional[Macros], micros: Optional[Micros] = None) -> 'Ingredient':
        """Update the nutritional information of the ingredient."""
        return Ingredient(
            ingredient_id=self.ingredient_id,
            food_id=self.food_id,
            name=self.name,
            quantity=self.quantity,
            unit=self.unit,
            calories=calories,
            macros=macros,
            micros=micros,
            created_at=self.created_at,
            updated_at=datetime.now()
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "ingredient_id": self.ingredient_id,
            "food_id": self.food_id,
            "name": self.name,
            "quantity": self.quantity,
            "unit": self.unit
        }
        
        if self.calories is not None:
            result["calories"] = self.calories
        if self.macros:
            result["macros"] = self.macros.to_dict()
        if self.micros:
            result["micros"] = self.micros.to_dict()
        if self.created_at:
            result["created_at"] = self.created_at.isoformat()
        if self.updated_at:
            result["updated_at"] = self.updated_at.isoformat()
            
        return result
</file>

<file path="src/domain/model/meal/meal_image.py">
import uuid
from dataclasses import dataclass
from typing import Optional


@dataclass(frozen=True)
class MealImage:
    """
    Value object representing a meal image.
    Contains metadata about the image like format, size, and a unique identifier.
    """
    image_id: str  # UUID as string
    format: str  # "jpeg" or "png"
    size_bytes: int
    width: Optional[int] = None
    height: Optional[int] = None
    url: Optional[str] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID format
        try:
            uuid.UUID(self.image_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for image_id: {self.image_id}")
        
        # Validate format
        if self.format.lower() not in ["jpeg", "png"]:
            raise ValueError(f"Image format must be 'jpeg' or 'png', got: {self.format}")
        
        # Validate size
        if self.size_bytes <= 0:
            raise ValueError(f"Size must be positive: {self.size_bytes}")
        
        # Max size check (8MB)
        max_size = 8 * 1024 * 1024  # 8MB in bytes
        if self.size_bytes > max_size:
            raise ValueError(f"Image size exceeds maximum allowed (8MB): {self.size_bytes} bytes")
        
        # Validate dimensions if provided
        if self.width is not None and self.width <= 0:
            raise ValueError(f"Width must be positive: {self.width}")
        
        if self.height is not None and self.height <= 0:
            raise ValueError(f"Height must be positive: {self.height}")
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "image_id": self.image_id,
            "format": self.format,
            "size_bytes": self.size_bytes,
        }
        
        if self.width is not None:
            result["width"] = self.width
            
        if self.height is not None:
            result["height"] = self.height
            
        if self.url is not None:
            result["url"] = self.url
            
        return result
</file>

<file path="src/domain/model/meal/meal.py">
import uuid
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional

from .meal_image import MealImage
from ..nutrition import Nutrition


class MealStatus(Enum):
    """Status of a meal in the analysis pipeline."""
    PROCESSING = "PROCESSING"  # Initial state, waiting for analysis
    ANALYZING = "ANALYZING"    # AI analysis in progress
    ENRICHING = "ENRICHING"    # Enrichment with food database in progress
    READY = "READY"            # Final state, analysis complete
    FAILED = "FAILED"          # Analysis failed
    INACTIVE = "INACTIVE"      # Soft-deleted by user; ignored in UI/macros
    
    def __str__(self):
        return self.value

@dataclass
class Meal:
    """
    Aggregate root representing a meal with its image and nutritional information.
    This is the main entity in the domain.
    """
    meal_id: str  # UUID as string
    user_id: str  # UUID as string - identifies the user who owns this meal
    status: MealStatus
    created_at: datetime
    image: MealImage
    dish_name: Optional[str] = None
    nutrition: Optional[Nutrition] = None
    ready_at: Optional[datetime] = None
    error_message: Optional[str] = None
    raw_gpt_json: Optional[str] = None
    # Edit tracking fields
    updated_at: Optional[datetime] = None
    last_edited_at: Optional[datetime] = None
    edit_count: int = 0
    is_manually_edited: bool = False
    meal_type: Optional[str] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.meal_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for meal_id: {self.meal_id}")
        
        try:
            uuid.UUID(self.user_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
        
        # Status-based validations
        if self.status == MealStatus.READY and self.nutrition is None:
            raise ValueError("Meal with READY status must have nutrition data")
            
        if self.status == MealStatus.READY and self.ready_at is None:
            raise ValueError("Meal with READY status must have ready_at timestamp")
            
        if self.status == MealStatus.FAILED and self.error_message is None:
            raise ValueError("Meal with FAILED status must have error_message")
        # INACTIVE has no additional constraints
    
    @classmethod
    def create_new_processing(cls, user_id: str, image: MealImage) -> 'Meal':
        """Factory method to create a new meal in PROCESSING status."""
        return cls(
            meal_id=str(uuid.uuid4()),
            user_id=user_id,
            status=MealStatus.PROCESSING,
            created_at=datetime.now(),
            image=image
        )
    
    def mark_analyzing(self) -> 'Meal':
        """Transition to ANALYZING state."""
        return Meal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatus.ANALYZING,
            created_at=self.created_at,
            image=self.image,
            dish_name=self.dish_name,
            nutrition=self.nutrition,
            ready_at=self.ready_at,
            error_message=self.error_message,
            raw_gpt_json=self.raw_gpt_json,
            updated_at=self.updated_at,
            last_edited_at=self.last_edited_at,
            edit_count=self.edit_count,
            is_manually_edited=self.is_manually_edited,
            meal_type=self.meal_type
        )
    
    def mark_enriching(self, raw_gpt_json: str) -> 'Meal':
        """Transition to ENRICHING state with GPT response."""
        return Meal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatus.ENRICHING,
            created_at=self.created_at,
            image=self.image,
            dish_name=self.dish_name,
            nutrition=self.nutrition,
            ready_at=self.ready_at,
            error_message=self.error_message,
            raw_gpt_json=raw_gpt_json,
            updated_at=self.updated_at,
            last_edited_at=self.last_edited_at,
            edit_count=self.edit_count,
            is_manually_edited=self.is_manually_edited,
            meal_type=self.meal_type
        )
    
    def mark_ready(self, nutrition: Nutrition, dish_name: str) -> 'Meal':
        """Transition to READY state with final nutrition data."""
        return Meal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatus.READY,
            created_at=self.created_at,
            image=self.image,
            dish_name=dish_name,
            nutrition=nutrition,
            ready_at=datetime.now(),
            error_message=self.error_message,
            raw_gpt_json=self.raw_gpt_json,
            updated_at=self.updated_at,
            last_edited_at=self.last_edited_at,
            edit_count=self.edit_count,
            is_manually_edited=self.is_manually_edited,
            meal_type=self.meal_type
        )
    
    def mark_failed(self, error_message: str) -> 'Meal':
        """Transition to FAILED state with error message."""
        return Meal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatus.FAILED,
            created_at=self.created_at,
            image=self.image,
            dish_name=self.dish_name,
            nutrition=self.nutrition,
            ready_at=self.ready_at,
            error_message=error_message,
            raw_gpt_json=self.raw_gpt_json,
            updated_at=self.updated_at,
            last_edited_at=self.last_edited_at,
            edit_count=self.edit_count,
            is_manually_edited=self.is_manually_edited,
            meal_type=self.meal_type
        )
    
    def mark_edited(self, nutrition: Nutrition, dish_name: str) -> 'Meal':
        """Mark meal as edited with updated nutrition."""
        return Meal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatus.READY,
            created_at=self.created_at,
            image=self.image,
            dish_name=dish_name,
            nutrition=nutrition,
            ready_at=self.ready_at,
            error_message=self.error_message,
            raw_gpt_json=self.raw_gpt_json,
            updated_at=datetime.now(),
            last_edited_at=datetime.now(),
            edit_count=self.edit_count + 1,
            is_manually_edited=True,
            meal_type=self.meal_type
        )

    def mark_inactive(self) -> 'Meal':
        """Mark meal as INACTIVE (soft delete)."""
        return Meal(
            meal_id=self.meal_id,
            user_id=self.user_id,
            status=MealStatus.INACTIVE,
            created_at=self.created_at,
            image=self.image,
            dish_name=self.dish_name,
            nutrition=self.nutrition,
            ready_at=self.ready_at,
            error_message=self.error_message,
            raw_gpt_json=self.raw_gpt_json,
            updated_at=datetime.now(),
            last_edited_at=self.last_edited_at,
            edit_count=self.edit_count,
            is_manually_edited=self.is_manually_edited,
            meal_type=self.meal_type
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "meal_id": self.meal_id,
            "user_id": self.user_id,
            "status": str(self.status),
            "created_at": self.created_at.isoformat(),
            "image": self.image.to_dict()
        }
        
        if self.dish_name is not None:
            result["dish_name"] = self.dish_name
            
        if self.nutrition is not None:
            result["nutrition"] = self.nutrition.to_dict()
            
        if self.ready_at is not None:
            result["ready_at"] = self.ready_at.isoformat()
            
        if self.error_message is not None:
            result["error_message"] = self.error_message
        
        return result
</file>

<file path="src/domain/model/meal_planning/macro_targets.py">
from pydantic import BaseModel, Field


class SimpleMacroTargets(BaseModel):
    """
    Simplified macro targets class for frontend use.
    Contains only the essential macronutrients: protein, carbs, and fat.
    """
    protein: float = Field(..., description="Protein target in grams", ge=0)
    carbs: float = Field(..., description="Carbohydrates target in grams", ge=0)
    fat: float = Field(..., description="Fat target in grams", ge=0)
    
    class Config:
        json_schema_extra = {
            "example": {
                "protein": 150.0,
                "carbs": 200.0,
                "fat": 65.0
            }
        }
    
    @property
    def total_calories(self) -> float:
        """Calculate total calories from macros"""
        return (self.protein * 4) + (self.carbs * 4) + (self.fat * 9)
    
    def to_dict(self) -> dict:
        """Convert to dictionary for easy JSON serialization"""
        return {
            "protein": self.protein,
            "carbs": self.carbs,
            "fat": self.fat
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> "MacroTargets":
        """Create MacroTargets from dictionary"""
        return cls(
            protein=data.get("protein", 0),
            carbs=data.get("carbs", 0),
            fat=data.get("fat", 0)
        )
</file>

<file path="src/domain/model/notification/__init__.py">
"""
Notification domain models.

This package contains all notification-related domain models, split into separate
files for better maintainability and single responsibility principle.
"""
from .enums import DeviceType, NotificationType
from .notification_preferences import NotificationPreferences
from .push_notification import PushNotification
from .user_fcm_token import UserFcmToken

__all__ = [
    'DeviceType',
    'NotificationType',
    'UserFcmToken',
    'NotificationPreferences',
    'PushNotification',
]
</file>

<file path="src/domain/model/notification/enums.py">
"""
Notification-related enums.
"""
from enum import Enum


class DeviceType(Enum):
    """Device types for FCM tokens."""
    IOS = "ios"
    ANDROID = "android"
    
    def __str__(self):
        return self.value


class NotificationType(Enum):
    """Types of notifications that can be sent."""
    MEAL_REMINDER_BREAKFAST = "meal_reminder_breakfast"
    MEAL_REMINDER_LUNCH = "meal_reminder_lunch"
    MEAL_REMINDER_DINNER = "meal_reminder_dinner"
    WATER_REMINDER = "water_reminder"
    SLEEP_REMINDER = "sleep_reminder"
    PROGRESS_NOTIFICATION = "progress_notification"
    REENGAGEMENT_NOTIFICATION = "reengagement_notification"
    
    def __str__(self):
        return self.value
</file>

<file path="src/domain/model/notification/push_notification.py">
"""
Push notification domain model.
"""
import uuid
from dataclasses import dataclass
from typing import Optional

from .enums import NotificationType


@dataclass
class PushNotification:
    """
    Domain model representing a push notification to be sent.
    """
    user_id: str  # UUID as string
    title: str
    body: str
    notification_type: NotificationType
    data: Optional[dict] = None
    
    def __post_init__(self):
        """Validate invariants."""
        try:
            uuid.UUID(self.user_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
        
        if not self.title or not self.body:
            raise ValueError("Title and body must be non-empty strings")
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        return {
            "user_id": self.user_id,
            "title": self.title,
            "body": self.body,
            "notification_type": str(self.notification_type),
            "data": self.data or {},
        }
</file>

<file path="src/domain/model/notification/user_fcm_token.py">
"""
User FCM token domain model.
"""
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from .enums import DeviceType


@dataclass
class UserFcmToken:
    """
    Domain model representing a user's FCM token for push notifications.
    """
    token_id: str  # UUID as string
    user_id: str  # UUID as string
    fcm_token: str
    device_type: DeviceType
    is_active: bool = True
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.token_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for token_id: {self.token_id}")
        
        try:
            uuid.UUID(self.user_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
        
        # Validate FCM token format (basic check)
        if not self.fcm_token or len(self.fcm_token) < 10:
            raise ValueError("FCM token must be a valid non-empty string")
    
    @classmethod
    def create_new(cls, user_id: str, fcm_token: str, device_type: DeviceType) -> 'UserFcmToken':
        """Factory method to create a new FCM token."""
        return cls(
            token_id=str(uuid.uuid4()),
            user_id=user_id,
            fcm_token=fcm_token,
            device_type=device_type,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
    
    def deactivate(self) -> 'UserFcmToken':
        """Deactivate the token."""
        return UserFcmToken(
            token_id=self.token_id,
            user_id=self.user_id,
            fcm_token=self.fcm_token,
            device_type=self.device_type,
            is_active=False,
            created_at=self.created_at,
            updated_at=datetime.now()
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        return {
            "token_id": self.token_id,
            "user_id": self.user_id,
            "fcm_token": self.fcm_token,
            "device_type": str(self.device_type),
            "is_active": self.is_active,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
</file>

<file path="src/domain/model/nutrition/__init__.py">
"""
Nutrition bounded context - Domain models for nutritional information.
"""
from .food import Food
from .macros import Macros
from .micros import Micros
from .nutrition import Nutrition, FoodItem

__all__ = [
    'Nutrition',
    'FoodItem',
    'Macros',
    'Micros',
    'Food',
]
</file>

<file path="src/domain/model/nutrition/food.py">
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from .macros import Macros


@dataclass
class Food:
    """
    Domain model representing a food item in the database.
    """
    food_id: str
    name: str
    brand: Optional[str] = None
    description: Optional[str] = None
    serving_size: Optional[float] = None
    serving_unit: Optional[str] = None
    calories_per_serving: Optional[float] = None
    macros_per_serving: Optional[Macros] = None
    barcode: Optional[str] = None
    image_url: Optional[str] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    is_verified: bool = False
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID format
        try:
            uuid.UUID(self.food_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for food_id: {self.food_id}")
        
        if self.serving_size is not None and self.serving_size <= 0:
            raise ValueError(f"Serving size must be positive: {self.serving_size}")
            
        if self.calories_per_serving is not None and self.calories_per_serving < 0:
            raise ValueError(f"Calories cannot be negative: {self.calories_per_serving}")
    
    @classmethod
    def create_new(cls, name: str, **kwargs) -> 'Food':
        """Factory method to create a new food item."""
        return cls(
            food_id=str(uuid.uuid4()),
            name=name,
            created_at=datetime.now(),
            **kwargs
        )
    
    def update_nutritional_info(self, calories: float, macros: Macros) -> 'Food':
        """Update the nutritional information of the food."""
        return Food(
            food_id=self.food_id,
            name=self.name,
            brand=self.brand,
            description=self.description,
            serving_size=self.serving_size,
            serving_unit=self.serving_unit,
            calories_per_serving=calories,
            macros_per_serving=macros,
            barcode=self.barcode,
            image_url=self.image_url,
            created_at=self.created_at,
            updated_at=datetime.now(),
            is_verified=self.is_verified
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "food_id": self.food_id,
            "name": self.name,
            "is_verified": self.is_verified
        }
        
        if self.brand:
            result["brand"] = self.brand
        if self.description:
            result["description"] = self.description
        if self.serving_size:
            result["serving_size"] = self.serving_size
        if self.serving_unit:
            result["serving_unit"] = self.serving_unit
        if self.calories_per_serving:
            result["calories_per_serving"] = self.calories_per_serving
        if self.macros_per_serving:
            result["macros_per_serving"] = self.macros_per_serving.to_dict()
        if self.barcode:
            result["barcode"] = self.barcode
        if self.image_url:
            result["image_url"] = self.image_url
        if self.created_at:
            result["created_at"] = self.created_at.isoformat()
        if self.updated_at:
            result["updated_at"] = self.updated_at.isoformat()
            
        return result
</file>

<file path="src/domain/model/nutrition/macros.py">
from dataclasses import dataclass


@dataclass
class Macros:
    """
    Value object representing macronutrient breakdown of a meal.
    All values are in grams.
    """
    protein: float
    carbs: float
    fat: float
    
    def __post_init__(self):
        # Validate invariants
        for field_name in ['protein', 'carbs', 'fat']:
            value = getattr(self, field_name)
            if value < 0:
                raise ValueError(f"{field_name} cannot be negative: {value}")
    
    @property
    def total_calories(self) -> float:
        """Calculate total calories based on macronutrients."""
        # Standard caloric values: 4 cal/g for protein and carbs, 9 cal/g for fat
        return round(self.protein * 4 + self.carbs * 4 + self.fat * 9, 1)
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "protein_g": self.protein,
            "carbs_g": self.carbs,
            "fat_g": self.fat,
        }
        return result
</file>

<file path="src/domain/model/nutrition/micros.py">
from dataclasses import dataclass
from typing import Dict, Optional

@dataclass(frozen=True)
class Micros:
    """
    Value object representing micronutrients in a meal.
    Flexible structure allowing various vitamins and minerals.
    """
    # Common vitamins (in mg or μg)
    vitamin_a: Optional[float] = None
    vitamin_c: Optional[float] = None
    vitamin_d: Optional[float] = None
    vitamin_e: Optional[float] = None
    vitamin_k: Optional[float] = None
    thiamin: Optional[float] = None
    riboflavin: Optional[float] = None
    niacin: Optional[float] = None
    vitamin_b6: Optional[float] = None
    vitamin_b12: Optional[float] = None
    folate: Optional[float] = None
    
    # Common minerals (in mg)
    calcium: Optional[float] = None
    iron: Optional[float] = None
    magnesium: Optional[float] = None
    phosphorus: Optional[float] = None
    potassium: Optional[float] = None
    sodium: Optional[float] = None
    zinc: Optional[float] = None
    selenium: Optional[float] = None
    
    def __post_init__(self):
        """Validate all micronutrients are non-negative."""
        for field_name, value in self.__dict__.items():
            if value is not None and value < 0:
                raise ValueError(f"{field_name} cannot be negative: {value}")
    
    def to_dict(self) -> Dict[str, float]:
        """Convert to dictionary, excluding None values."""
        return {k: v for k, v in self.__dict__.items() if v is not None}
    
    @classmethod
    def from_dict(cls, data: Dict[str, float]) -> 'Micros':
        """Create a Micros instance from a dictionary."""
        # Filter out any keys that are not fields in the dataclass
        valid_fields = {f.name for f in cls.__dataclass_fields__.values()}
        filtered_data = {k: v for k, v in data.items() if k in valid_fields}
        return cls(**filtered_data)
</file>

<file path="src/domain/model/nutrition/nutrition.py">
from dataclasses import dataclass
from typing import Dict, List, Optional

from .macros import Macros
from .micros import Micros


@dataclass
class FoodItem:
    """Represents a single food item in a meal with nutritional information."""
    id: str
    name: str
    quantity: float
    unit: str
    calories: float
    macros: Macros
    micros: Optional[Micros] = None
    confidence: float = 1.0  # 0.0-1.0 confidence score from AI or lookup
    fdc_id: Optional[int] = None  # USDA FDC ID if available
    is_custom: bool = False  # Whether this is a custom ingredient

    def __post_init__(self):
        """Validate invariants."""
        if not self.name or not self.name.strip():
            raise ValueError("Food item name cannot be empty")
        if len(self.name) > 200:
            raise ValueError(f"Food item name too long (max 200 chars): {len(self.name)}")
        if self.quantity <= 0 or self.quantity > 10000:
            raise ValueError(f"Quantity must be between 0 and 10000: {self.quantity}")
        if self.calories < 0:
            raise ValueError(f"Calories cannot be negative: {self.calories}")
        if not 0 <= self.confidence <= 1:
            raise ValueError(f"Confidence must be between 0 and 1: {self.confidence}")
        if not self.unit or not self.unit.strip():
            raise ValueError("Unit cannot be empty")
        if len(self.unit) > 50:
            raise ValueError(f"Unit too long (max 50 chars): {len(self.unit)}")

    def to_dict(self) -> Dict:
        """Convert to dictionary format."""
        result = {
            "id": self.id,
            "name": self.name,
            "quantity": self.quantity,
            "unit": self.unit,
            "calories": self.calories,
            "macros": self.macros.to_dict(),
            "confidence": self.confidence,
            "is_custom": self.is_custom
        }
        if self.micros:
            result["micros"] = self.micros.to_dict()
        if self.fdc_id:
            result["fdc_id"] = self.fdc_id
        return result

@dataclass
class Nutrition:
    """Value object representing full nutritional information for a meal."""
    calories: float
    macros: Macros
    micros: Optional[Micros] = None
    food_items: Optional[List[FoodItem]] = None
    confidence_score: float = 1.0  # 0.0-1.0 overall confidence score

    def __post_init__(self):
        """Validate invariants."""
        if self.calories < 0:
            raise ValueError(f"Calories cannot be negative: {self.calories}")
        if not 0 <= self.confidence_score <= 1:
            raise ValueError(f"Confidence score must be between 0 and 1: {self.confidence_score}")

        # Validate food items
        if self.food_items:
            if len(self.food_items) > 50:
                raise ValueError(f"Too many ingredients (max 50): {len(self.food_items)}")

            # Check for duplicate ingredient names (case-insensitive)
            names_lower = [item.name.lower().strip() for item in self.food_items]
            if len(names_lower) != len(set(names_lower)):
                raise ValueError("Duplicate ingredients are not allowed")
    
    def to_dict(self) -> Dict:
        """Convert to dictionary format."""
        result = {
            "calories": self.calories,
            "macros": self.macros.to_dict(),
            "confidence_score": self.confidence_score
        }
        
        if self.micros:
            result["micros"] = self.micros.to_dict()
            
        if self.food_items:
            result["food_items"] = [item.to_dict() for item in self.food_items]
            
        return result
</file>

<file path="src/domain/model/user/__init__.py">
"""
User bounded context - Domain models for user-related data.
"""
from .activity import Activity, ActivityType
from .onboarding import (
    OnboardingSection,
    OnboardingField,
    OnboardingResponse,
    OnboardingSectionType,
    FieldType
)
from .tdee import (
    TdeeRequest,
    TdeeResponse,
    MacroTargets,
    Sex,
    ActivityLevel,
    Goal,
    UnitSystem
)
from .user_macros import UserMacros

__all__ = [
    'Activity',
    'ActivityType',
    'UserMacros',
    'OnboardingSection',
    'OnboardingField',
    'OnboardingResponse',
    'OnboardingSectionType',
    'FieldType',
    'TdeeRequest',
    'TdeeResponse',
    'MacroTargets',
    'Sex',
    'ActivityLevel',
    'Goal',
    'UnitSystem',
]
</file>

<file path="src/domain/model/user/activity.py">
import uuid
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Optional, Dict, Any


class ActivityType(Enum):
    """Types of activities that can be tracked."""
    MEAL_SCAN = "MEAL_SCAN"
    MANUAL_FOOD_ADD = "MANUAL_FOOD_ADD"
    FOOD_UPDATE = "FOOD_UPDATE"
    INGREDIENT_ADD = "INGREDIENT_ADD"
    MACRO_CALCULATION = "MACRO_CALCULATION"

@dataclass
class Activity:
    """
    Domain model representing a user activity in the meal tracking system.
    """
    activity_id: str
    user_id: Optional[str]  # For when user system is implemented
    activity_type: ActivityType
    title: str
    description: Optional[str] = None
    metadata: Optional[Dict[str, Any]] = None  # Store activity-specific data
    created_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID format
        try:
            uuid.UUID(self.activity_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for activity_id: {self.activity_id}")
        
        if self.user_id:
            try:
                uuid.UUID(self.user_id)
            except ValueError:
                raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
    
    @classmethod
    def create_new(cls, activity_type: ActivityType, title: str, **kwargs) -> 'Activity':
        """Factory method to create a new activity."""
        return cls(
            activity_id=str(uuid.uuid4()),
            activity_type=activity_type,
            title=title,
            created_at=datetime.now(),
            **kwargs
        )
    
    @classmethod
    def create_meal_scan_activity(cls, meal_id: str, food_names: list) -> 'Activity':
        """Create an activity for meal scanning."""
        return cls.create_new(
            activity_type=ActivityType.MEAL_SCAN,
            title=f"Scanned meal with {len(food_names)} items",
            description=f"Identified: {', '.join(food_names)}",
            metadata={
                "meal_id": meal_id,
                "food_names": food_names,
                "food_count": len(food_names)
            }
        )
    
    @classmethod
    def create_manual_food_activity(cls, food_id: str, food_name: str) -> 'Activity':
        """Create an activity for manual food addition."""
        return cls.create_new(
            activity_type=ActivityType.MANUAL_FOOD_ADD,
            title=f"Added {food_name} manually",
            description=f"Manually added food item: {food_name}",
            metadata={
                "food_id": food_id,
                "food_name": food_name
            }
        )
    
    @classmethod
    def create_food_update_activity(cls, food_id: str, food_name: str, updated_fields: list) -> 'Activity':
        """Create an activity for food updates."""
        return cls.create_new(
            activity_type=ActivityType.FOOD_UPDATE,
            title=f"Updated {food_name}",
            description=f"Updated fields: {', '.join(updated_fields)}",
            metadata={
                "food_id": food_id,
                "food_name": food_name,
                "updated_fields": updated_fields
            }
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "activity_id": self.activity_id,
            "activity_type": self.activity_type.value,
            "title": self.title,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }
        
        if self.user_id:
            result["user_id"] = self.user_id
        if self.description:
            result["description"] = self.description
        if self.metadata:
            result["metadata"] = self.metadata
            
        return result
</file>

<file path="src/domain/model/user/onboarding.py">
import uuid
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import List, Optional, Dict, Any, Union


class OnboardingSectionType(Enum):
    """Types of onboarding sections."""
    PERSONAL_INFO = "PERSONAL_INFO"
    FITNESS_GOALS = "FITNESS_GOALS"
    DIETARY_PREFERENCES = "DIETARY_PREFERENCES"
    ACTIVITY_LEVEL = "ACTIVITY_LEVEL"
    HEALTH_CONDITIONS = "HEALTH_CONDITIONS"

class FieldType(Enum):
    """Types of form fields."""
    TEXT = "TEXT"
    NUMBER = "NUMBER"
    EMAIL = "EMAIL"
    SELECT = "SELECT"
    MULTI_SELECT = "MULTI_SELECT"
    RADIO = "RADIO"
    CHECKBOX = "CHECKBOX"
    DATE = "DATE"
    SLIDER = "SLIDER"

@dataclass
class OnboardingField:
    """Represents a field in an onboarding section."""
    field_id: str
    label: str
    field_type: FieldType
    required: bool = True
    placeholder: Optional[str] = None
    help_text: Optional[str] = None
    options: Optional[List[Dict[str, Any]]] = None  # For select/radio fields
    validation: Optional[Dict[str, Any]] = None  # Validation rules
    default_value: Optional[Union[str, int, float, bool]] = None
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "field_id": self.field_id,
            "label": self.label,
            "field_type": self.field_type.value,
            "required": self.required
        }
        
        if self.placeholder:
            result["placeholder"] = self.placeholder
        if self.help_text:
            result["help_text"] = self.help_text
        if self.options:
            result["options"] = self.options
        if self.validation:
            result["validation"] = self.validation
        if self.default_value is not None:
            result["default_value"] = self.default_value
            
        return result

@dataclass
class OnboardingSection:
    """
    Domain model representing an onboarding section with its fields.
    """
    section_id: str
    title: str
    description: str
    section_type: OnboardingSectionType
    order: int
    fields: List[OnboardingField]
    is_active: bool = True
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID format
        try:
            uuid.UUID(self.section_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for section_id: {self.section_id}")
        
        if self.order < 0:
            raise ValueError(f"Order must be non-negative: {self.order}")
            
        if not self.fields:
            raise ValueError("Section must have at least one field")
    
    @classmethod
    def create_new(cls, title: str, description: str, section_type: OnboardingSectionType, order: int, fields: List[OnboardingField]) -> 'OnboardingSection':
        """Factory method to create a new onboarding section."""
        return cls(
            section_id=str(uuid.uuid4()),
            title=title,
            description=description,
            section_type=section_type,
            order=order,
            fields=fields,
            created_at=datetime.now()
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "section_id": self.section_id,
            "title": self.title,
            "description": self.description,
            "section_type": self.section_type.value,
            "order": self.order,
            "fields": [field.to_dict() for field in self.fields],
            "is_active": self.is_active
        }
        
        if self.created_at:
            result["created_at"] = self.created_at.isoformat()
        if self.updated_at:
            result["updated_at"] = self.updated_at.isoformat()
            
        return result

@dataclass
class OnboardingResponse:
    """
    Domain model representing a user's response to onboarding.
    """
    response_id: str
    user_id: Optional[str]  # For when user system is implemented
    section_id: str
    field_responses: Dict[str, Any]  # field_id -> value mapping
    completed_at: Optional[datetime] = None
    created_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.response_id)
            uuid.UUID(self.section_id)
        except ValueError as e:
            raise ValueError(f"Invalid UUID format: {e}")
        
        if self.user_id:
            try:
                uuid.UUID(self.user_id)
            except ValueError:
                raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
    
    @classmethod
    def create_new(cls, section_id: str, field_responses: Dict[str, Any], user_id: Optional[str] = None) -> 'OnboardingResponse':
        """Factory method to create a new onboarding response."""
        return cls(
            response_id=str(uuid.uuid4()),
            user_id=user_id,
            section_id=section_id,
            field_responses=field_responses,
            completed_at=datetime.now(),
            created_at=datetime.now()
        )
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "response_id": self.response_id,
            "section_id": self.section_id,
            "field_responses": self.field_responses
        }
        
        if self.user_id:
            result["user_id"] = self.user_id
        if self.completed_at:
            result["completed_at"] = self.completed_at.isoformat()
        if self.created_at:
            result["created_at"] = self.created_at.isoformat()
            
        return result
</file>

<file path="src/domain/model/user/user_macros.py">
import uuid
from dataclasses import dataclass
from datetime import datetime, date
from typing import Optional, Dict, Any

from ..nutrition import Macros


@dataclass
class UserMacros:
    """
    Domain model representing daily macro targets and consumption for a user.
    """
    user_macros_id: str
    user_id: Optional[str]  # For when user system is implemented
    target_date: date
    target_calories: float
    target_macros: Macros
    consumed_calories: float = 0.0
    consumed_macros: Optional[Macros] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    onboard_data: Optional[Dict[str, Any]] = None  # Store onboarding choices
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID format
        try:
            uuid.UUID(self.user_macros_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for user_macros_id: {self.user_macros_id}")
        
        if self.user_id:
            try:
                uuid.UUID(self.user_id)
            except ValueError:
                raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
        
        if self.target_calories <= 0:
            raise ValueError(f"Target calories must be positive: {self.target_calories}")
            
        if self.consumed_calories < 0:
            raise ValueError(f"Consumed calories cannot be negative: {self.consumed_calories}")
        
        # Initialize consumed macros if not provided
        if self.consumed_macros is None:
            object.__setattr__(self, 'consumed_macros', Macros(protein=0.0, carbs=0.0, fat=0.0))
    
    @classmethod
    def create_new(cls, target_date: date, target_calories: float, target_macros: Macros, **kwargs) -> 'UserMacros':
        """Factory method to create new user macros."""
        return cls(
            user_macros_id=str(uuid.uuid4()),
            target_date=target_date,
            target_calories=target_calories,
            target_macros=target_macros,
            created_at=datetime.now(),
            **kwargs
        )
    
    @classmethod
    def create_from_onboarding(cls, target_date: date, target_calories: float, target_macros: Macros, onboard_data: Dict[str, Any]) -> 'UserMacros':
        """Create user macros from onboarding data."""
        return cls.create_new(
            target_date=target_date,
            target_calories=target_calories,
            target_macros=target_macros,
            onboard_data=onboard_data
        )
    
    def add_consumed_nutrition(self, calories: float, macros: Macros) -> 'UserMacros':
        """Add consumed nutrition to daily totals."""
        new_consumed_calories = self.consumed_calories + calories
        new_consumed_macros = Macros(
            protein=self.consumed_macros.protein + macros.protein,
            carbs=self.consumed_macros.carbs + macros.carbs,
            fat=self.consumed_macros.fat + macros.fat,
        )
        
        return UserMacros(
            user_macros_id=self.user_macros_id,
            user_id=self.user_id,
            target_date=self.target_date,
            target_calories=self.target_calories,
            target_macros=self.target_macros,
            consumed_calories=new_consumed_calories,
            consumed_macros=new_consumed_macros,
            created_at=self.created_at,
            updated_at=datetime.now(),
            onboard_data=self.onboard_data
        )
    
    @property
    def remaining_calories(self) -> float:
        """Calculate remaining calories for the day."""
        return max(0, self.target_calories - self.consumed_calories)
    
    @property
    def remaining_macros(self) -> Macros:
        """Calculate remaining macros for the day."""
        return Macros(
            protein=max(0, self.target_macros.protein - self.consumed_macros.protein),
            carbs=max(0, self.target_macros.carbs - self.consumed_macros.carbs),
            fat=max(0, self.target_macros.fat - self.consumed_macros.fat),
        )
    
    @property
    def completion_percentage(self) -> Dict[str, float]:
        """Calculate completion percentage for calories and macros."""
        return {
            "calories": min(100.0, (self.consumed_calories / self.target_calories) * 100),
            "protein": min(100.0, (self.consumed_macros.protein / self.target_macros.protein) * 100),
            "carbs": min(100.0, (self.consumed_macros.carbs / self.target_macros.carbs) * 100),
            "fat": min(100.0, (self.consumed_macros.fat / self.target_macros.fat) * 100)
        }
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        result = {
            "user_macros_id": self.user_macros_id,
            "target_date": self.target_date.isoformat(),
            "target_calories": self.target_calories,
            "target_macros": self.target_macros.to_dict(),
            "consumed_calories": self.consumed_calories,
            "consumed_macros": self.consumed_macros.to_dict(),
            "remaining_calories": self.remaining_calories,
            "remaining_macros": self.remaining_macros.to_dict(),
            "completion_percentage": self.completion_percentage
        }
        
        if self.user_id:
            result["user_id"] = self.user_id
        if self.created_at:
            result["created_at"] = self.created_at.isoformat()
        if self.updated_at:
            result["updated_at"] = self.updated_at.isoformat()
        if self.onboard_data:
            result["onboard_data"] = self.onboard_data
            
        return result
</file>

<file path="src/domain/model/__init__.py">
"""
Domain models organized by bounded context.

This module re-exports all domain models from their bounded contexts for convenience.
"""
# AI context
from .ai import (
    GPTMacros,
    GPTFoodItem,
    GPTAnalysisResponse,
    GPTResponseError,
    GPTResponseFormatError,
    GPTResponseValidationError,
    GPTResponseParsingError,
    GPTResponseIncompleteError,
)
# Chat context
from .chat import (
    Thread,
    MessageRole as ChatMessageRole,
    ThreadStatus,
)
# Conversation context
from .conversation import (
    Conversation,
    Message,
    MessageRole,
    ConversationContext,
    ConversationState,
    PromptContext,
    MealsForDateResponse,
)
# Meal context
from .meal import Meal, MealStatus, MealImage, Ingredient
# Meal Planning context
from .meal_planning import (
    MealPlan,
    PlannedMeal,
    DayPlan,
    UserPreferences,
    DietaryPreference,
    FitnessGoal,
    MealType,
    PlanDuration,
    SimpleMacroTargets,
    MealGenerationRequest,
    MealGenerationType,
    MealGenerationContext,
    UserDietaryProfile,
    UserNutritionTargets,
    IngredientConstraints,
    CalorieDistribution,
    DailyMealPlan,
    GeneratedMeal,
    NutritionSummary,
)
# Notification context
from .notification import (
    UserFcmToken,
    NotificationPreferences,
    PushNotification,
    DeviceType,
    NotificationType,
)
# Nutrition context
from .nutrition import Nutrition, FoodItem, Macros, Micros, Food
# User context
from .user import (
    Activity,
    ActivityType,
    UserMacros,
    OnboardingSection,
    OnboardingField,
    OnboardingResponse,
    OnboardingSectionType,
    FieldType,
    TdeeRequest,
    TdeeResponse,
    MacroTargets,
    Sex,
    ActivityLevel,
    Goal,
    UnitSystem,
)

__all__ = [
    # Meal
    'Meal',
    'MealStatus',
    'MealImage',
    'Ingredient',
    # Nutrition
    'Nutrition',
    'FoodItem',
    'Macros',
    'Micros',
    'Food',
    # User
    'Activity',
    'ActivityType',
    'UserMacros',
    'OnboardingSection',
    'OnboardingField',
    'OnboardingResponse',
    'OnboardingSectionType',
    'FieldType',
    'TdeeRequest',
    'TdeeResponse',
    'MacroTargets',
    'Sex',
    'ActivityLevel',
    'Goal',
    'UnitSystem',
    # Meal Planning
    'MealPlan',
    'PlannedMeal',
    'DayPlan',
    'UserPreferences',
    'DietaryPreference',
    'FitnessGoal',
    'MealType',
    'PlanDuration',
    'SimpleMacroTargets',
    'MealGenerationRequest',
    'MealGenerationType',
    'MealGenerationContext',
    'UserDietaryProfile',
    'UserNutritionTargets',
    'IngredientConstraints',
    'CalorieDistribution',
    'DailyMealPlan',
    'GeneratedMeal',
    'NutritionSummary',
    # Conversation
    'Conversation',
    'Message',
    'MessageRole',
    'ConversationContext',
    'ConversationState',
    'PromptContext',
    'MealsForDateResponse',
    # AI
    'GPTMacros',
    'GPTFoodItem',
    'GPTAnalysisResponse',
    'GPTResponseError',
    'GPTResponseFormatError',
    'GPTResponseValidationError',
    'GPTResponseParsingError',
    'GPTResponseIncompleteError',
    # Notification
    'UserFcmToken',
    'NotificationPreferences',
    'PushNotification',
    'DeviceType',
    'NotificationType',
    # Chat
    'Thread',
    'ChatMessageRole',
    'ThreadStatus',
]
</file>

<file path="src/domain/ports/notification_repository_port.py">
from abc import ABC, abstractmethod
from datetime import datetime
from typing import List, Optional

from src.domain.model.notification import UserFcmToken, NotificationPreferences


class NotificationRepositoryPort(ABC):
    """Port interface for notification persistence operations."""
    
    # FCM Token operations
    @abstractmethod
    def save_fcm_token(self, token: UserFcmToken) -> UserFcmToken:
        """
        Persists an FCM token.
        
        Args:
            token: The FCM token to be saved
            
        Returns:
            The saved FCM token with any generated IDs
        """
        pass
    
    @abstractmethod
    def find_fcm_token_by_token(self, fcm_token: str) -> Optional[UserFcmToken]:
        """
        Finds an FCM token by the token string.
        
        Args:
            fcm_token: The FCM token string to find
            
        Returns:
            The FCM token if found, None otherwise
        """
        pass
    
    @abstractmethod
    def find_active_fcm_tokens_by_user(self, user_id: str) -> List[UserFcmToken]:
        """
        Finds all active FCM tokens for a user.
        
        Args:
            user_id: The user ID to find tokens for
            
        Returns:
            List of active FCM tokens for the user
        """
        pass
    
    @abstractmethod
    def deactivate_fcm_token(self, fcm_token: str) -> bool:
        """
        Deactivates an FCM token.
        
        Args:
            fcm_token: The FCM token string to deactivate
            
        Returns:
            True if token was found and deactivated, False otherwise
        """
        pass
    
    @abstractmethod
    def delete_fcm_token(self, fcm_token: str) -> bool:
        """
        Deletes an FCM token.
        
        Args:
            fcm_token: The FCM token string to delete
            
        Returns:
            True if token was found and deleted, False otherwise
        """
        pass
    
    # Notification Preferences operations
    @abstractmethod
    def save_notification_preferences(self, preferences: NotificationPreferences) -> NotificationPreferences:
        """
        Persists notification preferences.
        
        Args:
            preferences: The notification preferences to be saved
            
        Returns:
            The saved notification preferences with any generated IDs
        """
        pass
    
    @abstractmethod
    def find_notification_preferences_by_user(self, user_id: str) -> Optional[NotificationPreferences]:
        """
        Finds notification preferences by user ID.
        
        Args:
            user_id: The user ID to find preferences for
            
        Returns:
            The notification preferences if found, None otherwise
        """
        pass
    
    @abstractmethod
    def update_notification_preferences(self, user_id: str, preferences: NotificationPreferences) -> NotificationPreferences:
        """
        Updates notification preferences for a user.
        
        Args:
            user_id: The user ID to update preferences for
            preferences: The updated notification preferences
            
        Returns:
            The updated notification preferences
        """
        pass
    
    @abstractmethod
    def delete_notification_preferences(self, user_id: str) -> bool:
        """
        Deletes notification preferences for a user.
        
        Args:
            user_id: The user ID to delete preferences for
            
        Returns:
            True if preferences were found and deleted, False otherwise
        """
        pass
    
    # Utility operations
    @abstractmethod
    def find_users_for_meal_reminder(self, meal_type: str, current_utc: datetime) -> List[str]:
        """
        Finds user IDs who should receive meal reminders at current UTC time.
        
        Converts UTC to each user's local time for matching.
        
        Args:
            meal_type: The meal type (breakfast, lunch, dinner)
            current_utc: Current UTC datetime
            
        Returns:
            List of user IDs who should receive the reminder
        """
        pass
    
    @abstractmethod
    def find_users_for_sleep_reminder(self, current_utc: datetime) -> List[str]:
        """
        Finds user IDs who should receive sleep reminders at current UTC time.
        
        Converts UTC to each user's local time for matching.
        
        Args:
            current_utc: Current UTC datetime
            
        Returns:
            List of user IDs who should receive the reminder
        """
        pass
    
    @abstractmethod
    def find_users_for_water_reminder(self, current_utc: datetime) -> List[str]:
        """
        Finds user IDs who should receive water reminders based on their interval setting.
        
        Args:
            current_utc: Current UTC datetime
            
        Returns:
            List of user IDs due for water reminder
        """
        pass
    
    @abstractmethod
    def update_last_water_reminder(self, user_id: str, sent_at: datetime) -> bool:
        """
        Update last water reminder timestamp for user.
        
        Args:
            user_id: User ID
            sent_at: Timestamp when reminder was sent
            
        Returns:
            True if updated successfully, False otherwise
        """
        pass
</file>

<file path="src/domain/services/daily_meal_suggestion_service.py">
import json
import logging
import os
from typing import List, Dict

from langchain_core.messages import HumanMessage, SystemMessage
from langchain_google_genai import ChatGoogleGenerativeAI

from src.domain.model.meal_planning import PlannedMeal, MealType
from src.domain.services.meal_suggestion.json_extractor import JsonExtractor
from src.domain.services.meal_suggestion.suggestion_fallback_provider import SuggestionFallbackProvider
from src.domain.services.meal_suggestion.suggestion_prompt_builder import SuggestionPromptBuilder

logger = logging.getLogger(__name__)


class DailyMealSuggestionService:
    """Service for generating daily meal suggestions based on user preferences from onboarding"""

    def __init__(self):
        self.google_api_key = os.getenv("GOOGLE_API_KEY")
        if not self.google_api_key:
            raise ValueError("GOOGLE_API_KEY environment variable not set")

        self.model = ChatGoogleGenerativeAI(
            model=os.getenv("GEMINI_MODEL", "gemini-2.5-flash"),
            temperature=0.7,
            max_output_tokens=4000,  # Increased for multiple meals
            google_api_key=self.google_api_key,
            convert_system_message_to_human=True
        )

        # Initialize extracted components
        self.json_extractor = JsonExtractor()
        self.fallback_provider = SuggestionFallbackProvider()
        self.prompt_builder = SuggestionPromptBuilder()

    def generate_daily_suggestions(self, user_preferences: Dict) -> List[PlannedMeal]:
        """
        Generate 3-5 meal suggestions for a day based on user onboarding data

        Args:
            user_preferences: Dictionary containing user data from onboarding
                - age, gender, height, weight
                - activity_level: sedentary/lightly_active/moderately_active/very_active/extra_active
                - goal: lose_weight/maintain_weight/gain_weight/build_muscle
                - dietary_preferences: List of dietary restrictions
                - health_conditions: List of health conditions
                - target_calories: Daily calorie target
                - target_macros: Daily macro targets (protein, carbs, fat)

        Returns:
            List of 3-5 PlannedMeal objects
        """
        logger.info(f"Generating daily meal suggestions for user preferences")

        # Use the new unified generation method
        return self._generate_all_meals_unified(user_preferences)

    def _generate_all_meals_unified(self, user_preferences: Dict) -> List[PlannedMeal]:
        """Generate all daily meals in a single request"""

        # Determine meal distribution based on calories
        target_calories = user_preferences.get('target_calories')
        if not target_calories:
            raise ValueError("target_calories is required for meal suggestions. Please provide user's calculated TDEE.")
        meal_distribution = self._calculate_meal_distribution(target_calories)

        # Build unified prompt using prompt builder
        prompt = self.prompt_builder.build_unified_meal_prompt(meal_distribution, user_preferences)

        try:
            messages = [
                SystemMessage(content="You are a professional nutritionist creating personalized daily meal plans."),
                HumanMessage(content=prompt)
            ]

            response = self.model.invoke(messages)
            content = response.content

            # Extract JSON using json extractor
            daily_meals_data = self.json_extractor.extract_unified_meals_json(content)

            # Convert to PlannedMeal objects
            suggested_meals = []
            for meal_data in daily_meals_data["meals"]:
                meal_type = MealType(meal_data["meal_type"])
                meal = PlannedMeal(
                    meal_type=meal_type,
                    name=meal_data["name"],
                    description=meal_data["description"],
                    prep_time=meal_data.get("prep_time", 10),
                    cook_time=meal_data.get("cook_time", 15),
                    calories=meal_data["calories"],
                    protein=meal_data["protein"],
                    carbs=meal_data["carbs"],
                    fat=meal_data["fat"],
                    ingredients=meal_data["ingredients"],
                    instructions=meal_data.get("instructions", ["Prepare and cook as desired"]),
                    is_vegetarian=meal_data.get("is_vegetarian", False),
                    is_vegan=meal_data.get("is_vegan", False),
                    is_gluten_free=meal_data.get("is_gluten_free", False),
                    cuisine_type=meal_data.get("cuisine_type", "International")
                )
                suggested_meals.append(meal)

            return suggested_meals

        except Exception as e:
            logger.error(f"Error generating unified meals: {str(e)}")
            # Fallback to individual meal generation
            logger.info("Falling back to individual meal generation")
            return self._generate_meals_individual(meal_distribution, user_preferences)

    def _generate_meals_individual(self, meal_distribution: Dict[MealType, float], user_preferences: Dict) -> List[PlannedMeal]:
        """Fallback method: Generate meals individually (original method)"""
        suggested_meals = []

        for meal_type, calorie_target in meal_distribution.items():
            try:
                meal = self._generate_meal_for_type(
                    meal_type=meal_type,
                    calorie_target=calorie_target,
                    user_preferences=user_preferences
                )
                suggested_meals.append(meal)
            except Exception as e:
                logger.error(f"Error generating {meal_type.value} meal: {str(e)}")
                # Add a fallback meal using fallback provider
                suggested_meals.append(self.fallback_provider.get_fallback_meal(meal_type, calorie_target))

        return suggested_meals

    def _calculate_meal_distribution(self, total_calories: float) -> Dict[MealType, float]:
        """Calculate calorie distribution across meals"""
        from src.domain.constants import MealDistribution

        # Standard distribution
        distribution = {
            MealType.BREAKFAST: total_calories * MealDistribution.BREAKFAST_PERCENT,
            MealType.LUNCH: total_calories * MealDistribution.LUNCH_PERCENT,
            MealType.DINNER: total_calories * MealDistribution.DINNER_PERCENT,
        }

        # Add snack if total calories > threshold
        if total_calories > MealDistribution.MIN_CALORIES_FOR_SNACK:
            distribution[MealType.SNACK] = total_calories * MealDistribution.SNACK_PERCENT
            # Adjust other meals
            distribution[MealType.BREAKFAST] = total_calories * MealDistribution.BREAKFAST_WITH_SNACK
            distribution[MealType.LUNCH] = total_calories * MealDistribution.LUNCH_WITH_SNACK
            distribution[MealType.DINNER] = total_calories * MealDistribution.DINNER_WITH_SNACK

        return distribution

    def _generate_meal_for_type(self, meal_type: MealType, calorie_target: float,
                                user_preferences: Dict) -> PlannedMeal:
        """Generate a single meal based on type and preferences"""

        # Build prompt using prompt builder
        prompt = self.prompt_builder.build_meal_suggestion_prompt(meal_type, calorie_target, user_preferences)

        try:
            messages = [
                SystemMessage(content="You are a professional nutritionist creating personalized meal suggestions."),
                HumanMessage(content=prompt)
            ]

            response = self.model.invoke(messages)
            content = response.content

            # Extract JSON using json extractor
            meal_data = self.json_extractor.extract_json(content)

            # Create PlannedMeal object
            return PlannedMeal(
                meal_type=meal_type,
                name=meal_data["name"],
                description=meal_data["description"],
                prep_time=meal_data.get("prep_time", 10),
                cook_time=meal_data.get("cook_time", 15),
                calories=meal_data["calories"],
                protein=meal_data["protein"],
                carbs=meal_data["carbs"],
                fat=meal_data["fat"],
                ingredients=meal_data["ingredients"],
                instructions=meal_data.get("instructions", ["Prepare and cook as desired"]),
                is_vegetarian=meal_data.get("is_vegetarian", False),
                is_vegan=meal_data.get("is_vegan", False),
                is_gluten_free=meal_data.get("is_gluten_free", False),
                cuisine_type=meal_data.get("cuisine_type", "International")
            )

        except Exception as e:
            logger.error(f"Error generating meal: {str(e)}")
            raise
</file>

<file path="src/domain/services/meal_service.py">
"""
MealService - Domain service for meal operations.
Provides shared meal editing and management logic.
"""
import logging
from typing import List, Optional
from uuid import uuid4

from src.domain.model.meal import Meal
from src.domain.model.nutrition import FoodItem
from src.domain.model.nutrition import Nutrition
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.app.commands.meal.edit_meal_command import FoodItemChange, CustomNutritionData


logger = logging.getLogger(__name__)


class MealService:
    """Service for meal operations."""
    
    def __init__(self, meal_repository: MealRepositoryPort):
        self.meal_repository = meal_repository
    
    def apply_food_item_changes(
        self,
        meal: Meal,
        food_item_changes: List[FoodItemChange]
    ) -> Meal:
        """Apply food item changes to a meal."""
        # Ensure meal.nutrition exists and food_items list is initialized
        if meal.nutrition is None:
            from src.domain.model.nutrition.macros import Macros
            meal.nutrition = Nutrition(
                calories=0.0,
                macros=Macros(protein=0.0, carbs=0.0, fat=0.0),
                food_items=[]
            )
        
        # Ensure food_items list exists
        if meal.nutrition.food_items is None:
            meal.nutrition.food_items = []
        
        for change in food_item_changes:
            if change.action == "add":
                # Add new food item
                from src.domain.model.nutrition.macros import Macros
                
                # Calculate calories and macros from custom_nutrition if provided
                if change.custom_nutrition:
                    scale_factor = change.quantity / 100.0  # Custom nutrition is per 100g
                    calories = change.custom_nutrition.calories_per_100g * scale_factor
                    macros = Macros(
                        protein=change.custom_nutrition.protein_per_100g * scale_factor,
                        carbs=change.custom_nutrition.carbs_per_100g * scale_factor,
                        fat=change.custom_nutrition.fat_per_100g * scale_factor
                    )
                else:
                    # Default values when no custom nutrition provided
                    calories = 0.0
                    macros = Macros(protein=0.0, carbs=0.0, fat=0.0)
                
                new_food_item = FoodItem(
                    id=str(uuid4()),
                    name=change.name,
                    quantity=change.quantity,
                    unit=change.unit,
                    calories=calories,
                    macros=macros,
                    is_custom=change.custom_nutrition is not None
                )
                meal.nutrition.food_items.append(new_food_item)
                logger.info(f"Added food item: {change.name}")
            
            elif change.action == "remove":
                # Remove food item
                if change.id:
                    meal.nutrition.food_items = [
                        item for item in meal.nutrition.food_items
                        if item.id != change.id
                    ]
                    logger.info(f"Removed food item: {change.id}")
                else:
                    logger.warning("Remove action requires food item id")
            
            elif change.action == "update":
                # Update existing food item
                from src.domain.model.nutrition.macros import Macros
                
                if not change.id:
                    logger.warning("Update action requires food item id")
                    continue
                
                for item in meal.nutrition.food_items:
                    if item.id == change.id:
                        if change.name is not None:
                            item.name = change.name
                        if change.quantity is not None:
                            item.quantity = change.quantity
                        if change.unit is not None:
                            item.unit = change.unit
                        if change.custom_nutrition is not None:
                            # Recalculate calories and macros from custom nutrition
                            scale_factor = (change.quantity or item.quantity) / 100.0
                            item.calories = change.custom_nutrition.calories_per_100g * scale_factor
                            item.macros = Macros(
                                protein=change.custom_nutrition.protein_per_100g * scale_factor,
                                carbs=change.custom_nutrition.carbs_per_100g * scale_factor,
                                fat=change.custom_nutrition.fat_per_100g * scale_factor
                            )
                            item.is_custom = True
                        logger.info(f"Updated food item: {change.id}")
                        break
        
        # Recalculate total nutrition from food items
        from src.domain.services import NutritionCalculationService
        nutrition_service = NutritionCalculationService()
        meal.nutrition = nutrition_service.calculate_meal_total(meal.nutrition.food_items)
        
        return meal
    
    def add_custom_ingredient(
        self,
        meal_id: str,
        name: str,
        quantity: float,
        unit: str,
        nutrition: Optional[CustomNutritionData] = None
    ) -> Meal:
        """Add a custom ingredient to a meal."""
        meal = self.meal_repository.find_by_id(meal_id)
        if not meal:
            raise ValueError(f"Meal {meal_id} not found")
        
        food_item_change = FoodItemChange(
            action="add",
            name=name,
            quantity=quantity,
            unit=unit,
            custom_nutrition=nutrition
        )
        
        updated_meal = self.apply_food_item_changes(meal, [food_item_change])
        return self.meal_repository.save(updated_meal)
</file>

<file path="src/domain/services/meal_suggestion_service.py">
"""
Service for generating meal suggestions.
"""
import logging
import uuid
from typing import List, Dict, Any, Optional

from src.domain.prompts.meal_suggestion_prompt import generate_meal_suggestion_prompt
from src.infra.adapters.meal_generation_service import MealGenerationService

logger = logging.getLogger(__name__)


class MealSuggestionService:
    """
    Service for generating exactly 3 meal suggestions based on user inputs.
    
    Reuses the MealGenerationService for AI generation with specialized prompts.
    """
    
    def __init__(self):
        """Initialize the service with meal generation adapter."""
        self.meal_generation_service = MealGenerationService()
    
    def generate_suggestions(
        self,
        user_id: str,
        meal_type: str,
        calorie_target: int,
        ingredients: List[str],
        time_available_minutes: Optional[int],
        dietary_preferences: List[str],
    ) -> Dict[str, Any]:
        """
        Generate exactly 3 meal suggestions.
        
        Args:
            user_id: User identifier
            meal_type: Type of meal (breakfast, lunch, dinner, snack)
            calorie_target: Target calories for the meal
            ingredients: Available ingredients
            time_available_minutes: Optional time constraint in minutes
            dietary_preferences: Dietary preferences
            exclude_ids: Meal IDs to exclude (for regeneration)
        
        Returns:
            Dict with request_id, suggestions (list of 3), and generation_token
        """
        try:
            # Generate prompt
            prompt, system_message = generate_meal_suggestion_prompt(
                meal_type=meal_type,
                calorie_target=calorie_target,
                ingredients=ingredients,
                time_available_minutes=time_available_minutes,
                dietary_preferences=dietary_preferences,
                exclude_names=[]  # We'll use IDs for exclusion, names for prompt clarity
            )
            
            # Call AI generation service
            logger.info(f"Generating meal suggestions for user {user_id}, meal_type: {meal_type}")
            raw_response = self.meal_generation_service.generate_meal_plan(
                prompt=prompt,
                system_message=system_message,
                response_type="json",
                max_tokens=2000  # Sufficient for 3 meals
            )
            
            # Validate response structure
            if "suggestions" not in raw_response:
                raise ValueError("AI response missing 'suggestions' field")
            
            suggestions_list = raw_response["suggestions"]
            
            if not isinstance(suggestions_list, list):
                raise ValueError("'suggestions' field must be a list")
            
            if len(suggestions_list) < 3:
                logger.warning(f"AI generated only {len(suggestions_list)} suggestions, expected 3")
                # Pad with fallback if needed
                while len(suggestions_list) < 3:
                    suggestions_list.append(self._create_fallback_suggestion(meal_type, calorie_target))
            
            # Take only first 3 if more were generated
            suggestions_list = suggestions_list[:3]
            
            # Process and enrich suggestions
            processed_suggestions = []
            for idx, suggestion in enumerate(suggestions_list):
                processed = self._process_suggestion(suggestion, meal_type, idx)
                
                # Apply time filter if specified
                if time_available_minutes:
                    total_time = processed.get("estimated_cook_time_minutes", 0)
                    if total_time > time_available_minutes:
                        logger.warning(
                            f"Suggestion '{processed['name']}' exceeds time limit "
                            f"({total_time} > {time_available_minutes}), replacing with fallback"
                        )
                        processed = self._create_fallback_suggestion(
                            meal_type, calorie_target, time_available_minutes
                        )
                
                processed_suggestions.append(processed)
            
            # Generate unique IDs for tracking
            request_id = f"req_{uuid.uuid4().hex[:12]}"
            generation_token = f"gen_{uuid.uuid4().hex[:12]}"
            
            return {
                "request_id": request_id,
                "suggestions": processed_suggestions,
                "generation_token": generation_token
            }
            
        except Exception as e:
            logger.error(f"Error generating meal suggestions: {str(e)}")
            # Return fallback suggestions
            return self._generate_fallback_suggestions(user_id, meal_type, calorie_target, time_available_minutes)
    
    def _process_suggestion(self, suggestion: Dict[str, Any], meal_type: str, index: int) -> Dict[str, Any]:
        """
        Process and validate a single suggestion from AI response.
        
        Args:
            suggestion: Raw suggestion from AI
            meal_type: Type of meal
            index: Index in the list (for ID generation)
        
        Returns:
            Processed suggestion with all required fields
        """
        # Generate unique ID
        suggestion_id = f"meal_{meal_type}_{uuid.uuid4().hex[:8]}"
        
        # Extract and validate fields
        name = suggestion.get("name", f"Suggested {meal_type.title()} {index + 1}")
        description = suggestion.get("description", f"A delicious {meal_type}")
        
        prep_time = suggestion.get("prep_time", 10)
        cook_time = suggestion.get("cook_time", 15)
        total_time = prep_time + cook_time
        
        calories = int(suggestion.get("calories", 400))
        protein = float(suggestion.get("protein", 20.0))
        carbs = float(suggestion.get("carbs", 40.0))
        fat = float(suggestion.get("fat", 15.0))
        
        ingredients = suggestion.get("ingredients", [])
        seasonings = suggestion.get("seasonings", [])
        instructions = suggestion.get("instructions", [])
        
        # Combine ingredients and seasonings for ingredients_list
        ingredients_list = ingredients + seasonings
        
        # Build tags
        tags = []
        if suggestion.get("is_vegetarian", False):
            tags.append("vegetarian")
        if suggestion.get("is_vegan", False):
            tags.append("vegan")
        if suggestion.get("is_gluten_free", False):
            tags.append("gluten-free")
        
        cuisine_type = suggestion.get("cuisine_type", "International")
        if cuisine_type:
            tags.append(cuisine_type.lower())
        
        return {
            "id": suggestion_id,
            "name": name,
            "description": description,
            "estimated_cook_time_minutes": total_time,
            "calories": calories,
            "macros": {
                "protein": protein,
                "carbs": carbs,
                "fat": fat
            },
            "ingredients_list": ingredients_list,
            "instructions": instructions,
            "tags": tags,
            "image_url": None,
            "source": "AI Generated"
        }
    
    def _create_fallback_suggestion(
        self, 
        meal_type: str, 
        calorie_target: int,
        time_limit: Optional[int] = None
    ) -> Dict[str, Any]:
        """
        Create a simple fallback suggestion when AI generation fails.
        
        Args:
            meal_type: Type of meal
            calorie_target: Target calories
            time_limit: Optional time constraint
        
        Returns:
            Fallback suggestion dict
        """
        suggestion_id = f"meal_{meal_type}_{uuid.uuid4().hex[:8]}"
        
        # Simple fallback meals by type
        fallback_meals = {
            "breakfast": {
                "name": "Simple Breakfast Bowl",
                "description": "Quick and nutritious breakfast with eggs and toast",
                "ingredients": ["2 eggs", "2 slices whole wheat bread", "1 tbsp butter"],
                "instructions": ["Toast bread", "Scramble eggs", "Serve together"]
            },
            "lunch": {
                "name": "Quick Lunch Plate",
                "description": "Balanced lunch with protein and vegetables",
                "ingredients": ["150g chicken breast", "100g mixed vegetables", "100g rice"],
                "instructions": ["Cook chicken", "Steam vegetables", "Prepare rice", "Serve together"]
            },
            "dinner": {
                "name": "Simple Dinner",
                "description": "Easy and satisfying dinner",
                "ingredients": ["200g protein of choice", "150g vegetables", "100g grains"],
                "instructions": ["Prepare protein", "Cook vegetables", "Prepare grains", "Combine and serve"]
            },
            "snack": {
                "name": "Healthy Snack",
                "description": "Quick and nutritious snack",
                "ingredients": ["1 apple", "2 tbsp peanut butter"],
                "instructions": ["Slice apple", "Serve with peanut butter"]
            }
        }
        
        fallback = fallback_meals.get(meal_type, fallback_meals["lunch"])
        
        # Adjust time if needed
        cook_time = 15 if time_limit and time_limit < 30 else 20
        
        return {
            "id": suggestion_id,
            "name": fallback["name"],
            "description": fallback["description"],
            "estimated_cook_time_minutes": cook_time,
            "calories": calorie_target,
            "macros": {
                "protein": calorie_target * 0.3 / 4,  # 30% protein
                "carbs": calorie_target * 0.4 / 4,    # 40% carbs
                "fat": calorie_target * 0.3 / 9       # 30% fat
            },
            "ingredients_list": fallback["ingredients"],
            "instructions": fallback["instructions"],
            "tags": ["simple", "quick"],
            "image_url": None,
            "source": "Fallback"
        }
    
    def _generate_fallback_suggestions(
        self,
        user_id: str,
        meal_type: str,
        calorie_target: int,
        time_limit: Optional[int]
    ) -> Dict[str, Any]:
        """
        Generate 3 fallback suggestions when AI generation completely fails.
        
        Returns:
            Complete response with 3 fallback suggestions
        """
        logger.warning(f"Using fallback suggestions for user {user_id}")
        
        suggestions = [
            self._create_fallback_suggestion(meal_type, calorie_target, time_limit)
            for _ in range(3)
        ]
        
        return {
            "request_id": f"req_fallback_{uuid.uuid4().hex[:12]}",
            "suggestions": suggestions,
            "generation_token": f"gen_fallback_{uuid.uuid4().hex[:12]}"
        }
</file>

<file path="src/infra/database/models/notification/notification_preferences.py">
"""
Notification preferences model for user notification settings.
"""
from sqlalchemy import Column, String, Boolean, Integer, DateTime, CheckConstraint

from src.infra.database.config import Base
from src.infra.database.models.base import BaseMixin


class NotificationPreferences(Base, BaseMixin):
    """Notification preferences table for user notification settings."""
    __tablename__ = 'notification_preferences'
    
    # User relationship (one-to-one)
    user_id = Column(String(36), nullable=False, unique=True, index=True)
    
    # Notification Type Toggles
    meal_reminders_enabled = Column(Boolean, default=True, nullable=False)
    water_reminders_enabled = Column(Boolean, default=True, nullable=False)
    sleep_reminders_enabled = Column(Boolean, default=True, nullable=False)
    progress_notifications_enabled = Column(Boolean, default=True, nullable=False)
    reengagement_notifications_enabled = Column(Boolean, default=True, nullable=False)
    
    # Meal Reminder Timing (minutes from midnight: 0-1439)
    breakfast_time_minutes = Column(Integer, nullable=True)
    lunch_time_minutes = Column(Integer, nullable=True)
    dinner_time_minutes = Column(Integer, nullable=True)
    
    # Water Reminder Settings
    water_reminder_interval_hours = Column(Integer, default=2, nullable=False)
    # Use timezone=True to store timezone-aware datetimes (required for UTC comparisons)
    last_water_reminder_at = Column(DateTime(timezone=True), nullable=True)
    
    # Sleep Reminder Timing (minutes from midnight)
    sleep_reminder_time_minutes = Column(Integer, nullable=True)
    
    # Constraints
    __table_args__ = (
        CheckConstraint('breakfast_time_minutes >= 0 AND breakfast_time_minutes < 1440', name='check_breakfast_time'),
        CheckConstraint('lunch_time_minutes >= 0 AND lunch_time_minutes < 1440', name='check_lunch_time'),
        CheckConstraint('dinner_time_minutes >= 0 AND dinner_time_minutes < 1440', name='check_dinner_time'),
        CheckConstraint('water_reminder_interval_hours > 0', name='check_water_interval'),
        CheckConstraint('sleep_reminder_time_minutes >= 0 AND sleep_reminder_time_minutes < 1440', name='check_sleep_time'),
    )
    
    # Relationships - removed to avoid circular import issues
    
    def to_domain(self):
        """Convert database model to domain model."""
        from src.domain.model.notification import NotificationPreferences as DomainNotificationPreferences
        
        return DomainNotificationPreferences(
            preferences_id=self.id,
            user_id=self.user_id,
            meal_reminders_enabled=self.meal_reminders_enabled,
            water_reminders_enabled=self.water_reminders_enabled,
            sleep_reminders_enabled=self.sleep_reminders_enabled,
            progress_notifications_enabled=self.progress_notifications_enabled,
            reengagement_notifications_enabled=self.reengagement_notifications_enabled,
            breakfast_time_minutes=self.breakfast_time_minutes,
            lunch_time_minutes=self.lunch_time_minutes,
            dinner_time_minutes=self.dinner_time_minutes,
            water_reminder_interval_hours=self.water_reminder_interval_hours,
            last_water_reminder_at=self.last_water_reminder_at,
            sleep_reminder_time_minutes=self.sleep_reminder_time_minutes,
            created_at=self.created_at,
            updated_at=self.updated_at
        )
</file>

<file path="src/infra/database/migration_manager.py">
"""
Database migration manager for automatic schema and migration management.

This module handles automatic database initialization and migration execution
during application startup, ensuring the database is always up-to-date.
"""
import logging
import os
import time
from typing import Optional

from alembic import command
from alembic.config import Config
from alembic.runtime.migration import MigrationContext
from alembic.script import ScriptDirectory
from sqlalchemy import inspect, text
from sqlalchemy.engine import Engine
from sqlalchemy.exc import OperationalError, DatabaseError

from src.infra.database.config import engine, Base

logger = logging.getLogger(__name__)


class MigrationManager:
    """Manages database migrations and schema initialization."""
    
    def __init__(
        self,
        engine: Engine,
        alembic_config_path: str = "alembic.ini",
        auto_migrate: bool = True,
        migration_timeout: int = 60,
        retry_attempts: int = 3,
        retry_delay: float = 2.0
    ):
        """
        Initialize the migration manager.
        
        Args:
            engine: SQLAlchemy database engine
            alembic_config_path: Path to alembic configuration file
            auto_migrate: Whether to automatically run migrations
            migration_timeout: Maximum time to wait for migrations (seconds)
            retry_attempts: Number of retry attempts for database operations
            retry_delay: Initial delay between retries (seconds)
        """
        self.engine = engine
        self.alembic_config_path = alembic_config_path
        self.auto_migrate = auto_migrate
        self.migration_timeout = migration_timeout
        self.retry_attempts = retry_attempts
        self.retry_delay = retry_delay
        self._lock_acquired = False
        
    def _get_alembic_config(self) -> Config:
        """Get Alembic configuration."""
        if not os.path.exists(self.alembic_config_path):
            raise FileNotFoundError(f"Alembic config not found: {self.alembic_config_path}")
        
        config = Config(self.alembic_config_path)
        # Override database URL from engine
        config.set_main_option("sqlalchemy.url", str(self.engine.url))
        return config
    
    def _check_database_connection(self) -> bool:
        """
        Check if database connection is available.
        
        Returns:
            bool: True if connection successful, False otherwise
        """
        try:
            with self.engine.connect() as conn:
                conn.execute(text("SELECT 1"))
            return True
        except (OperationalError, DatabaseError) as e:
            logger.warning(f"Database connection check failed: {e}")
            return False
    
    def _wait_for_database(self) -> bool:
        """
        Wait for database to become available with retries.
        
        Returns:
            bool: True if database available, False if timeout
        """
        start_time = time.time()
        attempt = 0
        delay = self.retry_delay
        
        while attempt < self.retry_attempts:
            if self._check_database_connection():
                logger.info("✅ Database connection established")
                return True
            
            if time.time() - start_time > self.migration_timeout:
                logger.error("Database connection timeout exceeded")
                return False
            
            attempt += 1
            logger.info(f"Waiting for database... (attempt {attempt}/{self.retry_attempts})")
            time.sleep(delay)
            delay *= 2  # Exponential backoff
            
        return False
    
    def _acquire_migration_lock(self) -> bool:
        """
        Acquire a migration lock to prevent concurrent migrations.
        Uses MySQL GET_LOCK or PostgreSQL advisory locks.
        
        Returns:
            bool: True if lock acquired, False otherwise
        """
        try:
            with self.engine.connect() as conn:
                dialect_name = self.engine.dialect.name
                
                if dialect_name == 'mysql':
                    # MySQL: GET_LOCK returns 1 if lock acquired, 0 if timeout
                    result = conn.execute(
                        text("SELECT GET_LOCK('alembic_migration_lock', 10)")
                    ).scalar()
                    self._lock_acquired = result == 1
                    return self._lock_acquired
                    
                elif dialect_name == 'postgresql':
                    # PostgreSQL: advisory lock
                    conn.execute(text("SELECT pg_advisory_lock(12345)"))
                    self._lock_acquired = True
                    return True
                    
                else:
                    # For other databases, proceed without locking
                    logger.warning(f"Migration locking not implemented for {dialect_name}")
                    return True
                    
        except Exception as e:
            logger.error(f"Failed to acquire migration lock: {e}")
            return False
    
    def _release_migration_lock(self):
        """Release the migration lock if acquired."""
        if not self._lock_acquired:
            return
            
        try:
            with self.engine.connect() as conn:
                dialect_name = self.engine.dialect.name
                
                if dialect_name == 'mysql':
                    conn.execute(text("SELECT RELEASE_LOCK('alembic_migration_lock')"))
                elif dialect_name == 'postgresql':
                    conn.execute(text("SELECT pg_advisory_unlock(12345)"))
                    
                self._lock_acquired = False
                logger.debug("Migration lock released")
                
        except Exception as e:
            logger.error(f"Failed to release migration lock: {e}")
    
    def _get_current_revision(self) -> Optional[str]:
        """
        Get the current database revision.
        
        Returns:
            Optional[str]: Current revision or None if not initialized
        """
        try:
            with self.engine.connect() as conn:
                context = MigrationContext.configure(conn)
                return context.get_current_revision()
        except Exception as e:
            logger.debug(f"Could not get current revision: {e}")
            return None
    
    def _is_database_initialized(self) -> bool:
        """
        Check if database has been initialized with tables.
        
        Returns:
            bool: True if database has tables, False otherwise
        """
        inspector = inspect(self.engine)
        tables = inspector.get_table_names()
        # Check for any application tables (not just alembic_version)
        app_tables = [t for t in tables if t != 'alembic_version']
        return len(app_tables) > 0
    
    def _create_initial_schema(self):
        """Create initial database schema from SQLAlchemy models."""
        logger.info("Creating initial database schema...")
        try:
            # Import all models to ensure they're registered
            from src.infra.database import models  # noqa: F401
            
            Base.metadata.create_all(bind=self.engine)
            logger.info("✅ Initial schema created successfully")
        except Exception as e:
            logger.error(f"Failed to create initial schema: {e}")
            raise
    
    def _stamp_baseline(self, revision: str = "001"):
        """
        Stamp the database with a baseline revision without running migrations.
        
        Args:
            revision: The revision to stamp (default: "001")
        """
        logger.info(f"Stamping database with baseline revision: {revision}")
        try:
            config = self._get_alembic_config()
            command.stamp(config, revision)
            logger.info(f"✅ Database stamped with revision: {revision}")
        except Exception as e:
            logger.error(f"Failed to stamp baseline: {e}")
            raise
    
    def _stamp_latest(self):
        """Stamp the database with the latest revision."""
        logger.info("Stamping database with latest revision")
        try:
            config = self._get_alembic_config()
            script_dir = ScriptDirectory.from_config(config)
            
            # Get all heads (in case of branching)
            heads = script_dir.get_heads()
            logger.info(f"Available heads: {heads}")
            
            # For now, use the first head or a specific revision
            # In a production environment, you'd want to merge the branches
            if heads:
                target_revision = heads[0]  # Use first head
                logger.info(f"Using revision: {target_revision}")
                
                # Add timeout and more detailed logging
                import signal
                import time
                
                def timeout_handler(signum, frame):
                    raise TimeoutError("Stamping operation timed out")
                
                # Set a 30-second timeout for the stamping operation
                signal.signal(signal.SIGALRM, timeout_handler)
                signal.alarm(30)
                
                try:
                    logger.info(f"Starting stamp operation for revision: {target_revision}")
                    
                    # First, manually create the alembic_version table if it doesn't exist
                    with self.engine.connect() as conn:
                        # Check if alembic_version table exists
                        result = conn.execute(text("SHOW TABLES LIKE 'alembic_version'"))
                        if not result.fetchone():
                            logger.info("Creating alembic_version table manually...")
                            conn.execute(text("""
                                CREATE TABLE alembic_version (
                                    version_num VARCHAR(32) NOT NULL,
                                    CONSTRAINT alembic_version_pkc PRIMARY KEY (version_num)
                                ) ENGINE=InnoDB
                            """))
                            conn.commit()
                            logger.info("✅ alembic_version table created")
                    
                    # Now try the stamp operation
                    command.stamp(config, target_revision)
                    signal.alarm(0)  # Cancel the alarm
                    logger.info("✅ Database stamped with latest revision")
                except TimeoutError:
                    signal.alarm(0)  # Cancel the alarm
                    logger.error("❌ Stamping operation timed out after 30 seconds")
                    raise Exception("Stamping operation timed out")
                    
            else:
                logger.warning("No heads found, using baseline revision")
                command.stamp(config, "001")
                
        except Exception as e:
            logger.error(f"Failed to stamp latest: {e}")
            raise
    
    def _run_migrations(self):
        """Run pending migrations to latest revision."""
        logger.info("Running database migrations...")
        try:
            config = self._get_alembic_config()
            command.upgrade(config, "head")
            logger.info("✅ Migrations completed successfully")
        except Exception as e:
            logger.error(f"Failed to run migrations: {e}")
            raise
    
    def _get_pending_migrations(self) -> list:
        """
        Get list of pending migrations.
        
        Returns:
            list: List of pending migration revisions
        """
        try:
            config = self._get_alembic_config()
            script_dir = ScriptDirectory.from_config(config)
            
            with self.engine.connect() as conn:
                context = MigrationContext.configure(conn)
                current_rev = context.get_current_revision()
                
            if current_rev is None:
                # All migrations are pending
                return [s.revision for s in script_dir.walk_revisions()]
            
            # Get revisions between current and head
            pending = []
            for rev in script_dir.walk_revisions():
                if rev.revision == current_rev:
                    break
                pending.append(rev.revision)
            
            return pending[::-1]  # Reverse to get chronological order
            
        except Exception as e:
            logger.error(f"Failed to get pending migrations: {e}")
            return []
    
    def initialize_and_migrate(self) -> bool:
        """
        Main method to initialize database and run migrations.
        
        Returns:
            bool: True if successful, False otherwise
        """
        if not self.auto_migrate:
            logger.info("Auto-migration disabled, skipping...")
            return True
        
        logger.info("🚀 Starting database initialization and migration...")
        
        # Wait for database to be available
        if not self._wait_for_database():
            logger.error("❌ Database not available, cannot proceed with migrations")
            return False
        
        # Acquire migration lock
        if not self._acquire_migration_lock():
            logger.warning("Could not acquire migration lock, another instance may be migrating")
            return False
        
        try:
            # Check current state
            inspector = inspect(self.engine)
            tables = inspector.get_table_names()
            current_revision = self._get_current_revision()
            
            logger.info(f"Current database state: {len(tables)} tables, revision: {current_revision}")
            
            # Determine what to do
            if 'alembic_version' not in tables:
                # First time setup
                logger.info("First time deployment detected")
                
                if not self._is_database_initialized():
                    # Empty database - create schema
                    self._create_initial_schema()
                    
                # Stamp as latest revision since we created from current models
                self._stamp_latest()
                
            # Check for pending migrations
            pending = self._get_pending_migrations()
            if pending:
                logger.info(f"Found {len(pending)} pending migrations: {pending}")
                self._run_migrations()
            else:
                logger.info("✅ Database is up to date")
            
            return True
            
        except Exception as e:
            logger.error(f"❌ Migration failed: {e}")
            return False
            
        finally:
            self._release_migration_lock()
    
    @classmethod
    def from_environment(cls, engine: Engine) -> 'MigrationManager':
        """
        Create MigrationManager from environment variables.
        
        Args:
            engine: SQLAlchemy database engine
            
        Returns:
            MigrationManager: Configured instance
        """
        auto_migrate = os.getenv('AUTO_MIGRATE', 'true').lower() == 'true'
        migration_timeout = int(os.getenv('MIGRATION_TIMEOUT', '60'))
        retry_attempts = int(os.getenv('MIGRATION_RETRY_ATTEMPTS', '3'))
        retry_delay = float(os.getenv('MIGRATION_RETRY_DELAY', '2.0'))
        
        return cls(
            engine=engine,
            auto_migrate=auto_migrate,
            migration_timeout=migration_timeout,
            retry_attempts=retry_attempts,
            retry_delay=retry_delay
        )


# Convenience function for backwards compatibility
def run_migrations() -> bool:
    """
    Run database migrations using default configuration.
    
    Returns:
        bool: True if successful, False otherwise
    """
    manager = MigrationManager.from_environment(engine)
    return manager.initialize_and_migrate()
</file>

<file path="src/infra/repositories/meal_suggestion_repository.py">
"""Redis-backed meal suggestion repository (Phase 06)."""
import json
import logging
from typing import List, Optional

from src.domain.model.meal_suggestion import MealSuggestion, SuggestionSession
from src.domain.ports.meal_suggestion_repository_port import MealSuggestionRepositoryPort
from src.infra.cache.redis_client import RedisClient

logger = logging.getLogger(__name__)


class MealSuggestionRepository(MealSuggestionRepositoryPort):
    """Redis-backed repository for meal suggestions with 4-hour TTL."""

    TTL_SECONDS = 4 * 60 * 60  # 4 hours

    def __init__(self, redis_client: RedisClient):
        self._cache = redis_client

    async def save_session(self, session: SuggestionSession) -> None:
        """Save session with 4-hour TTL."""
        key = f"suggestion_session:{session.id}"
        data = self._serialize_session(session)
        await self._cache.set(key, data, ttl=self.TTL_SECONDS)
        logger.debug(f"Saved session {session.id}")

    async def get_session(self, session_id: str) -> Optional[SuggestionSession]:
        """Retrieve session by ID."""
        key = f"suggestion_session:{session_id}"
        data = await self._cache.get(key)
        if not data:
            return None
        return self._deserialize_session(data)

    async def update_session(self, session: SuggestionSession) -> None:
        """Update session (maintains remaining TTL)."""
        key = f"suggestion_session:{session.id}"
        # Get remaining TTL
        if self._cache.client:
            ttl = await self._cache.client.ttl(key)
            if ttl <= 0:
                ttl = self.TTL_SECONDS
        else:
            ttl = self.TTL_SECONDS

        data = self._serialize_session(session)
        await self._cache.set(key, data, ttl=ttl)
        logger.debug(f"Updated session {session.id}")

    async def save_session_with_suggestions(
        self,
        session: SuggestionSession,
        suggestions: List[MealSuggestion]
    ) -> None:
        """
        Save session and all suggestions atomically using Redis pipeline.
        Reduces 4 round-trips to 1 batch operation.
        """
        if not self._cache.client:
            logger.warning("Redis client not available, skipping batch save")
            return

        async with self._cache.client.pipeline(transaction=False) as pipe:
            # Session
            session_key = f"suggestion_session:{session.id}"
            session_data = self._serialize_session(session)
            pipe.set(session_key, session_data, ex=self.TTL_SECONDS)

            # All suggestions in batch
            for suggestion in suggestions:
                key = f"suggestion:{suggestion.session_id}:{suggestion.id}"
                data = self._serialize_suggestion(suggestion)
                pipe.set(key, data, ex=self.TTL_SECONDS)

            # Execute all commands in single round-trip
            await pipe.execute()

        logger.debug(
            f"Saved session {session.id} + {len(suggestions)} suggestions via pipeline"
        )

    async def delete_session(self, session_id: str) -> None:
        """Delete session and all associated suggestions."""
        session_key = f"suggestion_session:{session_id}"
        await self._cache.delete(session_key)

        # Delete all suggestions for this session
        pattern = f"suggestion:{session_id}:*"
        deleted_count = await self._cache.delete_pattern(pattern)
        logger.debug(f"Deleted session {session_id} and {deleted_count} suggestions")

    async def save_suggestions(self, suggestions: List[MealSuggestion]) -> None:
        """Save batch of suggestions with 4-hour TTL."""
        for suggestion in suggestions:
            key = f"suggestion:{suggestion.session_id}:{suggestion.id}"
            data = self._serialize_suggestion(suggestion)
            await self._cache.set(key, data, ttl=self.TTL_SECONDS)
        logger.debug(f"Saved {len(suggestions)} suggestions")

    async def get_suggestion(self, suggestion_id: str) -> Optional[MealSuggestion]:
        """Retrieve single suggestion by ID."""
        # Search across all sessions (not ideal but works for 4h TTL)
        pattern = f"suggestion:*:{suggestion_id}"
        if not self._cache.client:
            return None

        keys = await self._cache.client.keys(pattern)
        if not keys:
            return None

        data = await self._cache.get(keys[0])
        if not data:
            return None

        return self._deserialize_suggestion(data)

    async def update_suggestion(self, suggestion: MealSuggestion) -> None:
        """Update suggestion (e.g., status change)."""
        key = f"suggestion:{suggestion.session_id}:{suggestion.id}"
        if self._cache.client:
            ttl = await self._cache.client.ttl(key)
            if ttl <= 0:
                ttl = self.TTL_SECONDS
        else:
            ttl = self.TTL_SECONDS

        data = self._serialize_suggestion(suggestion)
        await self._cache.set(key, data, ttl=ttl)
        logger.debug(f"Updated suggestion {suggestion.id}")

    async def get_session_suggestions(
        self, session_id: str
    ) -> List[MealSuggestion]:
        """Get all suggestions for a session."""
        pattern = f"suggestion:{session_id}:*"
        if not self._cache.client:
            return []

        keys = await self._cache.client.keys(pattern)
        if not keys:
            return []

        suggestions = []
        for key in keys:
            data = await self._cache.get(key)
            if data:
                suggestions.append(self._deserialize_suggestion(data))

        return suggestions

    def _serialize_session(self, session: SuggestionSession) -> str:
        """Serialize session to JSON string."""
        return json.dumps({
            "id": session.id,
            "user_id": session.user_id,
            "meal_type": session.meal_type,
            "meal_portion_type": session.meal_portion_type,
            "target_calories": session.target_calories,
            "ingredients": session.ingredients,
            "cooking_time_minutes": session.cooking_time_minutes,
            "shown_suggestion_ids": session.shown_suggestion_ids,
            "dietary_preferences": getattr(session, 'dietary_preferences', []),
            "allergies": getattr(session, 'allergies', []),
            "created_at": session.created_at.isoformat(),
            "expires_at": session.expires_at.isoformat() if session.expires_at else None,
        })

    def _deserialize_session(self, data: str) -> SuggestionSession:
        """Deserialize JSON to session object."""
        from datetime import datetime
        obj = json.loads(data)
        return SuggestionSession(
            id=obj["id"],
            user_id=obj["user_id"],
            meal_type=obj["meal_type"],
            meal_portion_type=obj["meal_portion_type"],
            target_calories=obj["target_calories"],
            ingredients=obj["ingredients"],
            cooking_time_minutes=obj["cooking_time_minutes"],
            shown_suggestion_ids=obj.get("shown_suggestion_ids", []),
            dietary_preferences=obj.get("dietary_preferences", []),
            allergies=obj.get("allergies", []),
            created_at=datetime.fromisoformat(obj["created_at"]),
            expires_at=datetime.fromisoformat(obj["expires_at"]) if obj.get("expires_at") else None,
        )

    def _serialize_suggestion(self, suggestion: MealSuggestion) -> str:
        """Serialize suggestion to JSON string."""
        return json.dumps({
            "id": suggestion.id,
            "session_id": suggestion.session_id,
            "user_id": suggestion.user_id,
            "meal_name": suggestion.meal_name,
            "description": suggestion.description,
            "meal_type": suggestion.meal_type.value,
            "macros": {
                "calories": suggestion.macros.calories,
                "protein": suggestion.macros.protein,
                "carbs": suggestion.macros.carbs,
                "fat": suggestion.macros.fat,
            },
            "ingredients": [
                {"name": ing.name, "amount": ing.amount, "unit": ing.unit}
                for ing in suggestion.ingredients
            ],
            "recipe_steps": [
                {"step": step.step, "instruction": step.instruction, "duration_minutes": step.duration_minutes}
                for step in suggestion.recipe_steps
            ],
            "prep_time_minutes": suggestion.prep_time_minutes,
            "confidence_score": suggestion.confidence_score,
            "status": suggestion.status.value,
            "generated_at": suggestion.generated_at.isoformat(),
        })

    def _deserialize_suggestion(self, data: str) -> MealSuggestion:
        """Deserialize JSON to suggestion object."""
        from datetime import datetime
        from src.domain.model.meal_suggestion import (
            MealType,
            SuggestionStatus,
            MacroEstimate,
            Ingredient,
            RecipeStep,
        )

        obj = json.loads(data)
        return MealSuggestion(
            id=obj["id"],
            session_id=obj["session_id"],
            user_id=obj["user_id"],
            meal_name=obj["meal_name"],
            description=obj["description"],
            meal_type=MealType(obj["meal_type"]),
            macros=MacroEstimate(**obj["macros"]),
            ingredients=[Ingredient(**ing) for ing in obj["ingredients"]],
            recipe_steps=[RecipeStep(**step) for step in obj["recipe_steps"]],
            prep_time_minutes=obj["prep_time_minutes"],
            confidence_score=obj["confidence_score"],
            status=SuggestionStatus(obj["status"]),
            generated_at=datetime.fromisoformat(obj["generated_at"]),
        )
</file>

<file path="src/infra/repositories/subscription_repository.py">
"""
Repository for managing subscription database operations.
"""
from datetime import datetime
from typing import Optional, List

from sqlalchemy import and_
from sqlalchemy.orm import Session

from src.infra.database.models.subscription import Subscription
from src.infra.repositories.base import BaseRepository


class SubscriptionRepository(BaseRepository[Subscription]):
    """Repository for subscription data operations."""
    
    def __init__(self, session: Session):
        super().__init__(Subscription, session)
    
    def find_all_by_user_id(self, user_id: str) -> List[Subscription]:
        """Find all subscriptions for a user."""
        return self.session.query(Subscription).filter(
            Subscription.user_id == user_id
        ).all()
    
    def get_by_user_id(self, user_id: str) -> List[Subscription]:
        """Get all subscriptions for a user (deprecated - use find_all_by_user_id)."""
        return self.find_all_by_user_id(user_id)
    
    def find_active_by_user_id(self, user_id: str) -> Optional[Subscription]:
        """Find active subscription for a user."""
        return self.session.query(Subscription).filter(
            and_(
                Subscription.user_id == user_id,
                Subscription.status == 'active'
            )
        ).first()
    
    def get_active_by_user_id(self, user_id: str) -> Optional[Subscription]:
        """Get active subscription for a user (deprecated - use find_active_by_user_id)."""
        return self.find_active_by_user_id(user_id)
    
    def find_by_revenuecat_id(self, revenuecat_subscriber_id: str) -> Optional[Subscription]:
        """Find subscription by RevenueCat ID."""
        return self.session.query(Subscription).filter(
            Subscription.revenuecat_subscriber_id == revenuecat_subscriber_id
        ).first()
    
    def get_by_revenuecat_id(self, revenuecat_subscriber_id: str) -> Optional[Subscription]:
        """Get subscription by RevenueCat subscriber ID (deprecated - use find_by_revenuecat_id)."""
        return self.find_by_revenuecat_id(revenuecat_subscriber_id)
    
    def get_expired_subscriptions(self) -> List[Subscription]:
        """Get all expired subscriptions that need status update."""
        return self.session.query(Subscription).filter(
            and_(
                Subscription.status == 'active',
                Subscription.expires_at < datetime.now()
            )
        ).all()
    
    def update_subscription_status(
        self, 
        subscription_id: str, 
        status: str,
        expires_at: Optional[datetime] = None
    ) -> Optional[Subscription]:
        """Update subscription status."""
        subscription = self.get(subscription_id)
        if subscription:
            subscription.status = status
            subscription.updated_at = datetime.now()
            if expires_at:
                subscription.expires_at = expires_at
            self.session.commit()
        return subscription
    
    # Async wrappers for compatibility
    async def get_by_user_id_async(self, user_id: str) -> List[Subscription]:
        """Async wrapper for get_by_user_id."""
        return self.get_by_user_id(user_id)
    
    async def get_by_revenuecat_id_async(self, revenuecat_subscriber_id: str) -> Optional[Subscription]:
        """Async wrapper for get_by_revenuecat_id."""
        return self.get_by_revenuecat_id(revenuecat_subscriber_id)
</file>

<file path="src/infra/services/ai/__init__.py">
"""AI services."""
from .openai_chat_service import OpenAIChatService
from .gemini_chat_service import GeminiChatService
from .llm_provider_factory import LLMProviderFactory, LLMProvider

__all__ = [
    "OpenAIChatService",
    "GeminiChatService",
    "LLMProviderFactory",
    "LLMProvider",
]
</file>

<file path="src/infra/services/ai/gemini_chat_service.py">
"""
Google Gemini implementation of AI chat service.
Refactored to use AIResponseParser and SystemPrompts.
"""
import logging
import os
from typing import List, Dict, Any, Optional, AsyncIterator

from src.domain.ports.ai_chat_service_port import AIChatServicePort
from src.infra.services.ai.prompts import SystemPrompts

logger = logging.getLogger(__name__)


class GeminiChatService(AIChatServicePort):
    """Google Gemini implementation of AI chat service for meal planning."""

    def __init__(
        self,
        api_key: Optional[str] = None,
        model: str = None,
        system_prompt: Optional[str] = None
    ):
        self.api_key = api_key or os.getenv("GOOGLE_API_KEY")
        self.model_name = model or os.getenv("GEMINI_MODEL", "gemini-2.5-flash")
        self.system_prompt = system_prompt or SystemPrompts.get_meal_planning_prompt()
        self.client = None

        if self.api_key:
            try:
                from langchain_google_genai import ChatGoogleGenerativeAI
                self.client = ChatGoogleGenerativeAI(
                    model=self.model_name,
                    temperature=0.7,
                    google_api_key=self.api_key,
                    convert_system_message_to_human=True
                )
                logger.info(f"Gemini chat service initialized with model {self.model_name}")
            except ImportError:
                logger.warning("langchain-google-genai package not installed. Install with: pip install langchain-google-genai")
            except Exception as e:
                logger.error(f"Failed to initialize Gemini client: {e}")
                logger.info(f"Tip: Using same model as food scanning: {self.model_name}")
        else:
            logger.warning("GOOGLE_API_KEY not set. AI responses will not be available.")

    def _get_client_for_temperature(self, temperature: float):
        """Get a client configured for the specified temperature."""
        if temperature == 0.7:
            return self.client

        from langchain_google_genai import ChatGoogleGenerativeAI
        return ChatGoogleGenerativeAI(
            model=self.model_name,
            temperature=temperature,
            google_api_key=self.api_key,
            convert_system_message_to_human=True
        )

    def _format_messages(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str]
    ) -> List:
        """
        Format messages for Gemini API.

        Args:
            messages: List of message dictionaries
            system_prompt: Optional system prompt to prepend

        Returns:
            List of formatted message objects
        """
        from langchain_core.messages import HumanMessage, SystemMessage, AIMessage

        formatted_messages = []

        # Add system prompt
        effective_prompt = system_prompt if system_prompt is not None else self.system_prompt
        if effective_prompt:
            formatted_messages.append(SystemMessage(content=effective_prompt))

        # Add conversation messages
        for msg in messages:
            role = msg.get("role", "user")
            content = msg.get("content", "")

            if role == "system":
                formatted_messages.append(SystemMessage(content=content))
            elif role == "user":
                formatted_messages.append(HumanMessage(content=content))
            elif role == "assistant":
                formatted_messages.append(AIMessage(content=content))

        return formatted_messages

    async def generate_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None
    ) -> Dict[str, Any]:
        """Generate AI response using Google Gemini API."""
        if not self.client:
            raise RuntimeError("Gemini client not initialized. Check API key.")

        # Validate temperature parameter
        if not 0 <= temperature <= 2:
            raise ValueError("temperature must be between 0 and 2")

        try:
            # Format messages
            formatted_messages = self._format_messages(messages, system_prompt)

            # Get client for temperature
            client = self._get_client_for_temperature(temperature)

            # Call Gemini API
            response = await client.ainvoke(formatted_messages)

            # Extract response content
            content = response.content if hasattr(response, 'content') else str(response)

            # Prepare metadata (Gemini doesn't provide token usage in same way as OpenAI)
            metadata = {
                "model": self.model_name,
                "usage": {
                    "prompt_tokens": 0,  # Gemini doesn't expose this easily
                    "completion_tokens": 0,
                    "total_tokens": 0
                },
                "finish_reason": "stop"
            }

            return {
                "content": content,
                "metadata": metadata
            }

        except Exception as e:
            logger.error(f"Error generating Gemini response: {e}")
            raise RuntimeError(f"Failed to generate AI response: {str(e)}")

    async def generate_streaming_response(
        self,
        messages: List[Dict[str, str]],
        system_prompt: Optional[str] = None,
        temperature: float = 0.7,
        max_tokens: Optional[int] = None
    ) -> AsyncIterator[Dict[str, Any]]:
        """Generate AI response with streaming chunks using Gemini API."""
        if not self.client:
            raise RuntimeError("Gemini client not initialized. Check API key.")

        # Validate temperature parameter
        if not 0 <= temperature <= 2:
            raise ValueError("temperature must be between 0 and 2")

        try:
            # Format messages
            formatted_messages = self._format_messages(messages, system_prompt)

            # Get client for temperature
            client = self._get_client_for_temperature(temperature)

            # Call Gemini API with streaming
            async for chunk in client.astream(formatted_messages):
                content = chunk.content if hasattr(chunk, 'content') else str(chunk)
                if content:
                    yield {
                        "chunk": content,
                        "metadata": {
                            "model": self.model_name,
                            "finish_reason": None
                        }
                    }

            # Final chunk with finish reason
            yield {
                "chunk": "",
                "metadata": {
                    "model": self.model_name,
                    "finish_reason": "stop"
                }
            }

        except Exception as e:
            logger.error(f"Error generating streaming Gemini response: {e}")
            raise RuntimeError(f"Failed to generate streaming AI response: {str(e)}")
</file>

<file path="src/infra/services/ai/llm_provider_factory.py">
"""
Factory for creating LLM provider adapters.
Supports multiple LLM providers (OpenAI, Gemini, etc.) with a unified interface.
"""
import logging
import os
from enum import Enum
from typing import Optional

from src.domain.ports.ai_chat_service_port import AIChatServicePort

logger = logging.getLogger(__name__)


class LLMProvider(str, Enum):
    """Supported LLM providers."""
    OPENAI = "openai"
    GEMINI = "gemini"
    # Add more providers as needed
    # ANTHROPIC = "anthropic"
    # COHERE = "cohere"


class LLMProviderFactory:
    """Factory for creating LLM provider instances."""
    
    @staticmethod
    def create_provider(
        provider: Optional[str] = None,
        api_key: Optional[str] = None,
        model: Optional[str] = None
    ) -> AIChatServicePort:
        """
        Create an LLM provider instance based on configuration.
        
        Args:
            provider: Provider name (openai, gemini). If None, auto-detects from available API keys.
            api_key: Optional API key. If None, reads from environment variables.
            model: Optional model name. Uses provider defaults if not specified.
            
        Returns:
            AIChatServicePort: Configured LLM provider instance
            
        Raises:
            ValueError: If no provider can be created (no API keys available)
            RuntimeError: If provider is specified but not available
        """
        # Auto-detect provider if not specified
        if not provider:
            provider = LLMProviderFactory._auto_detect_provider()
        
        provider = provider.lower()
        
        # Create provider instance
        if provider == LLMProvider.OPENAI.value:
            return LLMProviderFactory._create_openai_provider(api_key, model)
        elif provider == LLMProvider.GEMINI.value:
            return LLMProviderFactory._create_gemini_provider(api_key, model)
        else:
            raise ValueError(
                f"Unsupported LLM provider: {provider}. "
                f"Supported providers: {[p.value for p in LLMProvider]}"
            )
    
    @staticmethod
    def _auto_detect_provider() -> str:
        """
        Auto-detect provider based on available API keys.
        Priority: OpenAI > Gemini
        
        Returns:
            str: Provider name
            
        Raises:
            ValueError: If no API keys are available
        """
        openai_key = os.getenv("OPENAI_API_KEY")
        gemini_key = os.getenv("GOOGLE_API_KEY")
        
        if openai_key:
            logger.info("Auto-detected OpenAI provider (OPENAI_API_KEY found)")
            return LLMProvider.OPENAI.value
        elif gemini_key:
            logger.info("Auto-detected Gemini provider (GOOGLE_API_KEY found)")
            return LLMProvider.GEMINI.value
        else:
            raise ValueError(
                "No LLM provider API keys found. "
                "Please set OPENAI_API_KEY or GOOGLE_API_KEY environment variable, "
                "or specify LLM_PROVIDER environment variable."
            )
    
    @staticmethod
    def _create_openai_provider(
        api_key: Optional[str] = None,
        model: Optional[str] = None
    ) -> AIChatServicePort:
        """Create OpenAI provider instance."""
        from src.infra.services.ai.openai_chat_service import OpenAIChatService
        
        if not api_key:
            api_key = os.getenv("OPENAI_API_KEY")
        
        if not api_key:
            raise ValueError(
                "OpenAI API key not found. "
                "Please set OPENAI_API_KEY environment variable."
            )
        
        model = model or os.getenv("OPENAI_MODEL", "gpt-3.5-turbo")
        return OpenAIChatService(api_key=api_key, model=model)
    
    @staticmethod
    def _create_gemini_provider(
        api_key: Optional[str] = None,
        model: Optional[str] = None
    ) -> AIChatServicePort:
        """Create Gemini provider instance."""
        from src.infra.services.ai.gemini_chat_service import GeminiChatService
        
        if not api_key:
            api_key = os.getenv("GOOGLE_API_KEY")
        
        if not api_key:
            raise ValueError(
                "Google API key not found. "
                "Please set GOOGLE_API_KEY environment variable."
            )
        
        model = model or os.getenv("GEMINI_MODEL", "gemini-2.5-flash")
        return GeminiChatService(api_key=api_key, model=model)
</file>

<file path="src/infra/services/firebase_service.py">
"""
Firebase Admin SDK service for push notifications.
"""

import json
import logging
import os
from typing import Dict, List, Optional, Any

import firebase_admin
from firebase_admin import credentials, messaging

logger = logging.getLogger(__name__)


class NotificationChannelConfig:
    """Android notification channel configuration."""

    HIGH_PRIORITY_CHANNEL_ID = "high_priority_channel"
    MEDIUM_PRIORITY_CHANNEL_ID = "medium_priority_channel"
    LOW_PRIORITY_CHANNEL_ID = "low_priority_channel"


class FirebaseService:
    """Service for Firebase Admin SDK operations."""

    def __init__(self):
        """Initialize Firebase Admin SDK."""
        self._initialize_firebase()

    def _initialize_firebase(self):
        """Initialize Firebase Admin SDK if not already initialized."""
        try:
            # Check if Firebase is already initialized
            if not firebase_admin._apps:
                # Get service account key from environment
                service_account_key = self._get_service_account_key()

                if service_account_key:
                    # Initialize with service account key
                    cred = credentials.Certificate(service_account_key)
                    firebase_admin.initialize_app(cred)
                    logger.info("Firebase Admin SDK initialized successfully")
                else:
                    logger.warning(
                        "No Firebase service account key found. Push notifications will be disabled."
                    )
            else:
                logger.info("Firebase Admin SDK already initialized")
        except Exception as e:
            logger.error(f"Failed to initialize Firebase Admin SDK: {e}")
            raise e

    def _get_service_account_key(self) -> Optional[Dict[str, Any]]:
        """Get Firebase service account key from environment variables."""
        # Try to get from JSON string in environment variable
        service_account_json = os.getenv("FIREBASE_SERVICE_ACCOUNT_JSON")
        if service_account_json:
            try:
                return json.loads(service_account_json)
            except json.JSONDecodeError as e:
                logger.error(f"Invalid JSON in FIREBASE_SERVICE_ACCOUNT_JSON: {e}")
                return None

        # Try to get from file path
        service_account_path = os.getenv("FIREBASE_SERVICE_ACCOUNT_PATH")
        if service_account_path and os.path.exists(service_account_path):
            try:
                with open(service_account_path, "r") as f:
                    return json.load(f)
            except (json.JSONDecodeError, IOError) as e:
                logger.error(f"Error reading Firebase service account file: {e}")
                return None

        return None

    def send_notification(
        self,
        user_id: str,
        title: str,
        body: str,
        notification_type: str,
        data: Optional[Dict[str, str]] = None,
        tokens: Optional[List[str]] = None,
    ) -> Dict[str, Any]:
        """
        Send push notification to user's devices.

        Args:
            user_id: User ID (for logging purposes)
            title: Notification title
            body: Notification body
            notification_type: Type of notification
            data: Optional data payload
            tokens: List of FCM tokens (if not provided, will need to be fetched)

        Returns:
            Dictionary with success status and results
        """
        try:
            # Check if Firebase is initialized
            if firebase_admin._apps:
                # Prepare message data
                message_data = data or {}
                message_data["type"] = notification_type
                message_data["user_id"] = user_id

                if tokens:
                    # Send to specific tokens
                    return self._send_to_tokens(tokens, title, body, message_data)
                else:
                    logger.warning(f"No FCM tokens provided for user {user_id}")
                    return {"success": False, "reason": "no_tokens"}
            else:
                logger.warning(
                    "Firebase Admin SDK not initialized. Cannot send notification."
                )
                return {"success": False, "reason": "firebase_not_initialized"}

        except Exception as e:
            logger.error(f"Error sending notification to user {user_id}: {e}")
            return {"success": False, "reason": "error", "error": str(e)}

    def _send_to_tokens(
        self, tokens: List[str], title: str, body: str, data: Dict[str, str]
    ) -> Dict[str, Any]:
        """Send notification to specific FCM tokens."""
        try:
            # Ensure all data values are strings
            string_data = {k: str(v) for k, v in data.items()} if data else {}

            # Create multicast message
            message = messaging.MulticastMessage(
                notification=messaging.Notification(title=title, body=body),
                data=string_data,
                tokens=tokens,
                android=messaging.AndroidConfig(
                    priority="high",
                    notification=messaging.AndroidNotification(
                        channel_id=NotificationChannelConfig.HIGH_PRIORITY_CHANNEL_ID,
                        sound="default",
                    ),
                ),
                apns=messaging.APNSConfig(
                    payload=messaging.APNSPayload(
                        aps=messaging.Aps(
                            sound="default",
                            badge=1,
                            alert=messaging.ApsAlert(title=title, body=body),
                        )
                    )
                ),
            )

            # Send the message
            response = messaging.send_each_for_multicast(message)

            logger.info(
                f"Notification sent: {response.success_count} successful, {response.failure_count} failed"
            )

            # Handle failed tokens
            failed_tokens = []
            if response.failure_count > 0:
                for idx, result in enumerate(response.responses):
                    if not result.success:
                        error_code = "unknown_error"
                        if result.exception:
                            # Extract error code from exception
                            error_code = getattr(result.exception, "code", None)
                            if error_code is None:
                                error_code = type(result.exception).__name__

                        failed_tokens.append(
                            {"token": tokens[idx], "error": error_code}
                        )
                        logger.warning(f"Failed to send to token {idx}: {error_code}")

            return {
                "success": True,
                "sent": response.success_count,
                "failed": response.failure_count,
                "failed_tokens": failed_tokens,
            }

        except Exception as e:
            logger.error(f"Error sending multicast message: {e}")
            return {"success": False, "reason": "send_error", "error": str(e)}

    def send_to_topic(
        self, topic: str, title: str, body: str, data: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """
        Send notification to a topic.

        Args:
            topic: Firebase topic name
            title: Notification title
            body: Notification body
            data: Optional data payload

        Returns:
            Dictionary with success status and results
        """
        try:
            if not firebase_admin._apps:
                return {"success": False, "reason": "firebase_not_initialized"}

            # Prepare message data
            message_data = data or {}
            message_data["topic"] = topic

            # Create message
            message = messaging.Message(
                notification=messaging.Notification(title=title, body=body),
                data=message_data,
                topic=topic,
                android=messaging.AndroidConfig(
                    priority="high",
                    notification=messaging.AndroidNotification(
                        channel_id=NotificationChannelConfig.HIGH_PRIORITY_CHANNEL_ID,
                        sound="default",
                    ),
                ),
                apns=messaging.APNSConfig(
                    payload=messaging.APNSPayload(
                        aps=messaging.Aps(
                            sound="default",
                            badge=1,
                            alert=messaging.ApsAlert(title=title, body=body),
                        )
                    )
                ),
            )

            # Send the message
            response = messaging.send(message)

            logger.info(f"Topic notification sent successfully: {response}")

            return {"success": True, "message_id": response}

        except Exception as e:
            logger.error(f"Error sending topic notification: {e}")
            return {"success": False, "reason": "send_error", "error": str(e)}

    def is_initialized(self) -> bool:
        """Check if Firebase Admin SDK is initialized."""
        return len(firebase_admin._apps) > 0
</file>

<file path="src/infra/services/pinecone_service.py">
"""
Pinecone Meal Nutrition Service

Integrates Pinecone vector search for ingredient lookup with nutrition scaling.
Based on the MVP implementation from my-python-repo/mvp/meal_nutrition.py
"""

import os
from dataclasses import dataclass
from typing import Dict, Optional

from pinecone import Pinecone


@dataclass
class NutritionData:
    """Nutrition per serving"""
    calories: float = 0
    protein: float = 0
    fat: float = 0
    carbs: float = 0
    fiber: float = 0
    sugar: float = 0
    sodium: float = 0
    serving_size_g: float = 100

    def scale_to(self, grams: float) -> 'NutritionData':
        """Scale nutrition to specific amount in grams"""
        if self.serving_size_g == 0:
            return self
        factor = grams / self.serving_size_g
        return NutritionData(
            calories=self.calories * factor,
            protein=self.protein * factor,
            fat=self.fat * factor,
            carbs=self.carbs * factor,
            fiber=self.fiber * factor,
            sugar=self.sugar * factor,
            sodium=self.sodium * factor,
            serving_size_g=grams
        )


class PineconeNutritionService:
    """Service for searching ingredients and calculating nutrition using Pinecone"""

    def __init__(self, pinecone_api_key: Optional[str] = None):
        api_key = pinecone_api_key or os.getenv("PINECONE_API_KEY")
        if not api_key:
            raise ValueError("PINECONE_API_KEY must be provided or set in environment")

        self.pc = Pinecone(api_key=api_key)
        # No encoder needed - use Pinecone inference API

        # Connect to existing indexes
        try:
            self.ingredients_index = self.pc.Index("ingredients")
        except Exception:
            self.ingredients_index = None

        try:
            self.usda_index = self.pc.Index("usda")
        except Exception:
            self.usda_index = None

        if not self.ingredients_index and not self.usda_index:
            raise ValueError("No Pinecone indexes available. Ensure 'ingredients' or 'usda' index exists.")

        # Unit conversion table
        self.unit_conversions = {
            'g': 1, 'gram': 1, 'grams': 1,
            'kg': 1000, 'oz': 28.35, 'lb': 453.59,
            'cup': 240, 'cups': 240,
            'tbsp': 15, 'tablespoon': 15,
            'tsp': 5, 'teaspoon': 5,
            'serving': 100
        }

    def _embed_text(
        self, texts: list[str], input_type: str = "query"
    ) -> list[list[float]]:
        """
        Generate embeddings using Pinecone Inference API.

        Args:
            texts: List of text strings to embed
            input_type: "query" for search queries, "passage" for documents

        Returns:
            List of embedding vectors (1024 dimensions each)
        """
        embeddings = self.pc.inference.embed(
            model="llama-text-embed-v2",
            inputs=texts,
            parameters={
                "input_type": input_type,
                "truncate": "END"
            }
        )
        return [e["values"] for e in embeddings]

    def search_ingredient(self, query: str) -> Optional[Dict]:
        """
        Search for ingredient in Pinecone indexes using vector similarity.
        Returns nutrition data per 100g if found.
        """
        best_result = None
        best_score = 0

        # Generate embedding for search query using Pinecone Inference API
        query_embedding = self._embed_text([query], input_type="query")[0]

        # Try ingredients index first (better per-100g data)
        if self.ingredients_index:
            try:
                results = self.ingredients_index.query(
                    vector=query_embedding,
                    top_k=1,
                    include_metadata=True
                )

                if results and 'matches' in results and results['matches']:
                    match = results['matches'][0]
                    if match['score'] > 0.35:
                        best_result = match
                        best_score = match['score']
            except Exception as e:
                print(f"Ingredients index query failed: {e}")

        # Try USDA if no good match
        if self.usda_index and best_score < 0.6:
            try:
                results = self.usda_index.query(
                    vector=query_embedding,
                    top_k=1,
                    include_metadata=True
                )

                if results and 'matches' in results and results['matches']:
                    if results['matches'][0]['score'] > best_score * 1.2:
                        best_result = results['matches'][0]
            except Exception as e:
                print(f"USDA index query failed: {e}")

        if best_result:
            metadata = best_result['metadata']
            return {
                'name': metadata.get('name', query),
                'score': best_result['score'],
                'calories': float(metadata.get('calories', 0)),
                'protein': float(metadata.get('protein', 0)),
                'fat': float(metadata.get('fat', 0)),
                'carbs': float(metadata.get('carbs', 0)),
                'fiber': float(metadata.get('fiber', 0)),
                'sugar': float(metadata.get('sugar', 0)),
                'sodium': float(metadata.get('sodium', 0)),
                'serving_size': metadata.get('serving_size', '100g')
            }

        return None

    def convert_to_grams(self, quantity: float, unit: str) -> float:
        """Convert quantity in any unit to grams"""
        unit_lower = unit.lower()
        conversion_factor = self.unit_conversions.get(unit_lower, 1)
        return quantity * conversion_factor

    def get_scaled_nutrition(
        self, 
        ingredient_name: str, 
        quantity: float, 
        unit: str
    ) -> Optional[NutritionData]:
        """
        Search for ingredient and return nutrition scaled to the specified portion.
        
        Args:
            ingredient_name: Name of the ingredient to search
            quantity: Amount of the ingredient
            unit: Unit of measurement (g, kg, cup, etc.)
            
        Returns:
            NutritionData scaled to the specified portion, or None if not found
        """
        # Search for ingredient
        result = self.search_ingredient(ingredient_name)
        if not result:
            return None

        # Create base nutrition (per 100g)
        base_nutrition = NutritionData(
            calories=result['calories'],
            protein=result['protein'],
            fat=result['fat'],
            carbs=result['carbs'],
            fiber=result['fiber'],
            sugar=result['sugar'],
            sodium=result['sodium'],
            serving_size_g=100
        )

        # Convert to grams and scale
        grams = self.convert_to_grams(quantity, unit)
        return base_nutrition.scale_to(grams)

    def calculate_total_nutrition(
        self, 
        ingredients: list[Dict]
    ) -> NutritionData:
        """
        Calculate total nutrition from a list of ingredients.
        
        Args:
            ingredients: List of dicts with 'name', 'quantity', 'unit'
            
        Returns:
            Total NutritionData summed across all ingredients
        """
        total = NutritionData(serving_size_g=0)

        for ingredient in ingredients:
            nutrition = self.get_scaled_nutrition(
                ingredient['name'],
                ingredient['quantity'],
                ingredient['unit']
            )
            
            if nutrition:
                total.calories += nutrition.calories
                total.protein += nutrition.protein
                total.fat += nutrition.fat
                total.carbs += nutrition.carbs
                total.fiber += nutrition.fiber
                total.sugar += nutrition.sugar
                total.sodium += nutrition.sodium
                total.serving_size_g += nutrition.serving_size_g

        return total


# Singleton instance (lazy initialization)
_pinecone_service_instance: Optional[PineconeNutritionService] = None


def get_pinecone_service() -> PineconeNutritionService:
    """Get or create singleton instance of PineconeNutritionService"""
    global _pinecone_service_instance
    if _pinecone_service_instance is None:
        _pinecone_service_instance = PineconeNutritionService()
    return _pinecone_service_instance
</file>

<file path="src/infra/services/scheduled_notification_service.py">
"""
Scheduled notification service for sending push notifications at specific times.
"""
import asyncio
import logging
from datetime import datetime, timezone
from typing import Dict, List

from src.domain.model.notification import NotificationType
from src.domain.ports.notification_repository_port import NotificationRepositoryPort
from src.domain.services.notification_service import NotificationService

logger = logging.getLogger(__name__)


class ScheduledNotificationService:
    """Service for scheduling and sending notifications at specific times."""

    # Scheduling constants
    SCHEDULING_LOOP_INTERVAL_SECONDS = 60
    SCHEDULING_LOOP_ERROR_RETRY_SECONDS = 30
    WATER_REMINDER_MAX_BATCH_SIZE = 10

    def __init__(
        self,
        notification_repository: NotificationRepositoryPort,
        notification_service: NotificationService
    ):
        self.notification_repository = notification_repository
        self.notification_service = notification_service
        self._running = False
        self._tasks: List[asyncio.Task] = []
    
    async def start(self):
        """Start the scheduled notification service."""
        if self._running:
            logger.warning("Scheduled notification service is already running")
            return
        
        self._running = True
        logger.info("Starting scheduled notification service")
        
        # Start the main scheduling loop
        task = asyncio.create_task(self._scheduling_loop())
        self._tasks.append(task)
        
        logger.info("Scheduled notification service started")
    
    async def stop(self):
        """Stop the scheduled notification service."""
        if not self._running:
            logger.warning("Scheduled notification service is not running")
            return
        
        self._running = False
        logger.info("Stopping scheduled notification service")
        
        # Cancel all tasks
        for task in self._tasks:
            if not task.done():
                task.cancel()
        
        # Wait for tasks to complete
        if self._tasks:
            await asyncio.gather(*self._tasks, return_exceptions=True)
        
        self._tasks.clear()
        logger.info("Scheduled notification service stopped")
    
    async def _scheduling_loop(self):
        """Main scheduling loop that runs every minute."""
        while self._running:
            try:
                current_time = datetime.now(timezone.utc)
                await self._check_and_send_notifications(current_time)

                # Wait for next check
                await asyncio.sleep(self.SCHEDULING_LOOP_INTERVAL_SECONDS)

            except asyncio.CancelledError:
                logger.info("Scheduling loop cancelled")
                break
            except Exception as e:
                logger.error(f"Error in scheduling loop: {e}")
                # Wait a bit before retrying
                await asyncio.sleep(self.SCHEDULING_LOOP_ERROR_RETRY_SECONDS)
    
    async def _check_and_send_notifications(self, current_time: datetime):
        """Check if any notifications need to be sent at the current time."""
        try:
            # Check meal reminders (pass full datetime)
            await self._check_meal_reminders(current_time)

            # Check sleep reminders (pass full datetime)
            await self._check_sleep_reminders(current_time)

            # Check water reminders (based on user intervals)
            await self._check_water_reminders(current_time)
                
        except Exception as e:
            logger.error(f"Error checking notifications: {e}")
    
    async def _check_meal_reminders(self, current_utc: datetime):
        """Check if any users need meal reminders at the current UTC time."""
        try:
            meal_types = ["breakfast", "lunch", "dinner"]
            
            for meal_type in meal_types:
                user_ids = self.notification_repository.find_users_for_meal_reminder(
                    meal_type, current_utc  # Pass datetime, not minutes
                )
                
                for user_id in user_ids:
                    try:
                        result = await self.notification_service.send_meal_reminder(
                            user_id, meal_type
                        )
                        
                        if result.get("success"):
                            logger.info(f"Meal reminder sent to user {user_id} for {meal_type}")
                        else:
                            logger.warning(f"Failed to send meal reminder to user {user_id}: {result}")
                            
                    except Exception as e:
                        logger.error(f"Error sending meal reminder to user {user_id}: {e}")
                        
        except Exception as e:
            logger.error(f"Error checking meal reminders: {e}")
    
    async def _check_sleep_reminders(self, current_utc: datetime):
        """Check if any users need sleep reminders at the current UTC time."""
        try:
            user_ids = self.notification_repository.find_users_for_sleep_reminder(
                current_utc  # Pass datetime, not minutes
            )
            
            for user_id in user_ids:
                try:
                    result = await self.notification_service.send_sleep_reminder(user_id)
                    
                    if result.get("success"):
                        logger.info(f"Sleep reminder sent to user {user_id}")
                    else:
                        logger.warning(f"Failed to send sleep reminder to user {user_id}: {result}")
                        
                except Exception as e:
                    logger.error(f"Error sending sleep reminder to user {user_id}: {e}")
                    
        except Exception as e:
            logger.error(f"Error checking sleep reminders: {e}")
    
    async def _check_water_reminders(self, current_utc: datetime):
        """Check if any users need water reminders based on their interval."""
        try:
            user_ids = self.notification_repository.find_users_for_water_reminder(current_utc)

            # Limit to avoid sending too many at once
            limited_user_ids = user_ids[:self.WATER_REMINDER_MAX_BATCH_SIZE]
            
            for user_id in limited_user_ids:
                try:
                    result = await self.notification_service.send_water_reminder(user_id)
                    
                    if result.get("success"):
                        # Update last sent timestamp
                        self.notification_repository.update_last_water_reminder(user_id, current_utc)
                        logger.info(f"Water reminder sent to user {user_id}")
                    else:
                        logger.warning(f"Failed to send water reminder to user {user_id}: {result}")
                        
                except Exception as e:
                    logger.error(f"Error sending water reminder to user {user_id}: {e}")
                    
        except Exception as e:
            logger.error(f"Error checking water reminders: {e}")
    
    async def send_test_notification(
        self,
        user_id: str,
        notification_type: str = "test"
    ) -> Dict[str, any]:
        """Send a test notification to a user."""
        try:
            result = await self.notification_service.send_notification(
                user_id=user_id,
                title="🧪 Test Notification",
                body="This is a test notification from the backend",
                notification_type=NotificationType.PROGRESS_NOTIFICATION,
                data={"type": "test", "timestamp": datetime.now().isoformat()}
            )
            
            logger.info(f"Test notification sent to user {user_id}: {result}")
            return result
            
        except Exception as e:
            logger.error(f"Error sending test notification to user {user_id}: {e}")
            return {"success": False, "error": str(e)}
    
    def is_running(self) -> bool:
        """Check if the service is running."""
        return self._running
</file>

<file path="src/api/dependencies/auth.py">
"""
Authentication dependencies for FastAPI.

Provides Firebase token verification and user extraction.
"""

import logging
import os
from typing import Optional

from fastapi import Depends, HTTPException, Request, status
from fastapi.security import HTTPAuthorizationCredentials, HTTPBearer
from firebase_admin import auth as firebase_auth
from sqlalchemy.orm import Session

from src.infra.database.config import get_db

logger = logging.getLogger(__name__)

# Security scheme for OpenAPI documentation (auto_error=False for dev bypass)
security = HTTPBearer(auto_error=False)


async def verify_firebase_token(
    request: Request,
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(security),
) -> dict:
    """
    Verify Firebase ID token and return decoded token.

    In development mode (ENVIRONMENT=development), bypasses Firebase verification
    and uses the dev user injected by middleware.

    This dependency extracts and verifies the Firebase ID token from the
    Authorization header. It should be used as a dependency for all
    protected endpoints.

    Args:
        request: FastAPI request object
        credentials: HTTP Bearer token credentials (optional in dev mode)

    Returns:
        Decoded Firebase token containing user information

    Raises:
        HTTPException: If token is invalid, expired, or revoked

    Example:
        @router.get("/protected")
        async def protected_endpoint(
            token: dict = Depends(verify_firebase_token)
        ):
            user_id = token['uid']
            return {"message": f"Hello {user_id}"}
    """
    # Dev mode bypass: check if dev middleware injected a user
    if (os.getenv("ENVIRONMENT") == "development" and 
        hasattr(request.state, "user") and
        hasattr(request.state.user, "firebase_uid") and
        hasattr(request.state.user, "id")):
        dev_user = request.state.user
        # Additional check: make sure it's not a Mock object
        if type(dev_user).__name__ != "Mock":
            logger.debug("Dev mode: bypassing Firebase auth, using dev user: %s", dev_user.id)
            return {
                "uid": dev_user.firebase_uid,
                "email": dev_user.email,
                "sub": dev_user.firebase_uid
            }

    # Production mode: require Firebase token
    if not credentials:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Not authenticated",
            headers={"WWW-Authenticate": "Bearer"},
        )

    token = credentials.credentials

    try:
        # Verify the Firebase ID token
        decoded_token = firebase_auth.verify_id_token(token)
        logger.debug(
            "Successfully verified token for user: %s", decoded_token.get("uid")
        )
        return decoded_token

    except firebase_auth.ExpiredIdTokenError as e:
        logger.warning("Expired Firebase token: %s", str(e))
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication token has expired",
            headers={"WWW-Authenticate": "Bearer"},
        ) from e
    except firebase_auth.RevokedIdTokenError as e:
        logger.warning("Revoked Firebase token: %s", str(e))
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Authentication token has been revoked",
            headers={"WWW-Authenticate": "Bearer"},
        ) from e
    except firebase_auth.InvalidIdTokenError as e:
        logger.warning("Invalid Firebase token: %s", str(e))
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        ) from e
    except firebase_auth.CertificateFetchError as e:
        logger.error("Failed to fetch Firebase certificates: %s", str(e))
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Authentication service temporarily unavailable",
        ) from e
    except Exception as e:
        logger.error("Unexpected error verifying Firebase token: %s", str(e))
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Failed to verify authentication token",
            headers={"WWW-Authenticate": "Bearer"},
        ) from e


async def get_current_user_id(
    token: dict = Depends(verify_firebase_token),
    db: Session = Depends(get_db)
) -> str:
    """
    Extract the authenticated user's database ID from the verified Firebase token.

    This dependency:
    1. Extracts the Firebase UID from the verified token
    2. Looks up the user in the database by firebase_uid
    3. Returns the database user.id (UUID primary key)

    This ensures that the user_id matches what's expected by all database queries.

    Args:
        token: Verified Firebase token (injected by verify_firebase_token)
        db: Database session (injected by get_db)

    Returns:
        The authenticated user's database ID (UUID)

    Raises:
        HTTPException: If token is invalid or user not found in database

    Example:
        @router.get("/profile")
        async def get_profile(
            user_id: str = Depends(get_current_user_id)
        ):
            return {"user_id": user_id}
    """
    firebase_uid = token.get("uid")
    if not firebase_uid:
        logger.error("Firebase token missing 'uid' field")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Invalid token: missing user identifier",
        )
    
    # Look up user in database by firebase_uid (only active users)
    from src.infra.database.models.user.user import User
    user = db.query(User).filter(
        User.firebase_uid == firebase_uid,
        User.is_active == True  # CRITICAL: Block deleted/inactive users from authenticating
    ).first()

    if not user:
        logger.warning("Active user with Firebase UID not found in database")
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail={
                "error_code": "USER_NOT_FOUND",
                "message": "User not found or account has been deleted.",
                "details": {
                    "hint": "If your account was deleted, you cannot log in. If you're a new user, call POST /v1/users/sync to create your account."
                }
            }
        )
    
    return user.id


async def get_current_user_email(
    token: dict = Depends(verify_firebase_token),
) -> Optional[str]:
    """
    Extract the authenticated user's email from the verified Firebase token.

    Args:
        token: Verified Firebase token (injected by verify_firebase_token)

    Returns:
        The authenticated user's email, or None if not available
    """
    return token.get("email")


async def optional_authentication(
    credentials: Optional[HTTPAuthorizationCredentials] = Depends(
        HTTPBearer(auto_error=False)
    ),
) -> Optional[dict]:
    """
    Optional authentication dependency for endpoints that work with or without auth.

    Returns None if no credentials provided, otherwise verifies and returns token.

    Args:
        credentials: Optional HTTP Bearer token credentials

    Returns:
        Decoded Firebase token if credentials provided, None otherwise

    Example:
        @router.get("/public-or-private")
        async def endpoint(
            token: Optional[dict] = Depends(optional_authentication)
        ):
            if token:
                return {"message": "Authenticated", "user_id": token['uid']}
            else:
                return {"message": "Anonymous"}
    """
    if not credentials:
        return None

    try:
        decoded_token = firebase_auth.verify_id_token(credentials.credentials)
        return decoded_token
    except Exception as e:
        logger.debug("Optional auth failed: %s", str(e))
        return None
</file>

<file path="src/api/middleware/dev_auth_bypass.py">
import logging
import os
import uuid
from datetime import datetime, timezone
from types import SimpleNamespace
from typing import Optional

from fastapi import FastAPI, Request

from src.infra.database.config import SessionLocal
from src.infra.database.models.enums import MealStatusEnum
from src.infra.database.models.meal.meal import Meal as DBMeal
from src.infra.database.models.meal.meal_image import MealImage as DBMealImage
from src.infra.database.models.nutrition.nutrition import Nutrition as DBNutrition
from src.infra.database.models.user.profile import UserProfile
from src.infra.database.models.user.user import User

logger = logging.getLogger(__name__)


def _ensure_dev_user() -> Optional[User]:
    """Create or fetch the single development user and profile.

    This is safe to call multiple times. Returns the persisted SQLAlchemy User instance
    loaded from a short-lived session; do not store it for reuse across requests.

    Returns None if database isn't ready (e.g., during test collection).
    """
    firebase_uid = os.getenv("DEV_USER_FIREBASE_UID", "dev_firebase_uid")
    email = os.getenv("DEV_USER_EMAIL", "dev@example.com")
    username = os.getenv("DEV_USER_USERNAME", "dev_user")

    session = SessionLocal()
    try:
        user: Optional[User] = (
            session.query(User).filter(User.firebase_uid == firebase_uid).first()
        )

        if user:
            return user

        # Create new dev user
        user = User(
            firebase_uid=firebase_uid,
            email=email,
            username=username,
            first_name="Dev",
            last_name="User",
            password_hash="dev_password_placeholder",
            is_active=True,
            onboarding_completed=True,
        )
        session.add(user)
        session.flush()

        # Create a basic current profile
        profile = UserProfile(
            user_id=user.id,
            age=30,
            gender="male",
            height_cm=175.0,
            weight_kg=70.0,
            body_fat_percentage=18.0,
            is_current=True,
            activity_level="moderate",
            fitness_goal="maintenance",
            target_weight_kg=70.0,
            meals_per_day=3,
            snacks_per_day=1,
            dietary_preferences=[],
            health_conditions=[],
            allergies=[],
            pain_points=[],
        )
        session.add(profile)
        session.commit()

        logger.info("Created development user '%s' (%s)", username, user.id)
        return user
    except Exception as exc:
        session.rollback()
        logger.warning("Failed to ensure dev user (database may not be ready): %s", exc)
        return None
    finally:
        session.close()


def add_dev_auth_bypass(app: FastAPI) -> None:
    """Install a dev-only middleware that sets request.state.user.

    The injected user has an `id` attribute and an `is_premium()` method that returns True
    so premium-only endpoints work in development.
    """
    if os.getenv("ENVIRONMENT") != "development":
        logger.info("Dev auth bypass not enabled (ENVIRONMENT != development)")
        return

    # Try to ensure the user exists up-front and seed meals (may fail during test collection)
    user = _ensure_dev_user()
    if user:
        _seed_dev_meals(user.id)
    else:
        logger.warning("Dev user creation deferred - will create on first request")

    @app.middleware("http")
    async def dev_user_injector(request: Request, call_next):  # type: ignore[override]
        # Load fresh per request to avoid cross-session ORM usage
        session = SessionLocal()
        try:
            firebase_uid = os.getenv("DEV_USER_FIREBASE_UID", "dev_firebase_uid")
            user: Optional[User] = (
                session.query(User).filter(User.firebase_uid == firebase_uid).first()
            )

            if user is None:
                user = _ensure_dev_user()

            # Provide only what downstream code expects
            request.state.user = SimpleNamespace(
                id=user.id,
                firebase_uid=user.firebase_uid,
                email=user.email,
                username=user.username,
                is_premium=lambda: True,
            )
        finally:
            session.close()

        return await call_next(request)


def _seed_dev_meals(user_id: str) -> None:
    """Seed a small set of meals with nutrition for today's date if none exist.
    Creates breakfast, lunch, dinner with simple nutrition totals so daily macros works.
    """
    session = SessionLocal()
    try:
        # Check if there are any meals today for this user
        from datetime import date, timedelta
        today = date.today()
        start_dt = datetime.combine(today, datetime.min.time())
        end_dt = start_dt + timedelta(days=1)

        existing = (
            session.query(DBMeal)
            .filter(DBMeal.user_id == user_id)
            .filter(DBMeal.created_at >= start_dt)
            .filter(DBMeal.created_at < end_dt)
            .count()
        )
        if existing > 0:
            # Backfill missing ready_at for READY meals created earlier without it
            meals_missing_ready = (
                session.query(DBMeal)
                .filter(DBMeal.user_id == user_id)
                .filter(DBMeal.created_at >= start_dt)
                .filter(DBMeal.created_at < end_dt)
                .filter(DBMeal.status == MealStatusEnum.READY)
                .filter(DBMeal.ready_at.is_(None))
                .all()
            )
            if meals_missing_ready:
                now = datetime.now(timezone.utc)
                for m in meals_missing_ready:
                    m.ready_at = m.created_at or now
                    m.updated_at = now
                session.commit()
            return

        def create_meal(meal_name: str, calories: float, p: float, c: float, f: float):
            meal_id = str(uuid.uuid4())
            image_id = str(uuid.uuid4())
            # Minimal image row (FK is required)
            db_image = DBMealImage(
                image_id=image_id,
                format="jpeg",
                size_bytes=12345,
                width=800,
                height=600,
                url=None,
            )
            session.add(db_image)

            now = datetime.now(timezone.utc)
            db_meal = DBMeal(
                meal_id=meal_id,
                user_id=user_id,
                status=MealStatusEnum.READY,
                dish_name=meal_name,
                image_id=image_id,
                created_at=now,
                updated_at=now,
                ready_at=now,
            )
            session.add(db_meal)

            db_nutrition = DBNutrition(
                calories=calories,
                protein=p,
                carbs=c,
                fat=f,
                confidence_score=0.95,
                meal_id=meal_id,
            )
            session.add(db_nutrition)

        # Seed three meals
        create_meal("Breakfast Oatmeal", 420.0, 20.0, 60.0, 10.0)
        create_meal("Chicken Salad Lunch", 650.0, 50.0, 30.0, 30.0)
        create_meal("Salmon Dinner", 700.0, 45.0, 40.0, 35.0)

        session.commit()
        logger.info("Seeded dev meals for user %s", user_id)
    except Exception as exc:
        session.rollback()
        logger.error("Failed to seed dev meals: %s", exc)
    finally:
        session.close()
</file>

<file path="src/api/routes/v1/meals.py">
"""
Meals API endpoints using event-driven architecture.
Clean separation with event bus pattern.
"""
import logging
from datetime import datetime
from typing import Optional

from fastapi import APIRouter, Depends, File, UploadFile, Query, status

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception, ValidationException
from src.api.mappers.meal_mapper import MealMapper
from src.api.schemas.request.meal_requests import (
    EditMealIngredientsRequest,
    CreateManualMealFromFoodsRequest
)
from src.api.schemas.response import (
    DetailedMealResponse,
    ManualMealCreationResponse
)
from src.api.schemas.response.daily_nutrition_response import DailyNutritionResponse
from src.app.commands.meal import (
    EditMealCommand,
    FoodItemChange,
    CustomNutritionData
)
from src.app.commands.meal.delete_meal_command import DeleteMealCommand
from src.app.commands.meal.upload_meal_image_immediately_command import UploadMealImageImmediatelyCommand
from src.app.commands.meal.create_manual_meal_command import (
    CreateManualMealCommand,
    ManualMealItem,
)
from src.app.queries.meal import (
    GetMealByIdQuery,
    GetDailyMacrosQuery
)
from src.infra.adapters.cloudinary_image_store import CloudinaryImageStore
from src.infra.event_bus import EventBus

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/v1/meals", tags=["Meals"])



# File upload constraints
MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB
ALLOWED_CONTENT_TYPES = ["image/jpeg", "image/png", "image/jpg"]

# Status mapping from domain to API
STATUS_MAPPING = {
    "PROCESSING": "pending",
    "ANALYZING": "analyzing", 
    "ENRICHING": "analyzing",  # Map to analyzI mean ing since API doesn't have enriching
    "READY": "ready",
    "FAILED": "failed",
    "INACTIVE": "inactive",
}



@router.post("/image/analyze", status_code=status.HTTP_200_OK, response_model=DetailedMealResponse)
async def analyze_meal_image_immediate(
    file: UploadFile = File(...),
    user_id: str = Depends(get_current_user_id),
    target_date: Optional[str] = Query(None, description="Target date in YYYY-MM-DD format for meal association"),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Send meal photo and return immediate meal analysis with nutritional data.
    
    This endpoint processes the image and returns complete nutritional analysis
    synchronously without background processing. Use this when you need 
    immediate results.
    
    - Accepts image/jpeg or image/png files up to 8MB
    - Returns complete meal analysis immediately
    - Processing time may be longer than the background version
    - Recommended for interactive use cases
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Validate content type
        if file.content_type not in ALLOWED_CONTENT_TYPES:
            raise ValidationException(
                message=f"Invalid file type. Only {', '.join(ALLOWED_CONTENT_TYPES)} are allowed.",
                error_code="INVALID_FILE_TYPE",
                details={"content_type": file.content_type, "allowed": ALLOWED_CONTENT_TYPES}
            )
        
        # Read file content
        contents = await file.read()
        
        # Validate file size
        if len(contents) > MAX_FILE_SIZE:
            raise ValidationException(
                message=f"File size exceeds maximum allowed ({MAX_FILE_SIZE // (1024*1024)} MB)",
                error_code="FILE_SIZE_EXCEEDS_MAXIMUM",
                details={"size": len(contents), "max_size": MAX_FILE_SIZE}
            )
        
        # Parse target date if provided
        parsed_target_date = None
        if target_date:
            try:
                parsed_target_date = datetime.strptime(target_date, "%Y-%m-%d").date()
                logger.info("Target date specified: %s", parsed_target_date)
            except ValueError as e:
                raise ValidationException(
                    message="Invalid date format. Use YYYY-MM-DD format.",
                    error_code="INVALID_DATE_FORMAT",
                    details={"date": target_date}
                ) from e
        
        # Process the upload and analysis immediately
        logger.info("Processing meal photo for immediate analysis (target_date: %s)", parsed_target_date)
        
        command = UploadMealImageImmediatelyCommand(
            user_id=user_id,
            file_contents=contents,
            content_type=file.content_type,
            target_date=parsed_target_date
        )
        
        logger.info("Uploading and analyzing meal immediately")
        meal = await event_bus.send(command)
        
        logger.info("Immediate analysis completed for meal ID: %s, status: %s", meal.meal_id, meal.status)
        
        # Check if analysis was successful
        if meal.status.value == "FAILED":
            error_message = meal.error_message or "Analysis failed"
            logger.error("Immediate analysis failed: %s", error_message)
            raise ValidationException(
                message=f"Failed to analyze meal image: {error_message}",
                error_code="FAILED_TO_ANALYZE_MEAL_IMAGE",
                details={"error_message": error_message}
            )
        
        # Get the image URL if available
        image_url = None
        if meal.image:
            # Try to get URL from image store
            image_store = CloudinaryImageStore()
            image_url = image_store.get_url(meal.image.image_id)
        
        # Return the detailed meal response using mapper
        return MealMapper.to_detailed_response(meal, image_url)

    except Exception as e:
        raise handle_exception(e) from e


@router.post("/manual", response_model=ManualMealCreationResponse)
async def create_manual_meal(
    payload: CreateManualMealFromFoodsRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus),
) -> ManualMealCreationResponse:
    """
    Create a manual meal from USDA FDC items.

    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        items = [
            ManualMealItem(fdc_id=i.fdc_id, quantity=i.quantity, unit=i.unit)
            for i in payload.items
        ]

        # Parse target_date if provided
        target_date = None
        if payload.target_date:
            try:
                target_date = datetime.strptime(payload.target_date, "%Y-%m-%d").date()
            except ValueError as e:
                raise ValidationException(
                    message="Invalid date format. Use YYYY-MM-DD",
                    error_code="INVALID_DATE_FORMAT",
                    details={"date": payload.target_date}
                ) from e

        cmd = CreateManualMealCommand(
            user_id=user_id,
            items=items,
            dish_name=payload.dish_name,
            meal_type=payload.meal_type,
            target_date=target_date,
        )
        meal = await event_bus.send(cmd)

        return ManualMealCreationResponse(
            meal_id=meal.meal_id,
            status="success",
            message=f"Meal '{payload.dish_name}' created successfully",
            created_at=meal.created_at,
        )
    except Exception as e:
        raise handle_exception(e) from e


@router.get("/{meal_id}", response_model=DetailedMealResponse)
async def get_meal(
    meal_id: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """Get detailed information about a specific meal."""
    try:
        # Send query
        query = GetMealByIdQuery(meal_id=meal_id)
        meal = await event_bus.send(query)
        
        # Get image URL if available
        image_url = None
        if meal.image:
            image_store = CloudinaryImageStore()
            image_url = image_store.get_url(meal.image.image_id)
        
        # Use mapper to convert to response
        return MealMapper.to_detailed_response(meal, image_url)
        
    except Exception as e:
        raise handle_exception(e) from e
@router.delete("/{meal_id}")
async def delete_meal(
    meal_id: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """Mark a meal as INACTIVE (soft delete)."""
    try:
        command = DeleteMealCommand(meal_id=meal_id)
        result = await event_bus.send(command)
        return result
    except Exception as e:
        raise handle_exception(e) from e



@router.get("/daily/macros", response_model=DailyNutritionResponse)
async def get_daily_macros(
    user_id: str = Depends(get_current_user_id),
    date: Optional[str] = Query(None, description="Date in YYYY-MM-DD format"),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get daily macronutrient summary for all meals with user targets from TDEE.
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Parse date
        target_date = None
        if date:
            target_date = datetime.strptime(date, "%Y-%m-%d").date()
        
        # Send query with user_id for TDEE targets
        query = GetDailyMacrosQuery(user_id=user_id, target_date=target_date)
        result = await event_bus.send(query)
        
        # Use mapper to convert to response
        return MealMapper.to_daily_nutrition_response(result)
        
    except Exception as e:
        raise handle_exception(e) from e


@router.put("/{meal_id}/ingredients", response_model=None)
async def update_meal_ingredients(
    meal_id: str,
    request: EditMealIngredientsRequest,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Update meal ingredients and portions.
    
    Supports adding, removing, and modifying ingredients with automatic nutrition recalculation.
    """
    try:

        logger.info("Updating meal ingredients for meal %s", meal_id)
        # Convert request to command
        food_item_changes = []
        for change_request in request.food_item_changes:
            custom_nutrition = None
            if change_request.custom_nutrition:
                custom_nutrition = CustomNutritionData(
                    calories_per_100g=change_request.custom_nutrition.calories_per_100g,
                    protein_per_100g=change_request.custom_nutrition.protein_per_100g,
                    carbs_per_100g=change_request.custom_nutrition.carbs_per_100g,
                    fat_per_100g=change_request.custom_nutrition.fat_per_100g,
                )
            
            food_item_changes.append(
                FoodItemChange(
                    action=change_request.action,
                    id=change_request.id,
                    fdc_id=change_request.fdc_id,
                    name=change_request.name,
                    quantity=change_request.quantity,
                    unit=change_request.unit,
                    custom_nutrition=custom_nutrition
                )
            )

        logger.info("Food item changes: %s", food_item_changes)
        
        command = EditMealCommand(
            meal_id=meal_id,
            dish_name=request.dish_name,
            food_item_changes=food_item_changes
        )
        
        logger.info("Sending command to event bus: %s", command)
        result = await event_bus.send(command)
        return result
        
    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/api/schemas/request/notification_requests.py">
"""
Notification request schemas for push notification management.
"""
from typing import Optional

from pydantic import BaseModel, Field, field_validator


class FcmTokenRegistrationRequest(BaseModel):
    """Request to register an FCM token."""
    fcm_token: str = Field(..., description="Firebase Cloud Messaging token")
    device_type: str = Field(..., description="Device type (ios or android)")
    timezone: Optional[str] = Field(
        None,
        max_length=50,
        description="IANA timezone identifier (e.g., 'America/Los_Angeles')"
    )
    
    @field_validator('device_type')
    @classmethod
    def validate_device_type(cls, v):
        if v not in ['ios', 'android']:
            raise ValueError('device_type must be either "ios" or "android"')
        return v


class FcmTokenDeletionRequest(BaseModel):
    """Request to delete an FCM token."""
    fcm_token: str = Field(..., description="Firebase Cloud Messaging token to delete")


class NotificationPreferencesUpdateRequest(BaseModel):
    """Request to update notification preferences."""
    meal_reminders_enabled: Optional[bool] = Field(None, description="Enable/disable meal reminders")
    water_reminders_enabled: Optional[bool] = Field(None, description="Enable/disable water reminders")
    sleep_reminders_enabled: Optional[bool] = Field(None, description="Enable/disable sleep reminders")
    progress_notifications_enabled: Optional[bool] = Field(None, description="Enable/disable progress notifications")
    reengagement_notifications_enabled: Optional[bool] = Field(None, description="Enable/disable reengagement notifications")
    
    # Meal timing (minutes from midnight: 0-1439)
    breakfast_time_minutes: Optional[int] = Field(None, ge=0, le=1439, description="Breakfast reminder time (minutes from midnight)")
    lunch_time_minutes: Optional[int] = Field(None, ge=0, le=1439, description="Lunch reminder time (minutes from midnight)")
    dinner_time_minutes: Optional[int] = Field(None, ge=0, le=1439, description="Dinner reminder time (minutes from midnight)")
    
    # Water reminder settings
    water_reminder_interval_hours: Optional[int] = Field(None, gt=0, description="Water reminder interval in hours")
    
    # Sleep reminder timing
    sleep_reminder_time_minutes: Optional[int] = Field(None, ge=0, le=1439, description="Sleep reminder time (minutes from midnight)")
</file>

<file path="src/api/schemas/response/__init__.py">
"""
Response DTOs for API endpoints.
"""

# Activity responses
# Daily meal responses
from .daily_meal_responses import (
    DailyMealSuggestionsResponse,
    SingleMealSuggestionResponse,
    SuggestedMealResponse,
    NutritionTotalsResponse,
    MealSuggestionErrorResponse,
    UserMealPlanSummaryResponse,
    MealTypeEnum,
    QuickMealIdeaResponse,
    QuickMealSuggestionsResponse
)
# Daily nutrition responses
from .daily_nutrition_response import (
    DailyNutritionResponse,
    MacrosResponse as DailyMacrosResponse
)
# Ingredient responses
# Macros responses
# Meal plan responses
from .meal_plan_responses import (
    PlannedMealSchema,
    DayPlanSchema,
    MealPlanSummaryResponse,
    ErrorResponse,
    NutritionSummarySchema,
    UserPreferenceSummarySchema,
    MealsByDateResponse,
    MealPlanGenerationStatusResponse
)
# Meal suggestion responses
from .meal_suggestion_responses import (
    MealSuggestionItem,
    MealSuggestionsResponse,
    SaveMealSuggestionResponse,
    MacrosSchema as MealSuggestionMacrosSchema
)
# Meal responses
from .meal_responses import (
    SimpleMealResponse,
    DetailedMealResponse,
    MealListResponse,
    MealPhotoAnalysisResponse,
    MealSearchResponse,
    NutritionSummaryResponse,
    MacrosResponse,
    NutritionResponse,
    FoodItemResponse,
    ManualMealCreationResponse,
    MealStatusEnum
)
# Onboarding responses
from .onboarding_responses import (
    OnboardingFieldResponse,
    OnboardingSectionResponse,
    OnboardingSectionsResponse,
    OnboardingResponseResponse,
    OnboardingResponse
)
# TDEE responses
from .tdee_responses import (
    TdeeCalculationResponse,
    BatchTdeeCalculationResponse,
    TdeeComparisonResponse,
    TdeeHistoryResponse,
    TdeeErrorResponse,
    MacroTargetsResponse
)
# User responses
from .user_responses import (
    UserProfileResponse,
    UserSyncResponse,
    UserStatusResponse,
    UserUpdateResponse,
    UserMetricsResponse
)
# Weekly meal plan responses
from .weekly_meal_plan_responses import (
    WeeklyMealPlanResponse,
    WeeklyMealResponse,
    NutritionInfo,
    UserPreferencesResponse
)
# Ingredient recognition responses
from .ingredient_recognition_responses import (
    IngredientRecognitionResponse,
    IngredientCategoryEnum
)

__all__ = [
    # Daily meal
    'DailyMealSuggestionsResponse',
    'SingleMealSuggestionResponse',
    'SuggestedMealResponse',
    'NutritionTotalsResponse',
    'MealSuggestionErrorResponse',
    'UserMealPlanSummaryResponse',
    'QuickMealIdeaResponse',
    'QuickMealSuggestionsResponse',
    
    # Meal
    'SimpleMealResponse',
    'DetailedMealResponse',
    'MealListResponse',
    'MealPhotoAnalysisResponse',
    'MealSearchResponse',
    'NutritionSummaryResponse',
    'MacrosResponse',
    'NutritionResponse',
    'FoodItemResponse',
    'ManualMealCreationResponse',
    'MealStatusEnum',
    
    # TDEE
    'TdeeCalculationResponse',
    'BatchTdeeCalculationResponse',
    'TdeeComparisonResponse',
    'TdeeHistoryResponse',
    'TdeeErrorResponse',
    'MacroTargetsResponse',
    
    # Meal plan
    'PlannedMealSchema',
    'DayPlanSchema',
    'MealPlanSummaryResponse',
    'ErrorResponse',
    'NutritionSummarySchema',
    'UserPreferenceSummarySchema',
    'MealsByDateResponse',
    'MealPlanGenerationStatusResponse',
    
    # Meal suggestion
    'MealSuggestionItem',
    'MealSuggestionsResponse',
    'SaveMealSuggestionResponse',
    'MealSuggestionMacrosSchema',

    # Weekly meal plan
    'WeeklyMealPlanResponse',
    'WeeklyMealResponse',
    'NutritionInfo',
    'UserPreferencesResponse',

    # Onboarding
    'OnboardingFieldResponse',
    'OnboardingSectionResponse',
    'OnboardingSectionsResponse',
    'OnboardingResponseResponse',
    'OnboardingResponse',
    
    # Daily nutrition
    'DailyNutritionResponse',
    'DailyMacrosResponse',
    
    # User
    'UserProfileResponse',
    'UserSyncResponse',
    'UserStatusResponse',
    'UserUpdateResponse',
    'UserMetricsResponse',

    # Enums
    'MealTypeEnum',

    # Ingredient recognition
    'IngredientRecognitionResponse',
    'IngredientCategoryEnum'
]
</file>

<file path="src/app/handlers/query_handlers/__init__.py">
"""
query_handlers - Individual handler files.
Each handler is in its own file for better maintainability.
"""

# Activity handlers
from .get_daily_activities_query_handler import GetDailyActivitiesQueryHandler
from .get_daily_macros_query_handler import GetDailyMacrosQueryHandler
from .get_food_details_query_handler import GetFoodDetailsQueryHandler
# Meal handlers
from .get_meal_by_id_query_handler import GetMealByIdQueryHandler
# Meal Plan handlers
from .get_meal_plan_query_handler import GetMealPlanQueryHandler
from .get_meal_planning_summary_query_handler import GetMealPlanningSummaryQueryHandler
# Daily Meal handlers
from .get_meal_suggestions_for_profile_query_handler import GetMealSuggestionsForProfileQueryHandler
from .get_meals_from_plan_by_date_query_handler import GetMealsFromPlanByDateQueryHandler
from .get_meals_by_date_query_handler import GetMealsByDateQueryHandler
from .get_single_meal_for_profile_query_handler import GetSingleMealForProfileQueryHandler
from .get_user_by_firebase_uid_query_handler import GetUserByFirebaseUidQueryHandler
from .get_user_metrics_query_handler import GetUserMetricsQueryHandler
from .get_user_onboarding_status_query_handler import GetUserOnboardingStatusQueryHandler
# User handlers
from .get_user_profile_query_handler import GetUserProfileQueryHandler
# TDEE handlers
from .get_user_tdee_query_handler import GetUserTdeeQueryHandler
# Food handlers
from .search_foods_query_handler import SearchFoodsQueryHandler
# Notification handlers
from .get_notification_preferences_query_handler import GetNotificationPreferencesQueryHandler

__all__ = [
    # TDEE
    "GetUserTdeeQueryHandler",
    # Food
    "SearchFoodsQueryHandler",
    "GetFoodDetailsQueryHandler",
    # Meal
    "GetMealByIdQueryHandler",
    "GetDailyMacrosQueryHandler",
    # User
    "GetUserProfileQueryHandler",
    "GetUserByFirebaseUidQueryHandler",
    "GetUserOnboardingStatusQueryHandler",
    "GetUserMetricsQueryHandler",
    # Activity
    "GetDailyActivitiesQueryHandler",
    # Meal Plan
    "GetMealPlanQueryHandler",
    "GetMealsFromPlanByDateQueryHandler",
    "GetMealsByDateQueryHandler",
    # Daily Meal
    "GetMealSuggestionsForProfileQueryHandler",
    "GetSingleMealForProfileQueryHandler",
    "GetMealPlanningSummaryQueryHandler",
    # Notification
    "GetNotificationPreferencesQueryHandler",
]
</file>

<file path="src/app/handlers/query_handlers/get_user_tdee_query_handler.py">
"""
GetUserTdeeQueryHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException
from src.app.events.base import EventHandler, handles
from src.app.queries.tdee import GetUserTdeeQuery
from src.domain.model.user import TdeeRequest, Sex, ActivityLevel, Goal, UnitSystem
from src.domain.services.tdee_service import TdeeCalculationService
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)


@handles(GetUserTdeeQuery)
class GetUserTdeeQueryHandler(EventHandler[GetUserTdeeQuery, Dict[str, Any]]):
    """Handler for getting user's TDEE calculation."""

    def __init__(self, db: Session = None, tdee_service: TdeeCalculationService = None):
        self.db = db
        self.tdee_service = tdee_service or TdeeCalculationService()

    def set_dependencies(self, db: Session, tdee_service: TdeeCalculationService = None):
        """Set dependencies for dependency injection."""
        self.db = db
        if tdee_service:
            self.tdee_service = tdee_service

    async def handle(self, query: GetUserTdeeQuery) -> Dict[str, Any]:
        """Get user's TDEE calculation based on current profile."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Get current user profile
        profile = self.db.query(UserProfile).filter(
            UserProfile.user_id == query.user_id,
            UserProfile.is_current == True
        ).first()

        if not profile:
            raise ResourceNotFoundException(f"Current profile for user {query.user_id} not found")

        # Map profile data to TDEE request
        sex = Sex.MALE if profile.gender.lower() == "male" else Sex.FEMALE

        activity_map = {
            "sedentary": ActivityLevel.SEDENTARY,
            "light": ActivityLevel.LIGHT,
            "moderate": ActivityLevel.MODERATE,
            "active": ActivityLevel.ACTIVE,
            "extra": ActivityLevel.EXTRA
        }

        goal_map = {
            "cut": Goal.CUT,
            "bulk": Goal.BULK,
            "recomp": Goal.RECOMP
        }

        tdee_request = TdeeRequest(
            age=profile.age,
            sex=sex,
            height=profile.height_cm,
            weight=profile.weight_kg,
            activity_level=activity_map.get(profile.activity_level, ActivityLevel.MODERATE),
            goal=goal_map.get(profile.fitness_goal, Goal.RECOMP),
            body_fat_pct=profile.body_fat_percentage,
            unit_system=UnitSystem.METRIC
        )

        # Calculate TDEE
        result = self.tdee_service.calculate_tdee(tdee_request)
        # Determine activity multiplier for response
        activity_multipliers = {
            ActivityLevel.SEDENTARY: 1.2,
            ActivityLevel.LIGHT: 1.375,
            ActivityLevel.MODERATE: 1.55,
            ActivityLevel.ACTIVE: 1.725,
            ActivityLevel.EXTRA: 1.9
        }
        activity_multiplier = activity_multipliers.get(tdee_request.activity_level, 1.55)

        return {
            "user_id": query.user_id,
            "bmr": result.bmr,
            "tdee": result.tdee,
            "target_calories": round(result.macros.calories, 0),
            "activity_multiplier": activity_multiplier,
            "formula_used": result.formula_used,
            "macros": {
                "protein": round(result.macros.protein, 1),
                "carbs": round(result.macros.carbs, 1),
                "fat": round(result.macros.fat, 1),
                "calories": round(result.macros.calories, 1)
            },
            "profile_data": {
                "age": profile.age,
                "gender": profile.gender,
                "height_cm": profile.height_cm,
                "weight_kg": profile.weight_kg,
                "activity_level": profile.activity_level,
                "fitness_goal": profile.fitness_goal,
                "body_fat_percentage": profile.body_fat_percentage
            }
        }
</file>

<file path="src/domain/model/ai/gpt_response.py">
"""
Pydantic schemas for GPT response validation.

This module provides strongly-typed schemas for validating GPT responses,
improving type safety and error handling in the parsing process.
"""
from typing import List, Optional

from pydantic import BaseModel, Field, field_validator


class GPTMacros(BaseModel):
    """Macronutrient information from GPT response."""
    protein: float = Field(..., ge=0, description="Protein in grams")
    carbs: float = Field(..., ge=0, description="Carbohydrates in grams")
    fat: float = Field(..., ge=0, description="Fat in grams")
    
    @field_validator('protein', 'carbs', 'fat')
    @classmethod
    def round_macros(cls, v):
        """Round macro values to 1 decimal place."""
        return round(v, 1)


class GPTFoodItem(BaseModel):
    """Individual food item from GPT analysis."""
    name: str = Field(..., min_length=1, description="Food item name")
    quantity: float = Field(..., gt=0, description="Quantity of food")
    unit: str = Field(..., min_length=1, description="Unit of measurement")
    calories: float = Field(..., ge=0, description="Calories")
    macros: GPTMacros = Field(..., description="Macronutrient breakdown")
    confidence: float = Field(1.0, ge=0, le=1, description="Confidence score")
    
    @field_validator('calories')
    @classmethod
    def validate_calories(cls, v, info):
        """Validate calories against macros if possible."""
        if info.data and 'macros' in info.data:
            macros = info.data['macros']
            calculated = (macros.protein * 4) + (macros.carbs * 4) + (macros.fat * 9)
            # Allow 20% tolerance for rounding and estimation
            if abs(v - calculated) > calculated * 0.2:
                # Just log warning, don't fail validation
                pass
        return round(v, 1)


class GPTAnalysisResponse(BaseModel):
    """Complete GPT analysis response structure."""
    dish_name: str = Field(..., description="Overall dish name or food list")
    foods: List[GPTFoodItem] = Field(..., min_items=1, description="List of analyzed foods")
    total_calories: float = Field(..., ge=0, description="Total calories")
    confidence: float = Field(..., ge=0, le=1, description="Overall confidence")
    
    # Optional fields for enhanced analysis
    portion_adjustment: Optional[str] = Field(None, description="Portion adjustment note")
    weight_adjustment: Optional[str] = Field(None, description="Weight adjustment note")
    ingredient_based: Optional[bool] = Field(None, description="Whether ingredient-based analysis")
    total_weight_grams: Optional[float] = Field(None, gt=0, description="Total weight if provided")
    
    @field_validator('foods')
    @classmethod
    def validate_foods_not_empty(cls, v):
        """Ensure foods list is not empty."""
        if not v:
            raise ValueError("Foods list cannot be empty")
        return v
    
    @field_validator('total_calories')
    @classmethod
    def validate_total_calories(cls, v, info):
        """Validate total calories matches sum of food items."""
        if info.data and 'foods' in info.data:
            calculated_total = sum(food.calories for food in info.data['foods'])
            # Allow 5% tolerance for rounding
            if abs(v - calculated_total) > calculated_total * 0.05:
                # Use calculated total instead
                return calculated_total
        return round(v, 1)
    
    class Config:
        """Pydantic configuration."""
        json_schema_extra = {
            "example": {
                "dish_name": "Chicken Caesar Salad",
                "foods": [
                    {
                        "name": "Grilled Chicken Breast",
                        "quantity": 150,
                        "unit": "g",
                        "calories": 247.5,
                        "macros": {
                            "protein": 46.5,
                            "carbs": 0,
                            "fat": 5.4,
                        },
                        "confidence": 0.9
                    },
                    {
                        "name": "Caesar Dressing",
                        "quantity": 2,
                        "unit": "tablespoon",
                        "calories": 150,
                        "macros": {
                            "protein": 1,
                            "carbs": 2,
                            "fat": 16,
                        },
                        "confidence": 0.85
                    }
                ],
                "total_calories": 397.5,
                "confidence": 0.88
            }
        }
</file>

<file path="src/domain/model/meal_planning/__init__.py">
"""
Meal Planning bounded context - Domain models for meal planning and generation.
"""
from .macro_targets import SimpleMacroTargets
from .meal_generation_request import (
    MealGenerationRequest,
    MealGenerationType,
    MealGenerationContext,
    UserDietaryProfile,
    UserNutritionTargets,
    IngredientConstraints,
    CalorieDistribution
)
from .meal_generation_response import (
    DailyMealPlan,
    GeneratedMeal,
    NutritionSummary
)
from .meal_plan import (
    MealPlan,
    PlannedMeal,
    DayPlan,
    UserPreferences,
    DietaryPreference,
    FitnessGoal,
    MealType,
    PlanDuration
)
from .meal_suggestion import (
    MealSuggestion,
    MealSize,
    SuggestionStatus,
    Ingredient,
    RecipeStep,
    MacroEstimate,
    MEAL_SIZE_PERCENTAGES
)
from .suggestion_session import SuggestionSession

__all__ = [
    'MealPlan',
    'PlannedMeal',
    'DayPlan',
    'UserPreferences',
    'DietaryPreference',
    'FitnessGoal',
    'MealType',
    'PlanDuration',
    'MealGenerationRequest',
    'MealGenerationType',
    'MealGenerationContext',
    'UserDietaryProfile',
    'UserNutritionTargets',
    'IngredientConstraints',
    'CalorieDistribution',
    'DailyMealPlan',
    'GeneratedMeal',
    'NutritionSummary',
    'SimpleMacroTargets',
    'MealSuggestion',
    'MealSize',
    'SuggestionStatus',
    'Ingredient',
    'RecipeStep',
    'MacroEstimate',
    'MEAL_SIZE_PERCENTAGES',
    'SuggestionSession',
]
</file>

<file path="src/domain/model/meal_planning/meal_generation_request.py">
"""
Domain models for meal generation requests.
"""
from dataclasses import dataclass
from datetime import date
from enum import Enum
from typing import List, Dict, Optional

from .meal_plan import MealType


class MealGenerationType(Enum):
    """Types of meal generation requests."""
    DAILY_PROFILE_BASED = "daily_profile_based"
    DAILY_INGREDIENT_BASED = "daily_ingredient_based"
    WEEKLY_INGREDIENT_BASED = "weekly_ingredient_based"


class TimeFilterEnum(Enum):
    """Time constraints for meal preparation."""
    ANY = "any"           # No time constraint
    QUICK = "quick"       # Under 15 minutes
    MODERATE = "moderate" # 15-30 minutes
    EXTENDED = "extended" # 30-60 minutes


@dataclass
class UserNutritionTargets:
    """User's nutritional targets."""
    calories: int
    protein: float
    carbs: float
    fat: float


@dataclass
class UserDietaryProfile:
    """User's dietary profile and preferences."""
    user_id: str
    dietary_preferences: List[str]
    allergies: List[str]
    health_conditions: List[str]
    activity_level: str
    fitness_goal: str
    meals_per_day: int
    include_snacks: bool
    age: Optional[int] = None
    gender: Optional[str] = None


@dataclass
class IngredientConstraints:
    """Available ingredients and seasonings for meal generation."""
    available_ingredients: List[str]
    available_seasonings: List[str]


@dataclass
class MealGenerationRequest:
    """Base request for meal generation."""
    generation_type: MealGenerationType
    user_profile: UserDietaryProfile
    nutrition_targets: UserNutritionTargets
    ingredient_constraints: Optional[IngredientConstraints] = None
    time_filter: Optional[TimeFilterEnum] = None  # Time constraint for cooking


@dataclass
class CalorieDistribution:
    """Calorie distribution across meal types."""
    distribution: Dict[MealType, int]
    
    def get_calories_for_meal(self, meal_type: MealType) -> int:
        """Get calorie target for specific meal type."""
        return self.distribution.get(meal_type, 0)
    
    def total_calories(self) -> int:
        """Get total calories across all meals."""
        return sum(self.distribution.values())


@dataclass
class MealGenerationContext:
    """Context for generating a specific meal plan."""
    request: MealGenerationRequest
    calorie_distribution: CalorieDistribution
    meal_types: List[MealType]
    start_date: Optional[date] = None
    end_date: Optional[date] = None
    
    def is_ingredient_based(self) -> bool:
        """Check if this is an ingredient-based generation."""
        return self.request.ingredient_constraints is not None
    
    def is_weekly_plan(self) -> bool:
        """Check if this is a weekly plan generation."""
        return self.request.generation_type == MealGenerationType.WEEKLY_INGREDIENT_BASED
</file>

<file path="src/domain/model/meal_planning/meal_generation_response.py">
"""
Domain models for meal generation responses.
"""
from dataclasses import dataclass
from datetime import date
from typing import List, Dict, Any, Optional


@dataclass
class NutritionSummary:
    """Nutritional summary for meals."""
    calories: int
    protein: float
    carbs: float
    fat: float
    
    def __add__(self, other: 'NutritionSummary') -> 'NutritionSummary':
        """Add two nutrition summaries together."""
        return NutritionSummary(
            calories=self.calories + other.calories,
            protein=self.protein + other.protein,
            carbs=self.carbs + other.carbs,
            fat=self.fat + other.fat
        )


@dataclass
class GeneratedMeal:
    """A generated meal with all required information."""
    meal_id: str
    meal_type: str
    name: str
    description: str
    prep_time: int
    cook_time: int
    nutrition: NutritionSummary
    ingredients: List[str]
    seasonings: List[str]
    instructions: List[str]
    is_vegetarian: bool
    is_vegan: bool
    is_gluten_free: bool
    cuisine_type: str
    
    @property
    def total_time(self) -> int:
        """Get total preparation and cooking time."""
        return self.prep_time + self.cook_time
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API response."""
        return {
            "meal_id": self.meal_id,
            "meal_type": self.meal_type,
            "name": self.name,
            "description": self.description,
            "prep_time": self.prep_time,
            "cook_time": self.cook_time,
            "total_time": self.total_time,
            "calories": self.nutrition.calories,
            "protein": self.nutrition.protein,
            "carbs": self.nutrition.carbs,
            "fat": self.nutrition.fat,
            "ingredients": self.ingredients,
            "seasonings": self.seasonings,
            "instructions": self.instructions,
            "is_vegetarian": self.is_vegetarian,
            "is_vegan": self.is_vegan,
            "is_gluten_free": self.is_gluten_free,
            "cuisine_type": self.cuisine_type
        }


@dataclass
class DailyMealPlan:
    """A complete daily meal plan."""
    user_id: str
    plan_date: date
    meals: List[GeneratedMeal]
    
    @property
    def total_nutrition(self) -> NutritionSummary:
        """Calculate total nutrition for all meals."""
        total = NutritionSummary(0, 0.0, 0.0, 0.0)
        for meal in self.meals:
            total = total + meal.nutrition
        return total


@dataclass
class WeeklyMealPlan:
    """A complete weekly meal plan."""
    user_id: str
    start_date: date
    end_date: date
    daily_plans: Dict[str, List[GeneratedMeal]]  # day_name -> meals
    
    @property
    def all_meals(self) -> List[GeneratedMeal]:
        """Get all meals across all days."""
        meals = []
        for day_meals in self.daily_plans.values():
            meals.extend(day_meals)
        return meals
    
    @property
    def total_nutrition(self) -> NutritionSummary:
        """Calculate total nutrition for the week."""
        total = NutritionSummary(0, 0.0, 0.0, 0.0)
        for meal in self.all_meals:
            total = total + meal.nutrition
        return total
    
    @property
    def daily_average_nutrition(self) -> NutritionSummary:
        """Calculate daily average nutrition."""
        total = self.total_nutrition
        return NutritionSummary(
            calories=total.calories // 7,
            protein=round(total.protein / 7, 1),
            carbs=round(total.carbs / 7, 1),
            fat=round(total.fat / 7, 1)
        )


@dataclass
class MealGenerationResult:
    """Result of meal generation operation."""
    success: bool
    daily_plan: Optional[DailyMealPlan] = None
    weekly_plan: Optional[WeeklyMealPlan] = None
    error_message: Optional[str] = None

    def is_daily_plan(self) -> bool:
        """Check if result contains a daily plan."""
        return self.daily_plan is not None

    def is_weekly_plan(self) -> bool:
        """Check if result contains a weekly plan."""
        return self.weekly_plan is not None


@dataclass
class QuickMealIdea:
    """
    A quick meal idea for ingredient-based suggestions.

    Used when user provides ingredients and wants meal ideas.
    Includes simplified info for quick display + pairs_with and quick_recipe.
    """
    meal_id: str
    name: str
    description: str  # Short tagline (10 words max)
    time_minutes: int  # Total cooking time
    calories: int
    protein_g: float
    carbs_g: float
    fat_g: float
    pairs_with: List[str]  # 3-5 complementary ingredients
    quick_recipe: List[str]  # 4-6 simple steps
    tags: List[str]  # ["quick", "high-protein", etc.]

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for API response."""
        return {
            "meal_id": self.meal_id,
            "name": self.name,
            "description": self.description,
            "time_minutes": self.time_minutes,
            "calories": self.calories,
            "protein_g": self.protein_g,
            "carbs_g": self.carbs_g,
            "fat_g": self.fat_g,
            "pairs_with": self.pairs_with,
            "quick_recipe": self.quick_recipe,
            "tags": self.tags,
        }


@dataclass
class QuickMealSuggestionsResult:
    """Result of quick meal suggestions generation."""
    success: bool
    meals: List[QuickMealIdea]
    error_message: Optional[str] = None
</file>

<file path="src/domain/model/meal_planning/meal_plan.py">
import uuid
from dataclasses import dataclass, field
from datetime import datetime, date
from enum import Enum
from typing import List, Optional, Dict


class DietaryPreference(str, Enum):
    VEGAN = "vegan"
    VEGETARIAN = "vegetarian"
    PESCATARIAN = "pescatarian"
    GLUTEN_FREE = "gluten_free"
    KETO = "keto"
    PALEO = "paleo"
    LOW_CARB = "low_carb"
    DAIRY_FREE = "dairy_free"
    NONE = "none"


class FitnessGoal(str, Enum):
    CUT = "cut"
    BULK = "bulk"
    RECOMP = "recomp"


class MealType(str, Enum):
    BREAKFAST = "breakfast"
    LUNCH = "lunch"
    DINNER = "dinner"
    SNACK = "snack"


class PlanDuration(str, Enum):
    DAILY = "daily"
    WEEKLY = "weekly"


@dataclass
class UserPreferences:
    """User preferences for meal planning"""
    dietary_preferences: List[DietaryPreference]
    allergies: List[str]
    fitness_goal: FitnessGoal
    meals_per_day: int
    snacks_per_day: int
    cooking_time_weekday: int  # minutes
    cooking_time_weekend: int  # minutes
    favorite_cuisines: List[str]
    disliked_ingredients: List[str]
    plan_duration: PlanDuration = PlanDuration.WEEKLY
    
    def to_dict(self) -> Dict:
        return {
            "dietary_preferences": [pref.value for pref in self.dietary_preferences],
            "allergies": self.allergies,
            "fitness_goal": self.fitness_goal.value,
            "meals_per_day": self.meals_per_day,
            "snacks_per_day": self.snacks_per_day,
            "cooking_time_weekday": self.cooking_time_weekday,
            "cooking_time_weekend": self.cooking_time_weekend,
            "favorite_cuisines": self.favorite_cuisines,
            "disliked_ingredients": self.disliked_ingredients,
            "plan_duration": self.plan_duration.value
        }


@dataclass
class PlannedMeal:
    """Represents a single meal in a meal plan"""
    meal_id: str
    meal_type: MealType
    name: str
    description: str
    prep_time: int  # minutes
    cook_time: int  # minutes
    calories: int
    protein: float  # grams
    carbs: float  # grams
    fat: float  # grams
    ingredients: List[str]
    seasonings: List[str]
    instructions: List[str]
    is_vegetarian: bool
    is_vegan: bool
    is_gluten_free: bool
    cuisine_type: Optional[str] = None
    
    def __init__(self, **kwargs):
        self.meal_id = kwargs.get('meal_id', str(uuid.uuid4()))
        self.meal_type = kwargs['meal_type']
        self.name = kwargs['name']
        self.description = kwargs['description']
        self.prep_time = kwargs['prep_time']
        self.cook_time = kwargs['cook_time']
        self.calories = kwargs['calories']
        self.protein = kwargs['protein']
        self.carbs = kwargs['carbs']
        self.fat = kwargs['fat']
        self.ingredients = kwargs['ingredients']
        self.seasonings = kwargs.get('seasonings', [])
        self.instructions = kwargs['instructions']
        self.is_vegetarian = kwargs['is_vegetarian']
        self.is_vegan = kwargs['is_vegan']
        self.is_gluten_free = kwargs['is_gluten_free']
        self.cuisine_type = kwargs.get('cuisine_type')
    
    @property
    def total_time(self) -> int:
        return self.prep_time + self.cook_time
    
    def to_dict(self) -> Dict:
        return {
            "meal_id": self.meal_id,
            "meal_type": self.meal_type.value,
            "name": self.name,
            "description": self.description,
            "prep_time": self.prep_time,
            "cook_time": self.cook_time,
            "total_time": self.total_time,
            "calories": self.calories,
            "protein": self.protein,
            "carbs": self.carbs,
            "fat": self.fat,
            "ingredients": self.ingredients,
            "seasonings": self.seasonings,
            "instructions": self.instructions,
            "is_vegetarian": self.is_vegetarian,
            "is_vegan": self.is_vegan,
            "is_gluten_free": self.is_gluten_free,
            "cuisine_type": self.cuisine_type
        }


@dataclass
class DayPlan:
    """Represents meals for a single day"""
    date: date
    meals: List[PlannedMeal] = field(default_factory=list)

    def get_meals_by_type(self, meal_type: MealType) -> List[PlannedMeal]:
        return [meal for meal in self.meals if meal.meal_type == meal_type]
    
    def get_total_nutrition(self) -> Dict[str, float]:
        return {
            "calories": sum(meal.calories for meal in self.meals),
            "protein": sum(meal.protein for meal in self.meals),
            "carbs": sum(meal.carbs for meal in self.meals),
            "fat": sum(meal.fat for meal in self.meals)
        }
    
    def to_dict(self) -> Dict:
        return {
            "date": self.date.isoformat(),
            "meals": [meal.to_dict() for meal in self.meals],
            "total_nutrition": self.get_total_nutrition()
        }


class MealPlan:
    """Represents a complete meal plan (daily or weekly)"""
    
    def __init__(self, user_id: str, preferences: UserPreferences, days: List[DayPlan]):
        self.plan_id = str(uuid.uuid4())
        self.user_id = user_id
        self.preferences = preferences
        self.days = days
        self.created_at = datetime.utcnow()
        self.updated_at = datetime.utcnow()
    
    def get_day(self, date: date) -> Optional[DayPlan]:
        for day in self.days:
            if day.date == date:
                return day
        return None
    
    def replace_meal(self, date: date, meal_id: str, new_meal: PlannedMeal) -> bool:
        day = self.get_day(date)
        if day:
            for i, meal in enumerate(day.meals):
                if meal.meal_id == meal_id:
                    day.meals[i] = new_meal
                    self.updated_at = datetime.utcnow()
                    return True
        return False
    
    def to_dict(self) -> Dict:
        return {
            "plan_id": self.plan_id,
            "user_id": self.user_id,
            "preferences": self.preferences.to_dict(),
            "days": [day.to_dict() for day in self.days],
            "created_at": self.created_at.isoformat(),
            "updated_at": self.updated_at.isoformat()
        }
</file>

<file path="src/domain/model/notification/notification_preferences.py">
"""
Notification preferences domain model.
"""
import uuid
from dataclasses import dataclass
from datetime import datetime
from typing import Optional

from .enums import NotificationType

# Map notification types to their corresponding preference fields
NOTIFICATION_TYPE_TO_FIELD = {
    NotificationType.MEAL_REMINDER_BREAKFAST: "meal_reminders_enabled",
    NotificationType.MEAL_REMINDER_LUNCH: "meal_reminders_enabled",
    NotificationType.MEAL_REMINDER_DINNER: "meal_reminders_enabled",
    NotificationType.WATER_REMINDER: "water_reminders_enabled",
    NotificationType.SLEEP_REMINDER: "sleep_reminders_enabled",
    NotificationType.PROGRESS_NOTIFICATION: "progress_notifications_enabled",
    NotificationType.REENGAGEMENT_NOTIFICATION: "reengagement_notifications_enabled",
}


@dataclass
class NotificationPreferences:
    """
    Domain model representing a user's notification preferences.
    """
    preferences_id: str  # UUID as string
    user_id: str  # UUID as string
    meal_reminders_enabled: bool = True
    water_reminders_enabled: bool = True
    sleep_reminders_enabled: bool = True
    progress_notifications_enabled: bool = True
    reengagement_notifications_enabled: bool = True
    breakfast_time_minutes: Optional[int] = None  # minutes from midnight (0-1439)
    lunch_time_minutes: Optional[int] = None
    dinner_time_minutes: Optional[int] = None
    water_reminder_interval_hours: int = 2
    last_water_reminder_at: Optional[datetime] = None
    sleep_reminder_time_minutes: Optional[int] = None
    created_at: Optional[datetime] = None
    updated_at: Optional[datetime] = None
    
    def __post_init__(self):
        """Validate invariants."""
        # Validate UUID formats
        try:
            uuid.UUID(self.preferences_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for preferences_id: {self.preferences_id}")
        
        try:
            uuid.UUID(self.user_id)
        except ValueError:
            raise ValueError(f"Invalid UUID format for user_id: {self.user_id}")
        
        # Validate time constraints
        self._validate_time_minutes(self.breakfast_time_minutes, "breakfast_time_minutes")
        self._validate_time_minutes(self.lunch_time_minutes, "lunch_time_minutes")
        self._validate_time_minutes(self.dinner_time_minutes, "dinner_time_minutes")
        self._validate_time_minutes(self.sleep_reminder_time_minutes, "sleep_reminder_time_minutes")
        
        # Validate water interval
        if self.water_reminder_interval_hours <= 0:
            raise ValueError("water_reminder_interval_hours must be positive")
    
    def _validate_time_minutes(self, time_minutes: Optional[int], field_name: str):
        """Validate time in minutes from midnight."""
        if time_minutes is not None and (time_minutes < 0 or time_minutes >= 1440):
            raise ValueError(f"{field_name} must be between 0 and 1439 (minutes from midnight)")
    
    @classmethod
    def create_default(cls, user_id: str) -> 'NotificationPreferences':
        """Factory method to create default notification preferences.
        
        All notification types are enabled by default with sensible timing defaults.
        """
        return cls(
            preferences_id=str(uuid.uuid4()),
            user_id=user_id,
            # All notification types enabled by default
            meal_reminders_enabled=True,
            water_reminders_enabled=True,
            sleep_reminders_enabled=True,
            progress_notifications_enabled=True,
            reengagement_notifications_enabled=True,
            # Default meal times: 8:00 AM, 12:00 PM, 6:00 PM, 10:00 PM
            breakfast_time_minutes=480,  # 8:00 AM
            lunch_time_minutes=720,      # 12:00 PM
            dinner_time_minutes=1080,    # 6:00 PM
            sleep_reminder_time_minutes=1320,  # 10:00 PM
            water_reminder_interval_hours=2,  # Every 2 hours
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
    
    def update_preferences(
        self,
        meal_reminders_enabled: Optional[bool] = None,
        water_reminders_enabled: Optional[bool] = None,
        sleep_reminders_enabled: Optional[bool] = None,
        progress_notifications_enabled: Optional[bool] = None,
        reengagement_notifications_enabled: Optional[bool] = None,
        breakfast_time_minutes: Optional[int] = None,
        lunch_time_minutes: Optional[int] = None,
        dinner_time_minutes: Optional[int] = None,
        water_reminder_interval_hours: Optional[int] = None,
        sleep_reminder_time_minutes: Optional[int] = None,
    ) -> 'NotificationPreferences':
        """Update notification preferences with new values."""
        # Validate time constraints before updating
        if breakfast_time_minutes is not None:
            self._validate_time_minutes(breakfast_time_minutes, "breakfast_time_minutes")
        if lunch_time_minutes is not None:
            self._validate_time_minutes(lunch_time_minutes, "lunch_time_minutes")
        if dinner_time_minutes is not None:
            self._validate_time_minutes(dinner_time_minutes, "dinner_time_minutes")
        if sleep_reminder_time_minutes is not None:
            self._validate_time_minutes(sleep_reminder_time_minutes, "sleep_reminder_time_minutes")
        
        if water_reminder_interval_hours is not None and water_reminder_interval_hours <= 0:
            raise ValueError("water_reminder_interval_hours must be positive")
        
        return NotificationPreferences(
            preferences_id=self.preferences_id,
            user_id=self.user_id,
            meal_reminders_enabled=meal_reminders_enabled if meal_reminders_enabled is not None else self.meal_reminders_enabled,
            water_reminders_enabled=water_reminders_enabled if water_reminders_enabled is not None else self.water_reminders_enabled,
            sleep_reminders_enabled=sleep_reminders_enabled if sleep_reminders_enabled is not None else self.sleep_reminders_enabled,
            progress_notifications_enabled=progress_notifications_enabled if progress_notifications_enabled is not None else self.progress_notifications_enabled,
            reengagement_notifications_enabled=reengagement_notifications_enabled if reengagement_notifications_enabled is not None else self.reengagement_notifications_enabled,
            breakfast_time_minutes=breakfast_time_minutes if breakfast_time_minutes is not None else self.breakfast_time_minutes,
            lunch_time_minutes=lunch_time_minutes if lunch_time_minutes is not None else self.lunch_time_minutes,
            dinner_time_minutes=dinner_time_minutes if dinner_time_minutes is not None else self.dinner_time_minutes,
            water_reminder_interval_hours=water_reminder_interval_hours if water_reminder_interval_hours is not None else self.water_reminder_interval_hours,
            last_water_reminder_at=self.last_water_reminder_at,
            sleep_reminder_time_minutes=sleep_reminder_time_minutes if sleep_reminder_time_minutes is not None else self.sleep_reminder_time_minutes,
            created_at=self.created_at,
            updated_at=datetime.now()
        )
    
    def is_notification_type_enabled(self, notification_type: NotificationType) -> bool:
        """Check if a specific notification type is enabled."""
        field_name = NOTIFICATION_TYPE_TO_FIELD.get(notification_type)
        return getattr(self, field_name, False) if field_name else False
    
    def get_meal_reminder_time(self, meal_type: str) -> Optional[int]:
        """Get the reminder time in minutes for a specific meal type."""
        if meal_type == "breakfast":
            return self.breakfast_time_minutes
        elif meal_type == "lunch":
            return self.lunch_time_minutes
        elif meal_type == "dinner":
            return self.dinner_time_minutes
        else:
            return None
    
    def to_dict(self) -> dict:
        """Convert to dictionary format."""
        return {
            "preferences_id": self.preferences_id,
            "user_id": self.user_id,
            "meal_reminders_enabled": self.meal_reminders_enabled,
            "water_reminders_enabled": self.water_reminders_enabled,
            "sleep_reminders_enabled": self.sleep_reminders_enabled,
            "progress_notifications_enabled": self.progress_notifications_enabled,
            "reengagement_notifications_enabled": self.reengagement_notifications_enabled,
            "breakfast_time_minutes": self.breakfast_time_minutes,
            "lunch_time_minutes": self.lunch_time_minutes,
            "dinner_time_minutes": self.dinner_time_minutes,
            "water_reminder_interval_hours": self.water_reminder_interval_hours,
            "last_water_reminder_at": self.last_water_reminder_at.isoformat() if self.last_water_reminder_at else None,
            "sleep_reminder_time_minutes": self.sleep_reminder_time_minutes,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "updated_at": self.updated_at.isoformat() if self.updated_at else None,
        }
</file>

<file path="src/domain/services/meal_suggestion/__init__.py">
"""Meal suggestion service components."""
from src.domain.services.meal_suggestion.json_extractor import JsonExtractor
from src.domain.services.meal_suggestion.recipe_search_service import RecipeSearchService
from src.domain.services.meal_suggestion.suggestion_fallback_provider import SuggestionFallbackProvider
from src.domain.services.meal_suggestion.suggestion_prompt_builder import SuggestionPromptBuilder

__all__ = [
    "JsonExtractor",
    "RecipeSearchService",
    "SuggestionFallbackProvider",
    "SuggestionPromptBuilder",
]
</file>

<file path="src/domain/services/meal_suggestion/recipe_search_service.py">
"""
Service for searching recipes in Pinecone index.
Enables fast meal suggestion retrieval via semantic search.
"""
import json
import logging
from typing import List, Optional
from dataclasses import dataclass

from src.infra.services.pinecone_service import PineconeNutritionService

logger = logging.getLogger(__name__)


@dataclass
class RecipeSearchCriteria:
    """Search criteria for recipe lookup."""
    meal_type: str
    target_calories: int
    calorie_tolerance: int = 100  # ±100 cal
    max_cook_time: Optional[int] = None
    dietary_preferences: List[str] = None
    allergies: List[str] = None
    ingredients: List[str] = None
    exclude_ids: List[str] = None

    def __post_init__(self):
        """Initialize default values for list fields."""
        if self.dietary_preferences is None:
            self.dietary_preferences = []
        if self.allergies is None:
            self.allergies = []
        if self.ingredients is None:
            self.ingredients = []
        if self.exclude_ids is None:
            self.exclude_ids = []


@dataclass
class RecipeSearchResult:
    """Recipe retrieved from Pinecone."""
    recipe_id: str
    name: str
    description: str
    ingredients: List[dict]
    recipe_steps: List[dict]
    seasonings: List[str]
    macros: dict
    prep_time_minutes: int
    confidence_score: float


class RecipeSearchService:
    """Searches Pinecone recipe index for meal suggestions."""

    def __init__(self, pinecone_service: PineconeNutritionService = None):
        """Initialize with optional Pinecone service."""
        self._pinecone = pinecone_service
        if not self._pinecone:
            try:
                self._pinecone = PineconeNutritionService()
            except Exception as e:
                logger.warning(f"Failed to initialize Pinecone service: {e}")
                self._pinecone = None

        # No local embedding model needed - use Pinecone Inference API
        logger.info("Recipe search service initialized (using Pinecone Inference API)")

        self.recipes_index = None
        if self._pinecone:
            try:
                self.recipes_index = self._pinecone.pc.Index("recipes")
                logger.info("Connected to Pinecone recipes index")
            except Exception as e:
                logger.warning(f"Recipes index not available: {e}")

    def _embed_query(self, text: str) -> list[float]:
        """
        Generate query embedding using Pinecone Inference API.

        Args:
            text: Query text to embed

        Returns:
            1024-dimension embedding vector
        """
        embeddings = self._pinecone.pc.inference.embed(
            model="llama-text-embed-v2",
            inputs=[text],
            parameters={"input_type": "query", "truncate": "END"}
        )
        return embeddings[0]["values"]

    def search_recipes(
        self,
        criteria: RecipeSearchCriteria,
        top_k: int = 10
    ) -> List[RecipeSearchResult]:
        """
        Search for recipes matching criteria.

        Args:
            criteria: Search criteria
            top_k: Number of results to return

        Returns:
            List of matching recipes, sorted by relevance
        """
        if not self.recipes_index or not self._pinecone:
            logger.warning("Recipes index or Pinecone service not available, returning empty results")
            return []

        # Build search query text
        query_parts = [criteria.meal_type]

        if criteria.ingredients:
            query_parts.extend(criteria.ingredients[:5])

        if criteria.dietary_preferences:
            query_parts.extend(criteria.dietary_preferences)

        # Add allergies as negative terms to help semantic search avoid allergen-containing recipes
        if criteria.allergies:
            # Add "no" prefix for each allergy to indicate exclusion
            allergy_terms = [f"no {allergy}" for allergy in criteria.allergies]
            query_parts.extend(allergy_terms)

        query_text = " ".join(query_parts)

        # Generate query embedding using Pinecone Inference API
        query_embedding = self._embed_query(query_text)

        # Build metadata filters
        filters = {
            "meal_type": {"$eq": criteria.meal_type},
            "calories": {
                "$gte": criteria.target_calories - criteria.calorie_tolerance,
                "$lte": criteria.target_calories + criteria.calorie_tolerance
            }
        }

        if criteria.max_cook_time:
            filters["total_time_minutes"] = {"$lte": criteria.max_cook_time}

        if criteria.exclude_ids:
            filters["recipe_id"] = {"$nin": criteria.exclude_ids}

        try:
            # Search Pinecone with generated embedding
            logger.debug(
                f"Searching recipes: meal_type={criteria.meal_type}, "
                f"calories={criteria.target_calories}±{criteria.calorie_tolerance}, "
                f"allergies={criteria.allergies or []}, "
                f"query='{query_text}'"
            )

            results = self.recipes_index.query(
                vector=query_embedding,  # Use locally generated embedding
                top_k=top_k,
                include_metadata=True,
                filter=filters
            )

            # Convert to domain objects
            recipes = []
            matches = results.get("matches", [])

            logger.info(f"Pinecone returned {len(matches)} recipe matches")

            # Normalize allergies to lowercase for matching
            normalized_allergies = [allergy.lower() for allergy in (criteria.allergies or [])]

            for match in matches:
                metadata = match.get("metadata", {})

                # Parse JSON fields
                try:
                    ingredients = json.loads(metadata.get("ingredients", "[]"))
                    recipe_steps = json.loads(metadata.get("recipe_steps", "[]"))
                    seasonings = json.loads(metadata.get("seasonings", "[]"))
                except json.JSONDecodeError as e:
                    logger.warning(f"Failed to parse recipe metadata: {e}")
                    continue

                # Filter out recipes containing allergens
                if normalized_allergies:
                    # Check if any ingredient name contains any allergy term
                    ingredient_names = [ing.get("name", "").lower() for ing in ingredients if isinstance(ing, dict)]
                    contains_allergen = any(
                        any(allergy in ingredient_name for ingredient_name in ingredient_names)
                        for allergy in normalized_allergies
                    )
                    if contains_allergen:
                        logger.debug(
                            f"Filtered out recipe {metadata.get('recipe_id')} "
                            f"({metadata.get('name')}) - contains allergens"
                        )
                        continue

                recipes.append(
                    RecipeSearchResult(
                        recipe_id=metadata.get("recipe_id", ""),
                        name=metadata.get("name", ""),
                        description=metadata.get("description", ""),
                        ingredients=ingredients,
                        recipe_steps=recipe_steps,
                        seasonings=seasonings,
                        macros={
                            "calories": metadata.get("calories", 0),
                            "protein": metadata.get("protein", 0),
                            "carbs": metadata.get("carbs", 0),
                            "fat": metadata.get("fat", 0)
                        },
                        prep_time_minutes=metadata.get("total_time_minutes", 20),
                        confidence_score=match.get("score", 0.5)
                    )
                )

            logger.info(
                f"Recipe search returned {len(recipes)} valid results "
                f"(avg confidence: {sum(r.confidence_score for r in recipes) / len(recipes):.2f})"
                if recipes else "Recipe search returned 0 results"
            )
            return recipes

        except Exception as e:
            logger.error(f"Recipe search failed: {e}", exc_info=True)
            return []
</file>

<file path="src/domain/services/notification_service.py">
"""
Notification service for sending push notifications.
"""

import logging
from typing import Dict, List, Optional, Any

from src.domain.model.notification import (
    NotificationType,
    PushNotification,
    NotificationPreferences,
)
from src.domain.ports.notification_repository_port import NotificationRepositoryPort

logger = logging.getLogger(__name__)

# FCM error codes that indicate token should be deactivated
DEACTIVATABLE_FCM_ERRORS = {
    "invalid-registration-token",
    "registration-token-not-registered",
    "NOT_FOUND",  # Firebase messaging.exceptions.NotFoundError
    "UNREGISTERED",  # Token unregistered from FCM
    "INVALID_ARGUMENT",  # Malformed token
}

# Meal reminder configuration
MEAL_REMINDER_CONFIG = {
    "breakfast": {
        "title": "🍳 Breakfast Time!",
        "body": "Start your day right - log your breakfast",
    },
    "lunch": {
        "title": "🥗 Lunch Time!",
        "body": "Time for a nutritious lunch break",
    },
    "dinner": {
        "title": "🍽️ Dinner Time!",
        "body": "Wind down with a healthy dinner",
    },
}


class NotificationService:
    """Service for sending push notifications."""

    def __init__(
        self, notification_repository: NotificationRepositoryPort, firebase_service
    ):
        self.notification_repository = notification_repository
        self.firebase_service = firebase_service

    async def send_notification(
        self,
        user_id: str,
        title: str,
        body: str,
        notification_type: NotificationType,
        data: Optional[Dict[str, str]] = None,
    ) -> Dict[str, Any]:
        """
        Send push notification to user.

        Args:
            user_id: User ID
            title: Notification title
            body: Notification body
            notification_type: Type of notification
            data: Optional data payload

        Returns:
            Dictionary with success status and results
        """
        try:
            # 1. Get user's active FCM tokens
            tokens = self.notification_repository.find_active_fcm_tokens_by_user(
                user_id
            )

            if not tokens:
                logger.warning(f"No active FCM tokens found for user {user_id}")
                return {"success": False, "reason": "no_tokens"}

            # 2. Check if notification type is enabled for user
            preferences = (
                self.notification_repository.find_notification_preferences_by_user(
                    user_id
                )
            )

            if preferences and not preferences.is_notification_type_enabled(
                notification_type
            ):
                logger.info(
                    f"Notification type {notification_type} is disabled for user {user_id}"
                )
                return {"success": False, "reason": "disabled"}

            # 3. Send notification via Firebase
            fcm_tokens = [token.fcm_token for token in tokens]

            result = self.firebase_service.send_notification(
                user_id=user_id,
                title=title,
                body=body,
                notification_type=str(notification_type),
                data=data,
                tokens=fcm_tokens,
            )

            # 4. Handle invalid tokens
            if result.get("success") and result.get("failed_tokens"):
                await self._handle_failed_tokens(
                    result["failed_tokens"],
                    user_id=user_id,
                    notification_type=str(notification_type),
                )

            logger.info(f"Notification sent to user {user_id}: {result}")
            return result

        except Exception as e:
            logger.error(f"Error sending notification to user {user_id}: {e}")
            return {"success": False, "reason": "error", "error": str(e)}

    async def send_meal_reminder(self, user_id: str, meal_type: str) -> Dict[str, Any]:
        """Send meal reminder notification."""
        config = MEAL_REMINDER_CONFIG.get(
            meal_type, {"title": "🍽️ Meal Time!", "body": "Time to log your meal"}
        )
        title = config["title"]
        body = config["body"]

        notification_type = NotificationType(f"meal_reminder_{meal_type}")

        return await self.send_notification(
            user_id=user_id,
            title=title,
            body=body,
            notification_type=notification_type,
            data={"meal_type": meal_type},
        )

    async def send_water_reminder(self, user_id: str) -> Dict[str, Any]:
        """Send water reminder notification."""
        return await self.send_notification(
            user_id=user_id,
            title="💧 Hydration Check",
            body="Time to drink some water!",
            notification_type=NotificationType.WATER_REMINDER,
            data={"type": "water_reminder"},
        )

    async def send_sleep_reminder(self, user_id: str) -> Dict[str, Any]:
        """Send sleep reminder notification."""
        return await self.send_notification(
            user_id=user_id,
            title="😴 Sleep Time",
            body="Get ready for a good night's rest",
            notification_type=NotificationType.SLEEP_REMINDER,
            data={"type": "sleep_reminder"},
        )

    async def send_progress_notification(
        self, user_id: str, title: str, body: str, data: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """Send progress notification."""
        return await self.send_notification(
            user_id=user_id,
            title=title,
            body=body,
            notification_type=NotificationType.PROGRESS_NOTIFICATION,
            data=data,
        )

    async def send_reengagement_notification(
        self, user_id: str, title: str, body: str, data: Optional[Dict[str, str]] = None
    ) -> Dict[str, Any]:
        """Send reengagement notification."""
        return await self.send_notification(
            user_id=user_id,
            title=title,
            body=body,
            notification_type=NotificationType.REENGAGEMENT_NOTIFICATION,
            data=data,
        )

    async def send_bulk_notifications(
        self, notifications: List[PushNotification]
    ) -> List[Dict[str, Any]]:
        """
        Send multiple notifications efficiently.

        Args:
            notifications: List of push notifications to send

        Returns:
            List of results for each notification
        """
        results = []

        for notification in notifications:
            result = await self.send_notification(
                user_id=notification.user_id,
                title=notification.title,
                body=notification.body,
                notification_type=notification.notification_type,
                data=notification.data,
            )
            results.append(result)

        return results

    async def _handle_failed_tokens(
        self,
        failed_tokens: List[Dict[str, Any]],
        user_id: str = "",
        notification_type: str = "",
    ):
        """Handle tokens that failed to receive notifications."""
        deactivated_count = 0
        context = f"user={user_id}, type={notification_type}" if user_id else ""

        for failed_token in failed_tokens:
            token = failed_token["token"]
            error = failed_token.get("error", "unknown")
            error_upper = str(error).upper()

            # Check if error warrants token deactivation
            should_deactivate = any(
                err_code in error_upper for err_code in DEACTIVATABLE_FCM_ERRORS
            )

            if should_deactivate:
                logger.info(
                    f"Deactivating invalid FCM token ({context}): "
                    f"{token[:20]}... error={error}"
                )
                self.notification_repository.deactivate_fcm_token(token)
                deactivated_count += 1
            else:
                logger.warning(
                    f"FCM token failed ({context}) with error {error}: {token[:20]}..."
                )

        if deactivated_count > 0:
            logger.info(
                f"Deactivated {deactivated_count} invalid FCM tokens ({context})"
            )

    def get_notification_preferences(
        self, user_id: str
    ) -> Optional[NotificationPreferences]:
        """Get notification preferences for user."""
        return self.notification_repository.find_notification_preferences_by_user(
            user_id
        )

    def is_notification_enabled(
        self, user_id: str, notification_type: NotificationType
    ) -> bool:
        """Check if a notification type is enabled for user."""
        preferences = self.get_notification_preferences(user_id)
        if not preferences:
            return True  # Default to enabled if no preferences exist

        return preferences.is_notification_type_enabled(notification_type)
</file>

<file path="src/domain/services/tdee_service.py">
from src.domain.constants import TDEEConstants
from src.domain.model.user import TdeeRequest, TdeeResponse, MacroTargets, ActivityLevel, Goal
from src.domain.services.bmr_calculator import BMRCalculatorFactory


class TdeeCalculationService:
    """
    Domain service for TDEE and macro calculations.
    
    Automatically selects the appropriate BMR calculation formula:
    - Katch-McArdle: When body fat % is provided (more accurate)
    - Mifflin-St Jeor: When body fat % is not provided (standard approach)
    """
    
    def calculate_tdee(self, request: TdeeRequest) -> TdeeResponse:
        """Calculate BMR, TDEE and macros based on the request."""
        bmr, formula_name = self._calculate_bmr(request)
        tdee = self._calculate_tdee_from_bmr(bmr, request.activity_level)
        macro_targets = self._calculate_all_macro_targets(tdee, request.weight_kg, request.goal)
        return TdeeResponse(
            bmr=round(bmr, 1),
            tdee=round(tdee, 1),
            goal=request.goal,
            macros=macro_targets,
            formula_used=formula_name,
        )
    
    def _calculate_bmr(self, request: TdeeRequest) -> tuple[float, str]:
        """
        Calculate BMR using the appropriate formula based on available data.
        
        Returns:
            tuple: (bmr_value, formula_name)
        """
        # Get the appropriate calculator
        has_body_fat = request.body_fat_pct is not None
        calculator = BMRCalculatorFactory.get_calculator(has_body_fat)

        # Calculate BMR
        bmr = calculator.calculate(
            weight_kg=request.weight_kg,
            height_cm=request.height_cm,
            age=request.age,
            sex=request.sex,
            body_fat_pct=request.body_fat_pct
        )

        return bmr, calculator.get_formula_name()
    
    def _calculate_tdee_from_bmr(self, bmr: float, activity_level: ActivityLevel) -> float:
        """Calculate TDEE from BMR using activity multiplier."""
        # Map ActivityLevel enum to string for constants lookup
        activity_map = {
            ActivityLevel.SEDENTARY: "sedentary",
            ActivityLevel.LIGHT: "light",
            ActivityLevel.MODERATE: "moderate",
            ActivityLevel.ACTIVE: "active",
            ActivityLevel.EXTRA: "extra"
        }
        multiplier = TDEEConstants.ACTIVITY_MULTIPLIERS[activity_map[activity_level]]
        return bmr * multiplier
    
    def _calculate_all_macro_targets(self, tdee: float, weight_kg: float, goal: Goal) -> MacroTargets:
        """Calculate macro targets using goal-specific ratios based on nutrition science.

        Different goals require different macro distributions:
        - Bulk: Higher carbs for training energy, moderate protein
        - Cut: Higher protein to preserve muscle, lower carbs
        - Recomp: High protein like cutting, moderate carbs for training
        """
        # Determine target calories based on goal
        if goal == Goal.CUT:
            calories = tdee - TDEEConstants.CUTTING_DEFICIT
            goal_key = "cut"
        elif goal == Goal.BULK:
            calories = tdee + TDEEConstants.BULKING_SURPLUS
            goal_key = "bulk"
        elif goal == Goal.RECOMP:
            calories = tdee + TDEEConstants.RECOMP_ADJUSTMENT
            goal_key = "recomp"
        else:
            # Fallback to recomp for unknown goals
            calories = tdee
            goal_key = "recomp"

        # Get goal-specific macro ratios
        macro_ratios = TDEEConstants.MACRO_RATIOS.get(goal_key, TDEEConstants.MACRO_RATIOS["recomp"])

        # Calculate macros using goal-specific ratios
        # Protein: 4 cal/g, Carbs: 4 cal/g, Fat: 9 cal/g
        protein_g = (calories * macro_ratios["protein"]) / 4
        carb_g = (calories * macro_ratios["carbs"]) / 4
        fat_g = (calories * macro_ratios["fat"]) / 9

        macro_targets = MacroTargets(
            calories=round(calories, 1),
            protein=round(protein_g, 1),
            fat=round(fat_g, 1),
            carbs=round(carb_g, 1)
        )

        return macro_targets
    
    def calculate_macros(self, tdee: float, goal: Goal, weight_kg: float) -> MacroTargets:
        """Calculate macros based on TDEE, goal, and weight."""
        return self._calculate_all_macro_targets(tdee, weight_kg, goal)
</file>

<file path="src/infra/adapters/meal_generation_service.py">
"""
Meal generation service implementation using Google Gemini API.
Follows clean architecture pattern with single LLM handling different prompts.
"""
import json
import logging
import os
import re
import time
from typing import Dict, Any

from langchain_core.messages import HumanMessage, SystemMessage
from langchain_google_genai import ChatGoogleGenerativeAI

from src.domain.ports.meal_generation_service_port import MealGenerationServicePort

logger = logging.getLogger(__name__)


def _truncate(s: str, max_len: int = 200) -> str:
    """Truncate string for logging."""
    return s[:max_len] + "..." if len(s) > max_len else s


class MealGenerationService(MealGenerationServicePort):
    """
    Unified meal generation service using single LLM with different prompts.
    Follows clean architecture principles.
    """
    
    def __init__(self):
        """Initialize the single Gemini LLM client."""
        self.api_key = os.getenv("GOOGLE_API_KEY")
        if not self.api_key:
            logger.warning("GOOGLE_API_KEY not found. AI meal generation will not be available.")
            self.llm = None
        else:
            # Base LLM configuration - will be customized per request
            self.base_llm_config = {
                "model": os.getenv("GEMINI_MODEL", "gemini-2.5-flash"),
                "temperature": 0.2,  # Lower temperature for consistency
                "google_api_key": self.api_key,
                # NOTE: response_mime_type is set conditionally per request
                # (incompatible with structured output / function calling)
            }
    
    def generate_meal_plan(
        self, 
        prompt: str, 
        system_message: str, 
        response_type: str = "json", 
        max_tokens: int = None,
        schema: type = None
    ) -> Dict[str, Any]:
        """
        Generate meal plan using provided prompt and system message.
        Single entry point for all meal generation.

        Args:
            prompt: The generation prompt
            system_message: System instructions
            response_type: Response format ("json" or "text")
            max_tokens: Optional max tokens override (defaults based on complexity)
            schema: Optional Pydantic model for structured output (recommended for reliability)
        
        Returns:
            Dict or Pydantic model instance (if schema provided)
        """
        if not self.api_key:
            raise RuntimeError("GOOGLE_API_KEY missing — cannot call Gemini.")

        start_time = time.time()

        try:
            # Determine optimal token limit based on content complexity
            if max_tokens is None:
                max_tokens = self._determine_optimal_tokens(prompt, system_message)

            # Log request config
            model_name = self.base_llm_config.get("model", "unknown")
            logger.info(
                f"[AI-REQUEST] model={model_name} | "
                f"max_tokens={max_tokens} | "
                f"prompt_len={len(prompt)} | "
                f"system_len={len(system_message)} | "
                f"response_type={response_type}"
            )

            # Create LLM instance with appropriate token limit
            # Add response_mime_type only if NOT using structured output (incompatible)
            llm_config = {
                **self.base_llm_config,
                "max_output_tokens": max_tokens,
            }
            
            # Only set response_mime_type for legacy JSON mode (not structured output)
            if not schema and response_type == "json":
                llm_config["response_mime_type"] = "application/json"
            
            llm = ChatGoogleGenerativeAI(**llm_config)

            # Use structured output if schema provided (guarantees valid format)
            if schema:
                logger.info(f"[STRUCTURED-OUTPUT] using schema={schema.__name__}")
                # NOTE: with_structured_output uses function calling, incompatible with response_mime_type
                # Use include_raw=True to get raw response as fallback when parsing fails
                llm_with_structure = llm.with_structured_output(schema, include_raw=True)

                # Create messages
                messages = [
                    SystemMessage(content=system_message),
                    HumanMessage(content=prompt)
                ]

                # Generate structured response (returns dict with 'raw' and 'parsed')
                result = llm_with_structure.invoke(messages)
                elapsed = time.time() - start_time

                # Extract parsed response (or None if parsing failed)
                structured_response = result.get("parsed") if isinstance(result, dict) else result
                raw_response = result.get("raw") if isinstance(result, dict) else None

                logger.info(
                    f"[STRUCTURED-RESPONSE] elapsed={elapsed:.2f}s | "
                    f"schema={schema.__name__} | "
                    f"parsed_type={type(structured_response).__name__} | "
                    f"has_raw={raw_response is not None}"
                )

                # Handle None response - try to use raw response as fallback
                if structured_response is None:
                    if raw_response and hasattr(raw_response, 'content'):
                        raw_content = raw_response.content
                        logger.warning(
                            f"[STRUCTURED-OUTPUT-FALLBACK] schema={schema.__name__} | "
                            f"Attempting legacy JSON parse on raw content | "
                            f"raw_len={len(raw_content) if raw_content else 0}"
                        )
                        # Try legacy JSON parsing as fallback
                        try:
                            fallback_data = self._extract_json(raw_content)
                            logger.info(f"[STRUCTURED-OUTPUT-FALLBACK-SUCCESS] Parsed raw JSON successfully")
                            return fallback_data
                        except Exception as json_err:
                            logger.error(
                                f"[STRUCTURED-OUTPUT-FALLBACK-FAILED] "
                                f"JSON parse also failed: {json_err}"
                            )

                    # E2 FIX: Ultimate fallback to legacy JSON mode
                    logger.warning(
                        f"[E2-LEGACY-FALLBACK] schema={schema.__name__} | "
                        f"Structured output completely failed, retrying with legacy JSON mode"
                    )

                    try:
                        # Create new LLM with legacy JSON mode (response_mime_type)
                        legacy_llm_config = {
                            **self.base_llm_config,
                            "max_output_tokens": max_tokens,
                            "response_mime_type": "application/json"
                        }
                        legacy_llm = ChatGoogleGenerativeAI(**legacy_llm_config)

                        # Retry with same prompt but legacy mode
                        legacy_response = legacy_llm.invoke(messages)
                        legacy_elapsed = time.time() - start_time

                        logger.info(
                            f"[E2-LEGACY-RESPONSE] elapsed={legacy_elapsed:.2f}s | "
                            f"content_len={len(legacy_response.content)}"
                        )

                        # Parse legacy JSON response
                        legacy_data = self._extract_json(legacy_response.content)
                        logger.info(f"[E2-LEGACY-SUCCESS] Successfully parsed legacy JSON response")
                        return legacy_data

                    except Exception as legacy_err:
                        logger.error(
                            f"[E2-LEGACY-FAILED] Legacy fallback also failed: {legacy_err}"
                        )
                        raise ValueError(
                            f"Both structured output and legacy JSON mode failed for schema {schema.__name__}. "
                            f"Structured: None response. Legacy: {str(legacy_err)[:100]}"
                        )

                # Convert to dict for consistent interface
                if hasattr(structured_response, 'model_dump'):
                    return structured_response.model_dump()
                elif hasattr(structured_response, 'dict'):
                    return structured_response.dict()
                else:
                    return dict(structured_response)
            
            # Legacy JSON parsing (when no schema provided)
            # Create messages
            messages = [
                SystemMessage(content=system_message),
                HumanMessage(content=prompt)
            ]

            # Generate response
            response = llm.invoke(messages)
            content = response.content
            elapsed = time.time() - start_time

            # Log response details
            logger.info(
                f"[AI-RESPONSE] elapsed={elapsed:.2f}s | "
                f"content_len={len(content)} chars (~{len(content)//4} tokens) | "
                f"starts_with={_truncate(content[:50], 50)} | "
                f"ends_with={_truncate(content[-50:] if len(content) > 50 else content, 50)}"
            )

            # Extract and validate JSON
            if response_type == "json":
                data = self._extract_json(content)
                logger.debug(
                    f"[AI-PARSED] keys={list(data.keys()) if isinstance(data, dict) else 'non-dict'}"
                )
                return data
            else:
                return {"raw_content": content}

        except Exception as e:
            elapsed = time.time() - start_time
            logger.error(
                f"[AI-ERROR] elapsed={elapsed:.2f}s | "
                f"error_type={type(e).__name__} | "
                f"error={str(e)[:200]}"
            )
            raise
    
    def _determine_optimal_tokens(self, prompt: str, system_message: str) -> int:
        """
        Determine optimal token limit based on content complexity.

        Returns:
            Appropriate max_output_tokens value
        """
        # Analyze prompt content to estimate complexity
        content_indicators = {
            # Weekly plans need more tokens
            'weekly': ['week', '7 days', 'monday', 'tuesday', 'wednesday'],
            # Multiple suggestions with full details (ingredients, recipe steps)
            'suggestions': ['suggestions', 'meal ideas', 'recipe_steps', 'ingredients (array'],
            # Multiple meals need moderate tokens
            'daily_multiple': ['breakfast', 'lunch', 'dinner', 'snack'],
            # Single meals need fewer tokens
            'single': ['single meal', 'one meal', 'generate a meal']
        }

        combined_text = (prompt + " " + system_message).lower()

        # Check for weekly plan indicators
        if any(indicator in combined_text for indicator in content_indicators['weekly']):
            logger.debug("Detected weekly plan generation - using high token limit")
            return 8000  # Increased back to 8000 for complete weekly plans

        # Check for multiple suggestions with full recipe details
        if any(indicator in combined_text for indicator in content_indicators['suggestions']):
            # Extract number of suggestions requested - handle formats like:
            # "3 meal suggestions", "exactly 3 different breakfast meal suggestions"
            suggestion_count_match = re.search(
                r'(?:exactly\s+)?(\d+)\s+(?:\w+\s+)*(?:meal\s+)?suggestions?',
                combined_text
            )
            if suggestion_count_match:
                count = int(suggestion_count_match.group(1))
                # Each full suggestion with ingredients + instructions + seasonings ~1500 tokens
                tokens = max(4000, count * 1500)
                logger.debug(f"Detected {count} meal suggestions - using {tokens} token limit")
                return min(tokens, 8000)  # Cap at 8000
            logger.debug("Detected meal suggestions generation - using medium-high token limit")
            return 5000  # Default for suggestions with full details (increased from 3500)

        # Check for daily multiple meals
        meal_types_found = sum(1 for indicator in content_indicators['daily_multiple']
                              if indicator in combined_text)
        if meal_types_found >= 3:
            logger.debug("Detected daily multiple meal generation - using medium token limit")
            return 3000  # Medium for daily plans with multiple meals

        # Single meal or simple requests
        logger.debug("Detected simple meal generation - using low token limit")
        return 1500  # Conservative for single meals
    
    def _extract_json(self, content: str) -> Dict[str, Any]:
        """Extract and validate JSON from AI response with better error handling."""
        logger.debug(
            f"[JSON-EXTRACT-START] content_len={len(content)} | "
            f"first_char={repr(content[0]) if content else 'empty'} | "
            f"last_char={repr(content[-1]) if content else 'empty'}"
        )

        try:
            # Direct JSON parsing (works with response_mime_type="application/json")
            result = json.loads(content)
            logger.debug("[JSON-EXTRACT] direct parse success")
            return result
        except json.JSONDecodeError as e:
            logger.warning(
                f"[JSON-PARSE-FAIL-DIRECT] error={e.msg} | "
                f"pos={e.pos} | "
                f"line={e.lineno} | "
                f"col={e.colno} | "
                f"context={_truncate(content[max(0, e.pos-30):e.pos+30], 60)}"
            )

            # Try to fix common JSON issues
            cleaned_content = self._clean_json_content(content)
            if cleaned_content:
                logger.debug(
                    f"[JSON-CLEAN] original_len={len(content)} | "
                    f"cleaned_len={len(cleaned_content)} | "
                    f"diff={len(content) - len(cleaned_content)}"
                )
                try:
                    result = json.loads(cleaned_content)
                    logger.info("[JSON-EXTRACT] cleaned parse success")
                    return result
                except json.JSONDecodeError as e2:
                    logger.warning(
                        f"[JSON-PARSE-FAIL-CLEANED] error={e2.msg} | "
                        f"pos={e2.pos} | "
                        f"context={_truncate(cleaned_content[max(0, e2.pos-30):e2.pos+30], 60)}"
                    )

            # Fallback: try to find JSON in markdown code block
            json_match = re.search(r'```json\s*(.*?)\s*```', content, re.DOTALL)
            if json_match:
                json_content = json_match.group(1).strip()
                logger.debug(
                    f"[JSON-MARKDOWN] found markdown block | "
                    f"extracted_len={len(json_content)}"
                )
                try:
                    result = json.loads(json_content)
                    logger.info("[JSON-EXTRACT] markdown parse success")
                    return result
                except json.JSONDecodeError as e3:
                    logger.warning(
                        f"[JSON-PARSE-FAIL-MARKDOWN] error={e3.msg} | pos={e3.pos}"
                    )

            # Last resort: find any JSON-like structure
            json_match = re.search(r'\{.*\}', content, re.DOTALL)
            if json_match:
                json_content = json_match.group(0)
                logger.debug(
                    f"[JSON-REGEX] found JSON structure | "
                    f"extracted_len={len(json_content)}"
                )
                try:
                    cleaned_json = self._clean_json_content(json_content)
                    if cleaned_json:
                        result = json.loads(cleaned_json)
                        logger.info("[JSON-EXTRACT] regex+clean parse success")
                        return result
                except json.JSONDecodeError as e4:
                    logger.warning(
                        f"[JSON-PARSE-FAIL-REGEX] error={e4.msg} | pos={e4.pos}"
                    )

            # Log the problematic content for debugging (truncated)
            content_preview = content[:500] + "..." if len(content) > 500 else content
            logger.error(
                f"[JSON-EXTRACT-FAILED] all parsing attempts failed | "
                f"content_preview={content_preview}"
            )
            raise ValueError(f"Could not extract valid JSON from response: {str(e)}")
    
    def _clean_json_content(self, content: str) -> str:
        """
        Clean and recover truncated JSON from token limit cutoffs.
        Strategy: Find last complete suggestion object and close structures.
        """
        if not content.strip():
            logger.debug("[JSON-CLEAN] empty content, returning empty")
            return ""

        original_len = len(content)
        content = content.strip()

        # Strategy: Find positions of complete top-level objects in suggestions array
        # Look for pattern: complete {...} objects at depth 2 (inside suggestions array)

        in_string = False
        escape_next = False
        depth = 0  # Brace depth
        bracket_depth = 0  # Bracket depth
        last_complete_suggestion_end = -1
        object_start_depth = -1
        complete_objects_count = 0
        root_object_end = -1  # Position where root JSON object ends

        i = 0
        while i < len(content):
            char = content[i]

            if escape_next:
                escape_next = False
                i += 1
                continue

            if char == '\\' and in_string:
                escape_next = True
                i += 1
                continue

            if char == '"':
                in_string = not in_string
                i += 1
                continue

            if in_string:
                i += 1
                continue

            # Track structure depth
            if char == '{':
                depth += 1
                # Track when we enter a suggestion object (depth 2, inside suggestions array)
                if depth == 2 and bracket_depth == 1:
                    object_start_depth = depth
            elif char == '}':
                # Check if we're closing a suggestion object
                if depth == 2 and object_start_depth == 2:
                    last_complete_suggestion_end = i + 1
                    complete_objects_count += 1
                    object_start_depth = -1
                depth = max(0, depth - 1)
                # Track when root object closes (depth returns to 0)
                if depth == 0 and bracket_depth == 0 and root_object_end == -1:
                    root_object_end = i + 1
            elif char == '[':
                bracket_depth += 1
            elif char == ']':
                bracket_depth = max(0, bracket_depth - 1)
                # Track when root array closes
                if depth == 0 and bracket_depth == 0 and root_object_end == -1:
                    root_object_end = i + 1

            i += 1

        # Check if JSON is incomplete (unclosed structures or in string)
        is_incomplete = in_string or depth > 0 or bracket_depth > 0

        logger.debug(
            f"[JSON-CLEAN-ANALYSIS] original_len={original_len} | "
            f"in_string={in_string} | "
            f"unclosed_braces={depth} | "
            f"unclosed_brackets={bracket_depth} | "
            f"complete_objects={complete_objects_count} | "
            f"last_complete_pos={last_complete_suggestion_end} | "
            f"root_object_end={root_object_end} | "
            f"is_incomplete={is_incomplete}"
        )

        # If there's extra text after a complete JSON object, truncate it
        if not is_incomplete and root_object_end > 0 and root_object_end < len(content):
            extra_text = content[root_object_end:].strip()
            if extra_text:
                logger.debug(
                    f"[JSON-CLEAN-EXTRA-TEXT] removing {len(content) - root_object_end} chars "
                    f"after complete JSON at pos {root_object_end}"
                )
                content = content[:root_object_end]

        # Always fix trailing commas before closing braces/brackets (common AI output issue)
        original_content = content
        content = re.sub(r',(\s*[}\]])', r'\1', content)
        if content != original_content:
            logger.debug("[JSON-CLEAN-TRAILING-COMMA] removed trailing comma before closing brace/bracket")

        # Fix missing commas between array elements or object properties (common AI output issue)
        # These patterns use }\s+{ or ]\s+" to ensure there's whitespace (newlines) between
        # which indicates structure boundaries, not content inside strings
        original_content = content

        # Pattern: } followed by whitespace (including newline) then { (missing comma between objects)
        content = re.sub(r'\}(\s*\n\s*)\{', r'},\1{', content)

        # Pattern: ] followed by whitespace (including newline) then [ (missing comma between arrays)
        content = re.sub(r'\](\s*\n\s*)\[', r'],\1[', content)

        # Pattern: } followed by whitespace (including newline) then " (object end, then property key)
        content = re.sub(r'\}(\s*\n\s*)"', r'},\1"', content)

        # Pattern: ] followed by whitespace (including newline) then " (array end, then property key)
        content = re.sub(r'\](\s*\n\s*)"', r'],\1"', content)

        # Also handle single-line JSON with spaces (but be conservative - require at least 2 spaces)
        content = re.sub(r'\}(  +)\{', r'},\1{', content)
        content = re.sub(r'\](  +)\[', r'],\1[', content)

        if content != original_content:
            logger.debug("[JSON-CLEAN-MISSING-COMMA] added missing commas between JSON structures")

        if is_incomplete and last_complete_suggestion_end > 0:
            # Truncate to last complete suggestion
            truncated_len = len(content) - last_complete_suggestion_end
            content = content[:last_complete_suggestion_end]
            # Close the suggestions array and root object
            content += ']}'
            logger.info(
                f"[JSON-CLEAN-RECOVERY] truncated {truncated_len} chars | "
                f"kept {last_complete_suggestion_end} chars | "
                f"preserved {complete_objects_count} complete objects | "
                f"added closing ']}}'"
            )
        elif is_incomplete:
            # No complete suggestions found, try simpler recovery
            logger.warning(
                f"[JSON-CLEAN-FALLBACK] no complete objects found | "
                f"attempting simple recovery"
            )
            # Find last complete key-value pair
            last_valid = self._find_last_valid_json_position(content)
            if last_valid > 0:
                content = content[:last_valid]
                logger.debug(
                    f"[JSON-CLEAN-TRUNCATE] cut at last_valid={last_valid}"
                )

            # Remove trailing incomplete content
            content = re.sub(r',\s*$', '', content)
            content = re.sub(r':\s*$', ': null', content)  # Fix hanging colons
            content = re.sub(r',(\s*[}\]])', r'\1', content)

            # Close structures
            content = self._close_json_structures(content)
            logger.debug(
                f"[JSON-CLEAN-CLOSED] final_len={len(content)}"
            )

        return content

    def _find_last_valid_json_position(self, content: str) -> int:
        """Find position after last complete JSON value."""
        in_string = False
        escape_next = False
        last_valid = 0

        for i, char in enumerate(content):
            if escape_next:
                escape_next = False
                continue
            if char == '\\' and in_string:
                escape_next = True
                continue
            if char == '"':
                in_string = not in_string
                if not in_string:  # Just closed a string
                    last_valid = i + 1
                continue
            if in_string:
                continue
            if char in '}]':
                last_valid = i + 1
            elif char == ',':
                last_valid = i

        return last_valid

    def _close_json_structures(self, content: str) -> str:
        """Close any unclosed JSON structures."""
        in_string = False
        escape_next = False
        structure_stack = []

        for char in content:
            if escape_next:
                escape_next = False
                continue
            if char == '\\' and in_string:
                escape_next = True
                continue
            if char == '"':
                in_string = not in_string
                continue
            if in_string:
                continue
            if char in '{[':
                structure_stack.append(char)
            elif char == '}' and structure_stack and structure_stack[-1] == '{':
                structure_stack.pop()
            elif char == ']' and structure_stack and structure_stack[-1] == '[':
                structure_stack.pop()

        # Close in reverse order
        for opener in reversed(structure_stack):
            content += ']' if opener == '[' else '}'

        return content
</file>

<file path="src/infra/config/settings.py">
"""
Application configuration settings loaded from environment variables.
"""
from functools import lru_cache

from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict


class Settings(BaseSettings):
    """Centralized application settings."""

    # General application settings
    ENVIRONMENT: str = Field(default="development")
    FAIL_ON_MIGRATION_ERROR: bool = Field(default=False)
    FAIL_ON_CACHE_ERROR: bool = Field(default=False)
    AUTO_MIGRATE: bool = Field(default=True)
    MIGRATION_TIMEOUT: int = Field(default=60)
    MIGRATION_RETRY_ATTEMPTS: int = Field(default=3)
    MIGRATION_RETRY_DELAY: float = Field(default=2.0)

    # Database configuration
    DATABASE_URL: str | None = Field(default=None)
    DB_USER: str = Field(default="nutree")
    DB_PASSWORD: str = Field(default="changeme")
    DB_HOST: str = Field(default="localhost")
    DB_PORT: int = Field(default=3306)
    DB_NAME: str = Field(default="nutree")

    # SSL controls
    DB_SSL_ENABLED: bool = Field(default=True)
    DB_SSL_VERIFY_CERT: bool = Field(default=False)
    DB_SSL_VERIFY_IDENTITY: bool = Field(default=False)

    # Connection pool tuning
    UVICORN_WORKERS: int = Field(default=4)
    POOL_SIZE_PER_WORKER: int = Field(default=5)
    POOL_MAX_OVERFLOW: int = Field(default=10)
    POOL_TIMEOUT: int = Field(default=30)
    POOL_RECYCLE: int = Field(default=300)
    POOL_ECHO: bool = Field(default=False)

    # Redis configuration
    REDIS_HOST: str = Field(default="localhost")
    REDIS_PORT: int = Field(default=6379)
    REDIS_DB: int = Field(default=0)
    REDIS_PASSWORD: str | None = Field(default=None)
    REDIS_SSL: bool = Field(default=False)
    REDIS_MAX_CONNECTIONS: int = Field(default=50)

    # Cache configuration
    CACHE_ENABLED: bool = Field(default=True)
    CACHE_DEFAULT_TTL: int = Field(default=3600)  # 1 hour

    # Firebase
    FIREBASE_CREDENTIALS: str | None = Field(default=None)
    FIREBASE_SERVICE_ACCOUNT_JSON: str | None = Field(default=None)
    FIREBASE_SERVICE_ACCOUNT_PATH: str | None = Field(default=None)

    # External APIs & integrations
    GOOGLE_API_KEY: str | None = Field(default=None)
    USDA_FDC_API_KEY: str | None = Field(default=None)
    PINECONE_API_KEY: str | None = Field(default=None)
    
    # LLM Provider configuration
    LLM_PROVIDER: str | None = Field(default=None, description="LLM provider to use: 'openai' or 'gemini'. Auto-detects if not set.")
    OPENAI_MODEL: str = Field(default="gpt-3.5-turbo", description="OpenAI model to use")
    GEMINI_MODEL: str = Field(default="gemini-2.5-flash", description="Gemini model to use (same as food scanning)")
    
    # Chat/AI configuration
    CHAT_ENABLE_STRUCTURED_RESPONSES: bool = Field(default=True, description="Enable structured JSON responses from chat AI")
    CHAT_ENABLE_WELCOME_MESSAGE: bool = Field(default=True, description="Auto-generate welcome message on thread creation")
    REVENUECAT_SECRET_API_KEY: str | None = Field(default=None)
    REVENUECAT_WEBHOOK_SECRET: str | None = Field(default=None)
    CLOUDINARY_CLOUD_NAME: str | None = Field(default=None)
    CLOUDINARY_API_KEY: str | None = Field(default=None)
    CLOUDINARY_API_SECRET: str | None = Field(default=None)

    # Feature flags / development toggles
    USE_MOCK_STORAGE: int = Field(default=0)
    DEV_USER_FIREBASE_UID: str = Field(default="dev_firebase_uid")
    DEV_USER_EMAIL: str = Field(default="dev@example.com")
    DEV_USER_USERNAME: str = Field(default="dev_user")

    # Additional fields from actual .env
    UPLOADS_DIR: str | None = Field(default=None)
    FCM_CREDENTIALS_PATH: str | None = Field(default=None)
    SMTP_HOST: str | None = Field(default=None)
    SMTP_PORT: int | None = Field(default=None)
    SMTP_USERNAME: str | None = Field(default=None)
    SMTP_PASSWORD: str | None = Field(default=None)
    EMAIL_FROM_ADDRESS: str | None = Field(default=None)
    EMAIL_FROM_NAME: str | None = Field(default=None)

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore"  # Allow extra fields without validation errors
    )

    @property
    def redis_url(self) -> str:
        """Construct a Redis URL from the configured components."""
        protocol = "rediss" if self.REDIS_SSL else "redis"
        auth = f":{self.REDIS_PASSWORD}@" if self.REDIS_PASSWORD else ""
        return f"{protocol}://{auth}{self.REDIS_HOST}:{self.REDIS_PORT}/{self.REDIS_DB}"


@lru_cache
def get_settings() -> Settings:
    """Return a cached Settings instance."""
    return Settings()


settings = get_settings()
</file>

<file path="src/infra/database/models/__init__.py">
"""
Database models package.

This module imports all database models from their respective submodules
to provide a centralized access point.
"""
# Base models
from .base import BaseMixin, PrimaryEntityMixin, SecondaryEntityMixin, TimestampMixin
# Enums
from .enums import (
    MealStatusEnum,
    DietaryPreferenceEnum,
    FitnessGoalEnum,
    MealTypeEnum,
    PlanDurationEnum,
    ActivityLevelEnum,
    SexEnum,
    GoalEnum,
)
# Meal models
from .meal.meal import Meal
from .meal.meal_image import MealImage
# Meal planning models
from .meal_planning.meal_plan import MealPlan
from .meal_planning.meal_plan_day import MealPlanDay
from .meal_planning.planned_meal import PlannedMeal
# Notification models
from .notification import NotificationPreferences, UserFcmToken
from .nutrition.food_item import FoodItem
# Nutrition models
from .nutrition.nutrition import Nutrition
from .subscription import Subscription
from .user.profile import UserProfile
# User models
from .user.user import User

__all__ = [
    # Base
    "BaseMixin",
    "PrimaryEntityMixin", 
    "SecondaryEntityMixin",
    "TimestampMixin",
    
    # Enums
    "MealStatusEnum",
    "DietaryPreferenceEnum",
    "FitnessGoalEnum",
    "MealTypeEnum",
    "PlanDurationEnum",
    "ActivityLevelEnum",
    "SexEnum",
    "GoalEnum",
    
    # User models
    "User",
    "UserProfile",
    "Subscription",
    
    # Nutrition models
    "Nutrition",
    "FoodItem",
    
    # Meal models
    "Meal",
    "MealImage",
    
    # Meal planning models
    "MealPlan",
    "MealPlanDay",
    "PlannedMeal",
    
    # Test models
    
    # Notification models
    "NotificationPreferences",
    "UserFcmToken",
]
</file>

<file path="src/infra/repositories/notification_repository.py">
"""Notification repository implementation."""
from datetime import datetime
from typing import List, Optional

from sqlalchemy.orm import Session

from src.domain.model.notification import UserFcmToken, NotificationPreferences
from src.domain.ports.notification_repository_port import NotificationRepositoryPort
from src.infra.database.config import SessionLocal
from src.infra.repositories.notification.fcm_token_operations import FcmTokenOperations
from src.infra.repositories.notification.notification_preferences_operations import NotificationPreferencesOperations
from src.infra.repositories.notification.reminder_query_builder import ReminderQueryBuilder


class NotificationRepository(NotificationRepositoryPort):
    """Implementation of the notification repository using SQLAlchemy."""

    def __init__(self, db: Optional[Session] = None):
        """Initialize with optional session dependency."""
        self.db = db
        self.fcm_ops = FcmTokenOperations()
        self.prefs_ops = NotificationPreferencesOperations()
        self.query_builder = ReminderQueryBuilder()

    def _get_db(self):
        """Get a database session, creating one if needed."""
        if self.db:
            return self.db
        else:
            return SessionLocal()

    def _close_db_if_created(self, db):
        """Close the database session if we created it."""
        if self.db is None and db is not None:
            db.close()

    # FCM Token operations
    def save_fcm_token(self, token: UserFcmToken) -> UserFcmToken:
        """Save an FCM token to the database."""
        db = self._get_db()
        try:
            return self.fcm_ops.save_fcm_token(db, token)
        finally:
            self._close_db_if_created(db)

    def find_fcm_token_by_token(self, fcm_token: str) -> Optional[UserFcmToken]:
        """Find an FCM token by the token string."""
        db = self._get_db()
        try:
            return self.fcm_ops.find_fcm_token_by_token(db, fcm_token)
        finally:
            self._close_db_if_created(db)

    def find_active_fcm_tokens_by_user(self, user_id: str) -> List[UserFcmToken]:
        """Find all active FCM tokens for a user."""
        db = self._get_db()
        try:
            return self.fcm_ops.find_active_fcm_tokens_by_user(db, user_id)
        finally:
            self._close_db_if_created(db)

    def deactivate_fcm_token(self, fcm_token: str) -> bool:
        """Deactivate an FCM token."""
        db = self._get_db()
        try:
            return self.fcm_ops.deactivate_fcm_token(db, fcm_token)
        finally:
            self._close_db_if_created(db)

    def delete_fcm_token(self, fcm_token: str) -> bool:
        """Delete an FCM token."""
        db = self._get_db()
        try:
            return self.fcm_ops.delete_fcm_token(db, fcm_token)
        finally:
            self._close_db_if_created(db)

    # Notification Preferences operations
    def save_notification_preferences(self, preferences: NotificationPreferences) -> NotificationPreferences:
        """Save notification preferences to the database."""
        db = self._get_db()
        try:
            return self.prefs_ops.save_notification_preferences(db, preferences)
        finally:
            self._close_db_if_created(db)

    def find_notification_preferences_by_user(self, user_id: str) -> Optional[NotificationPreferences]:
        """Find notification preferences by user ID."""
        db = self._get_db()
        try:
            return self.prefs_ops.find_notification_preferences_by_user(db, user_id)
        finally:
            self._close_db_if_created(db)

    def update_notification_preferences(self, user_id: str, preferences: NotificationPreferences) -> NotificationPreferences:
        """Update notification preferences for a user."""
        return self.save_notification_preferences(preferences)

    def delete_notification_preferences(self, user_id: str) -> bool:
        """Delete notification preferences for a user."""
        db = self._get_db()
        try:
            return self.prefs_ops.delete_notification_preferences(db, user_id)
        finally:
            self._close_db_if_created(db)

    # Utility operations
    def find_users_for_meal_reminder(self, meal_type: str, current_utc: datetime) -> List[str]:
        """Find user IDs who should receive meal reminders at current UTC time."""
        db = self._get_db()
        try:
            return self.query_builder.find_users_for_meal_reminder(db, meal_type, current_utc)
        finally:
            self._close_db_if_created(db)

    def find_users_for_sleep_reminder(self, current_utc: datetime) -> List[str]:
        """Find user IDs who should receive sleep reminders at current UTC time."""
        db = self._get_db()
        try:
            return self.query_builder.find_users_for_sleep_reminder(db, current_utc)
        finally:
            self._close_db_if_created(db)

    def find_users_for_water_reminder(self, current_utc: datetime) -> List[str]:
        """Find users who should receive water reminders based on interval and quiet hours."""
        db = self._get_db()
        try:
            return self.query_builder.find_users_for_water_reminder(db, current_utc)
        finally:
            self._close_db_if_created(db)

    def update_last_water_reminder(self, user_id: str, sent_at: datetime) -> bool:
        """Update last water reminder timestamp for user."""
        db = self._get_db()
        try:
            return self.prefs_ops.update_last_water_reminder(db, user_id, sent_at)
        finally:
            self._close_db_if_created(db)
</file>

<file path="src/api/routes/v1/users.py">
"""
Users API endpoints - Firebase integration for user management.
Handles user authentication sync, profile retrieval, and status management.
"""
import logging

from fastapi import APIRouter, Depends

from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.schemas.request.user_requests import (
    UserSyncRequest,
    UserUpdateLastAccessedRequest
)
from src.api.schemas.response.user_responses import (
    UserSyncResponse,
    UserProfileResponse,
    UserStatusResponse,
    UserUpdateResponse,
    OnboardingCompletionResponse,
    UserDeleteResponse
)
from src.app.commands.user import CompleteOnboardingCommand, DeleteUserCommand
from src.app.commands.user.sync_user_command import (
    SyncUserCommand,
    UpdateUserLastAccessedCommand
)
from src.app.queries.user.get_user_by_firebase_uid_query import GetUserByFirebaseUidQuery
from src.app.queries.user.get_user_onboarding_status_query import GetUserOnboardingStatusQuery
from src.infra.event_bus import EventBus

logger = logging.getLogger(__name__)
router = APIRouter(prefix="/v1/users", tags=["Users"])


@router.post("/sync", response_model=UserSyncResponse)
async def sync_user_from_firebase(
    request: UserSyncRequest,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Sync user data from Firebase authentication.
    
    Creates a new user if they don't exist, or updates existing user data.
    This endpoint is called automatically when a user signs in through Firebase.
    
    - **firebase_uid**: Firebase user unique identifier
    - **email**: User email address
    - **phone_number**: User phone number (optional)
    - **display_name**: User display name from Firebase (optional)
    - **photo_url**: User profile photo URL (optional)
    - **provider**: Authentication provider (phone, google)
    """
    logger.info(
        f"Starting user sync for firebase_uid: {request.firebase_uid}",
        extra={
            "firebase_uid": request.firebase_uid,
            "provider": request.provider,
            "has_email": bool(request.email),
            "has_phone": bool(request.phone_number)
        }
    )
    try:
        # Create sync command
        command = SyncUserCommand(
            firebase_uid=request.firebase_uid,
            email=request.email,
            phone_number=request.phone_number,
            display_name=request.display_name,
            photo_url=request.photo_url,
            provider=request.provider,
            username=request.username,
            first_name=request.first_name,
            last_name=request.last_name
        )
        
        # Send command
        result = await event_bus.send(command)
        
        # Map result to response
        user_data = result["user"]
        
        logger.info(
            f"User sync completed for firebase_uid: {request.firebase_uid}",
            extra={
                "firebase_uid": request.firebase_uid,
                "user_created": result["created"],
                "user_updated": result["updated"]
            }
        )

        return UserSyncResponse(
            user=UserProfileResponse(**user_data),
            created=result["created"],
            updated=result["updated"],
            message=result["message"]
        )
        
    except Exception as e:
        logger.error(
            f"User sync failed for firebase_uid: {request.firebase_uid}",
            extra={
                "firebase_uid": request.firebase_uid,
                "provider": request.provider,
                "exception_type": type(e).__name__
            }
        )
        raise handle_exception(e)


@router.get("/firebase/{firebase_uid}", response_model=UserProfileResponse)
async def get_user_by_firebase_uid(
    firebase_uid: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get user profile by Firebase UID.
    
    Retrieves complete user profile information using Firebase UID.
    This is the primary way to get user data after Firebase authentication.
    
    - **firebase_uid**: Firebase user unique identifier
    """
    try:
        # Create query
        query = GetUserByFirebaseUidQuery(firebase_uid=firebase_uid)
        
        # Send query
        result = await event_bus.send(query)
        
        # Return user profile response
        return UserProfileResponse(**result)
        
    except Exception as e:
        raise handle_exception(e)


@router.get("/firebase/{firebase_uid}/status", response_model=UserStatusResponse)
async def get_user_onboarding_status(
    firebase_uid: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get user's onboarding status by Firebase UID.
    
    Returns minimal user status information for onboarding flow decisions.
    Used by the mobile app to determine if user needs to complete onboarding.
    
    - **firebase_uid**: Firebase user unique identifier
    """
    try:
        # Create query
        query = GetUserOnboardingStatusQuery(firebase_uid=firebase_uid)
        
        # Send query
        result = await event_bus.send(query)
        
        # Return status response
        return UserStatusResponse(**result)
        
    except Exception as e:
        raise handle_exception(e)


@router.put("/firebase/{firebase_uid}/last-accessed", response_model=UserUpdateResponse)
async def update_user_last_accessed(
    firebase_uid: str,
    request: UserUpdateLastAccessedRequest,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Update user's last accessed timestamp.
    
    Updates the last_accessed field for activity tracking and analytics.
    Called periodically by the mobile app to track user engagement.
    
    - **firebase_uid**: Firebase user unique identifier
    - **last_accessed**: Timestamp of last access (optional, defaults to now)
    """
    try:
        # Create command
        command = UpdateUserLastAccessedCommand(
            firebase_uid=firebase_uid,
            last_accessed=request.last_accessed
        )
        
        # Send command
        result = await event_bus.send(command)
        
        # Return update response
        return UserUpdateResponse(**result)
        
    except Exception as e:
        raise handle_exception(e)


@router.put("/firebase/{firebase_uid}/onboarding/complete", response_model=OnboardingCompletionResponse)
async def complete_onboarding(
    firebase_uid: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Mark user onboarding as completed.

    Sets the user's onboarding status to completed if it's currently false.
    This endpoint is called when the user finishes the onboarding flow in the mobile app.

    - **firebase_uid**: Firebase user unique identifier
    """
    try:
        # Create command
        command = CompleteOnboardingCommand(firebase_uid=firebase_uid)

        # Send command
        result = await event_bus.send(command)

        # Return completion response
        return OnboardingCompletionResponse(**result)

    except Exception as e:
        raise handle_exception(e)


@router.delete("/firebase/{firebase_uid}", response_model=UserDeleteResponse)
async def delete_user_account(
    firebase_uid: str,
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Delete user account (soft delete in DB, hard delete in Firebase).

    Performs complete account deletion:
    - Soft deletes user in database (sets is_active=False)
    - Anonymizes user data for GDPR compliance
    - Hard deletes user from Firebase Authentication

    This action cannot be undone. All user data will be anonymized and
    the account will be marked as inactive.

    - **firebase_uid**: Firebase user unique identifier
    """
    logger.info(
        f"Starting account deletion for firebase_uid: {firebase_uid}",
        extra={"firebase_uid": firebase_uid}
    )
    try:
        # Create delete command
        command = DeleteUserCommand(firebase_uid=firebase_uid)

        # Send command
        result = await event_bus.send(command)

        logger.info(
            f"Account deletion completed for firebase_uid: {firebase_uid}",
            extra={
                "firebase_uid": firebase_uid,
                "deleted": result["deleted"]
            }
        )

        # Return deletion response
        return UserDeleteResponse(**result)

    except Exception as e:
        logger.error(
            f"Account deletion failed for firebase_uid: {firebase_uid}",
            extra={
                "firebase_uid": firebase_uid,
                "exception_type": type(e).__name__
            }
        )
        raise handle_exception(e)
</file>

<file path="src/api/schemas/request/user_profile_update_requests.py">
from enum import Enum

from pydantic import BaseModel, Field


class GoalEnum(str, Enum):
    cut = "cut"
    bulk = "bulk"
    recomp = "recomp"


class UpdateFitnessGoalRequest(BaseModel):
    goal: GoalEnum = Field(..., description="New fitness goal")


class UpdateMetricsRequest(BaseModel):
    """Unified update for weight, activity level, body fat, and fitness goal."""
    weight_kg: float | None = Field(None, description="Weight in kg", gt=0)
    activity_level: str | None = Field(None, description="Activity level")
    body_fat_percent: float | None = Field(None, description="Body fat percentage", ge=0, le=70)
    fitness_goal: GoalEnum | None = Field(None, description="Fitness goal (cut, bulk, recomp)")
    override: bool = Field(False, description="Override goal cooldown restriction")
</file>

<file path="src/domain/services/meal_plan_service.py">
import json
import logging
import os
from datetime import date, timedelta
from typing import List, Dict, Optional

from langchain_core.messages import HumanMessage, SystemMessage

from src.domain.model.meal_planning import (
    MealPlan, PlannedMeal, DayPlan, UserPreferences,
    FitnessGoal, MealType, PlanDuration
)

logger = logging.getLogger(__name__)


class MealPlanService:
    """Service for generating and managing meal plans using AI"""
    
    def __init__(self):
        self.google_api_key = os.getenv("GOOGLE_API_KEY")
        if not self.google_api_key:
            raise ValueError("GOOGLE_API_KEY environment variable not set")
        
        self._model = None  # Lazy load
        
    @property
    def model(self):
        """Lazy load the ChatGoogleGenerativeAI model."""
        if self._model is None:
            from langchain_google_genai import ChatGoogleGenerativeAI
            self._model = ChatGoogleGenerativeAI(
                model=os.getenv("GEMINI_MODEL", "gemini-2.5-flash"),
                temperature=0.8,
                max_output_tokens=1000,
                google_api_key=self.google_api_key,
                convert_system_message_to_human=True
            )
        return self._model
    
    def generate_meal_plan(self, user_id: str, preferences: UserPreferences) -> MealPlan:
        """Generate a complete meal plan based on user preferences"""
        logger.info(f"Generating meal plan for user {user_id}")
        
        # Determine number of days
        num_days = 7 if preferences.plan_duration == PlanDuration.WEEKLY else 1
        start_date = date.today()
        
        # Generate meals for each day
        days = []
        for i in range(num_days):
            current_date = start_date + timedelta(days=i)
            is_weekend = current_date.weekday() >= 5
            
            day_meals = self._generate_day_meals(
                preferences=preferences,
                is_weekend=is_weekend
            )
            
            days.append(DayPlan(date=current_date, meals=day_meals))
        
        # Create and return meal plan
        meal_plan = MealPlan(
            user_id=user_id,
            preferences=preferences,
            days=days
        )
        
        logger.info(f"Generated meal plan {meal_plan.plan_id} with {len(days)} days")
        return meal_plan
    
    def _generate_day_meals(self, preferences: UserPreferences, is_weekend: bool) -> List[PlannedMeal]:
        """Generate meals for a single day"""
        meals = []
        
        # Determine cooking time based on day type
        max_cooking_time = preferences.cooking_time_weekend if is_weekend else preferences.cooking_time_weekday
        
        # Generate main meals
        for i in range(preferences.meals_per_day):
            if i == 0:
                meal_type = MealType.BREAKFAST
            elif i == 1:
                meal_type = MealType.LUNCH
            elif i == 2:
                meal_type = MealType.DINNER
            else:
                meal_type = MealType.LUNCH  # Extra meals default to lunch type
            
            meal = self._generate_single_meal(
                meal_type=meal_type,
                preferences=preferences,
                max_cooking_time=max_cooking_time
            )
            meals.append(meal)
        
        # Generate snacks
        for i in range(preferences.snacks_per_day):
            snack = self._generate_single_meal(
                meal_type=MealType.SNACK,
                preferences=preferences,
                max_cooking_time=15  # Snacks should be quick
            )
            meals.append(snack)
        
        return meals
    
    def _generate_single_meal(self, meal_type: MealType, preferences: UserPreferences, 
                             max_cooking_time: int) -> PlannedMeal:
        """Generate a single meal using Google Gemini AI"""
        
        prompt = self._build_meal_generation_prompt(meal_type, preferences, max_cooking_time)
        
        try:
            messages = [
                SystemMessage(content="You are a professional meal planning assistant that always returns valid JSON."),
                HumanMessage(content=prompt)
            ]
            
            response = self.model.invoke(messages)
            content = response.content
            
            # Extract JSON from the response
            try:
                # Try to parse the entire response as JSON
                meal_data = json.loads(content)
            except json.JSONDecodeError:
                # If that fails, try to find and extract just the JSON part
                import re
                json_match = re.search(r'```json(.*?)```', content, re.DOTALL)
                if json_match:
                    json_str = json_match.group(1).strip()
                    meal_data = json.loads(json_str)
                else:
                    # As a last resort, try to find any JSON-like structure
                    json_match = re.search(r'\{.*\}', content, re.DOTALL)
                    if json_match:
                        json_str = json_match.group(0)
                        meal_data = json.loads(json_str)
                    else:
                        raise ValueError("Could not extract JSON from response")
            
            return PlannedMeal(
                meal_type=meal_type,
                name=meal_data["name"],
                description=meal_data["description"],
                prep_time=meal_data["prep_time"],
                cook_time=meal_data["cook_time"],
                calories=meal_data["calories"],
                protein=meal_data["protein"],
                carbs=meal_data["carbs"],
                fat=meal_data["fat"],
                ingredients=meal_data["ingredients"],
                instructions=meal_data["instructions"],
                is_vegetarian=meal_data.get("is_vegetarian", False),
                is_vegan=meal_data.get("is_vegan", False),
                is_gluten_free=meal_data.get("is_gluten_free", False),
                cuisine_type=meal_data.get("cuisine_type")
            )
            
        except Exception as e:
            logger.error(f"Error generating meal: {str(e)}")
            # Return a fallback meal
            return self._get_fallback_meal(meal_type)
    
    def _build_meal_generation_prompt(self, meal_type: MealType, preferences: UserPreferences, 
                                    max_cooking_time: int) -> str:
        """Build prompt for meal generation"""
        
        dietary_str = ", ".join([pref.value for pref in preferences.dietary_preferences])
        cuisines_str = ", ".join(preferences.favorite_cuisines) if preferences.favorite_cuisines else "any"
        disliked_str = ", ".join(preferences.disliked_ingredients) if preferences.disliked_ingredients else "none"
        allergies_str = ", ".join(preferences.allergies) if preferences.allergies else "none"
        
        fitness_goals = {
            FitnessGoal.BULK: "high protein (30-40g), moderate carbs, healthy fats",
            FitnessGoal.CUT: "moderate protein, lower carbs, controlled calories (300-500 for meals, 100-200 for snacks)",
            FitnessGoal.RECOMP: "balanced macros with high protein, appropriate portions"
        }
        
        nutrition_guidance = fitness_goals.get(preferences.fitness_goal, "balanced nutrition")
        
        prompt = f"""Generate a {meal_type.value} recipe with the following requirements:

Dietary Preferences: {dietary_str}
Allergies to avoid: {allergies_str}
Fitness Goal: {preferences.fitness_goal.value} - ensure {nutrition_guidance}
Maximum total cooking time: {max_cooking_time} minutes
Preferred cuisines: {cuisines_str}
Ingredients to avoid: {disliked_str}

Return ONLY a JSON object with this exact structure:
{{
    "name": "Recipe name",
    "description": "Brief appetizing description",
    "prep_time": 10,
    "cook_time": 20,
    "calories": 400,
    "protein": 25.5,
    "carbs": 35.2,
    "fat": 15.8,
    "ingredients": ["ingredient 1", "ingredient 2"],
    "instructions": ["Step 1", "Step 2"],
    "is_vegetarian": true/false,
    "is_vegan": true/false,
    "is_gluten_free": true/false,
    "cuisine_type": "Italian/Asian/Mexican/etc"
}}

Ensure the recipe is practical, delicious, and meets all dietary requirements."""
        
        return prompt
    
    def _get_fallback_meal(self, meal_type: MealType) -> PlannedMeal:
        """Return a simple fallback meal if AI generation fails"""
        fallback_meals = {
            MealType.BREAKFAST: {
                "name": "Greek Yogurt Parfait",
                "description": "Quick and healthy breakfast with berries and nuts",
                "prep_time": 5,
                "cook_time": 0,
                "calories": 300,
                "protein": 20,
                "carbs": 35,
                "fat": 10,
                "ingredients": ["Greek yogurt", "Mixed berries", "Granola", "Honey"],
                "instructions": ["Layer yogurt in a bowl", "Add berries", "Top with granola", "Drizzle with honey"],
                "is_vegetarian": True,
                "is_vegan": False,
                "is_gluten_free": False
            },
            MealType.LUNCH: {
                "name": "Quinoa Buddha Bowl",
                "description": "Nutritious bowl with quinoa, vegetables, and protein",
                "prep_time": 15,
                "cook_time": 20,
                "calories": 450,
                "protein": 18,
                "carbs": 55,
                "fat": 15,
                "ingredients": ["Quinoa", "Chickpeas", "Mixed vegetables", "Tahini dressing"],
                "instructions": ["Cook quinoa", "Roast vegetables", "Prepare chickpeas", "Assemble bowl", "Add dressing"],
                "is_vegetarian": True,
                "is_vegan": True,
                "is_gluten_free": True
            },
            MealType.DINNER: {
                "name": "Grilled Chicken with Vegetables",
                "description": "Simple grilled chicken with roasted seasonal vegetables",
                "prep_time": 10,
                "cook_time": 25,
                "calories": 400,
                "protein": 35,
                "carbs": 30,
                "fat": 12,
                "ingredients": ["Chicken breast", "Broccoli", "Carrots", "Olive oil", "Herbs"],
                "instructions": ["Season chicken", "Grill chicken", "Roast vegetables", "Serve together"],
                "is_vegetarian": False,
                "is_vegan": False,
                "is_gluten_free": True
            },
            MealType.SNACK: {
                "name": "Apple with Almond Butter",
                "description": "Quick and satisfying snack",
                "prep_time": 2,
                "cook_time": 0,
                "calories": 200,
                "protein": 7,
                "carbs": 25,
                "fat": 10,
                "ingredients": ["Apple", "Almond butter"],
                "instructions": ["Slice apple", "Serve with almond butter"],
                "is_vegetarian": True,
                "is_vegan": True,
                "is_gluten_free": True
            }
        }
        
        meal_data = fallback_meals.get(meal_type, fallback_meals[MealType.LUNCH])
        return PlannedMeal(meal_type=meal_type, **meal_data)
    
    def regenerate_meal(self, meal_plan: MealPlan, date: date, meal_id: str, 
                       additional_preferences: Optional[Dict] = None) -> PlannedMeal:
        """Regenerate a specific meal with optional additional preferences"""
        
        # Find the meal to replace
        day_plan = meal_plan.get_day(date)
        if not day_plan:
            raise ValueError(f"No meal plan found for date {date}")
        
        old_meal = None
        for meal in day_plan.meals:
            if meal.meal_id == meal_id:
                old_meal = meal
                break
        
        if not old_meal:
            raise ValueError(f"Meal {meal_id} not found in plan")
        
        # Generate new meal with same type
        is_weekend = date.weekday() >= 5
        max_cooking_time = (meal_plan.preferences.cooking_time_weekend if is_weekend 
                          else meal_plan.preferences.cooking_time_weekday)
        
        # Create modified preferences if additional preferences provided
        preferences = meal_plan.preferences
        if additional_preferences:
            # This is a simplified approach - in production, properly merge preferences
            pass
        
        new_meal = self._generate_single_meal(
            meal_type=old_meal.meal_type,
            preferences=preferences,
            max_cooking_time=max_cooking_time
        )
        
        # Replace in meal plan
        meal_plan.replace_meal(date, meal_id, new_meal)
        
        return new_meal
</file>

<file path="src/app/handlers/command_handlers/sync_user_command_handler.py">
"""
SyncUserCommandHandler - Individual handler file.
Auto-extracted for better maintainability.
"""
import logging
import re
from datetime import datetime
from typing import Dict, Any

from sqlalchemy.orm import Session

from src.app.commands.user.sync_user_command import SyncUserCommand
from src.app.events.base import EventHandler, handles
from src.infra.database.models.user import User

logger = logging.getLogger(__name__)


@handles(SyncUserCommand)
class SyncUserCommandHandler(EventHandler[SyncUserCommand, Dict[str, Any]]):
    """Handler for syncing user data from Firebase authentication."""

    def __init__(self, db: Session = None):
        self.db = db

    def set_dependencies(self, db: Session):
        """Set dependencies for dependency injection."""
        self.db = db

    async def handle(self, command: SyncUserCommand) -> Dict[str, Any]:
        """Sync user data from Firebase authentication."""
        if not self.db:
            raise RuntimeError("Database session not configured")

        try:
            # Check if user exists by firebase_uid
            existing_user = self.db.query(User).filter(
                User.firebase_uid == command.firebase_uid
            ).first()

            created = False
            updated = False

            if existing_user:
                # Update existing user
                updated = self._update_existing_user(existing_user, command)
                user = existing_user
                logger.info('Updated existing user')
            else:
                # Create new user
                user = self._create_new_user(command)
                created = True
                logger.info('Created new user')

            # Flush to get the user ID without committing the transaction
            self.db.flush()
            self.db.refresh(user)
            
            # Create default notification preferences for new user (before commit for atomicity)
            # Both user and preferences will be committed together in a single transaction
            if created:
                self._create_default_notification_preferences_without_commit(user.id)
            
            # Commit both user and notification preferences atomically
            self.db.commit()

            # Get subscription info if user has active premium
            subscription_info = None
            active_subscription = user.get_active_subscription()
            if active_subscription:
                subscription_info = {
                    "product_id": active_subscription.product_id,
                    "status": active_subscription.status,
                    "expires_at": active_subscription.expires_at,
                    "is_monthly": active_subscription.is_monthly(),
                    "is_yearly": active_subscription.is_yearly(),
                    "platform": active_subscription.platform
                }

            # Prepare response
            return {
                "user": {
                    "id": user.id,
                    "firebase_uid": user.firebase_uid,
                    "email": user.email,
                    "username": user.username,
                    "first_name": user.first_name,
                    "last_name": user.last_name,
                    "phone_number": user.phone_number,
                    "display_name": user.display_name,
                    "photo_url": user.photo_url,
                    "provider": user.provider,
                    "is_active": user.is_active,
                    "onboarding_completed": user.onboarding_completed,
                    "last_accessed": user.last_accessed,
                    "created_at": user.created_at,
                    "updated_at": user.updated_at,
                    "is_premium": user.is_premium(),
                    "subscription": subscription_info
                },
                "created": created,
                "updated": updated,
                "message": "User created successfully" if created else "User updated successfully" if updated else "User data up to date"
            }

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error syncing user data: {str(e)}")
            raise

    def _create_new_user(self, command: SyncUserCommand) -> User:
        """Create a new user from Firebase data."""
        # Generate username if not provided
        username = command.username or self._generate_username(command.email, command.display_name)

        # Ensure username is unique
        username = self._ensure_unique_username(username)

        # Extract names if not provided
        first_name, last_name = self._extract_names(command.display_name, command.first_name, command.last_name)

        # Create new user
        user = User(
            firebase_uid=command.firebase_uid,
            email=command.email,
            username=username,
            password_hash="",  # No password for Firebase users
            first_name=first_name,
            last_name=last_name,
            phone_number=command.phone_number,
            display_name=command.display_name,
            photo_url=command.photo_url,
            provider=command.provider,
            is_active=True,
            onboarding_completed=False,
        )

        self.db.add(user)
        return user

    def _update_existing_user(self, user: User, command: SyncUserCommand) -> bool:
        """Update existing user with new Firebase data."""
        updated = False

        # Update fields that might have changed
        if user.email != command.email:
            user.email = command.email
            updated = True

        if user.phone_number != command.phone_number:
            user.phone_number = command.phone_number
            updated = True

        if user.display_name != command.display_name:
            user.display_name = command.display_name
            updated = True

        if user.photo_url != command.photo_url:
            user.photo_url = command.photo_url
            updated = True

        if user.provider != command.provider:
            user.provider = command.provider
            updated = True

        # Always update last_accessed
        user.last_accessed = datetime.utcnow()
        updated = True

        return updated

    def _generate_username(self, email: str, display_name: str = None) -> str:
        """Generate a username from email or display name."""
        if display_name:
            # Use display name, remove spaces and special characters
            username = re.sub(r'[^a-zA-Z0-9]', '', display_name.lower())
        else:
            # Use email prefix
            username = email.split('@')[0]
            username = re.sub(r'[^a-zA-Z0-9]', '', username.lower())

        # Ensure minimum length
        if len(username) < 3:
            username = f"user{username}"

        # Limit length
        return username[:20]

    def _ensure_unique_username(self, base_username: str) -> str:
        """Ensure username is unique by appending numbers if needed."""
        username = base_username
        counter = 1

        while self.db.query(User).filter(User.username == username).first():
            username = f"{base_username}{counter}"
            counter += 1
            # Prevent infinite loop
            if counter > 999:
                username = f"{base_username}{datetime.utcnow().microsecond}"
                break

        return username

    def _extract_names(self, display_name: str = None, first_name: str = None, last_name: str = None):
        """Extract first and last names from display name or provided names."""
        if first_name and last_name:
            return first_name, last_name

        if display_name:
            name_parts = display_name.strip().split()
            if len(name_parts) >= 2:
                return name_parts[0], ' '.join(name_parts[1:])
            elif len(name_parts) == 1:
                return name_parts[0], None

        return first_name, last_name
    
    def _create_default_notification_preferences_without_commit(self, user_id: str):
        """Create default notification preferences for a new user without committing.
        
        This method adds notification preferences to the session but does not commit,
        allowing the caller to commit both user and preferences atomically.
        """
        # Guard against None user_id
        if not user_id:
            logger.warning("Cannot create notification preferences: user_id is None")
            return
        
        from src.domain.model.notification import NotificationPreferences
        from src.infra.database.models.notification import NotificationPreferences as DBNotificationPreferences
        
        # Create default preferences
        default_prefs = NotificationPreferences.create_default(user_id)
        
        # Create database model directly without using repository (to avoid auto-commit)
        db_prefs = DBNotificationPreferences(
            id=default_prefs.preferences_id,
            user_id=default_prefs.user_id,
            meal_reminders_enabled=default_prefs.meal_reminders_enabled,
            water_reminders_enabled=default_prefs.water_reminders_enabled,
            sleep_reminders_enabled=default_prefs.sleep_reminders_enabled,
            progress_notifications_enabled=default_prefs.progress_notifications_enabled,
            reengagement_notifications_enabled=default_prefs.reengagement_notifications_enabled,
            breakfast_time_minutes=default_prefs.breakfast_time_minutes,
            lunch_time_minutes=default_prefs.lunch_time_minutes,
            dinner_time_minutes=default_prefs.dinner_time_minutes,
            water_reminder_interval_hours=default_prefs.water_reminder_interval_hours,
            sleep_reminder_time_minutes=default_prefs.sleep_reminder_time_minutes,
            created_at=default_prefs.created_at,
            updated_at=default_prefs.updated_at
        )
        
        # Add to session (will be committed by caller)
        self.db.add(db_prefs)
        logger.info(f"Added default notification preferences for user {user_id} to session")
</file>

<file path="src/app/handlers/command_handlers/update_user_metrics_command_handler.py">
"""
Command handler for updating user metrics.
"""
import logging
from datetime import datetime, timedelta
from typing import Optional

from sqlalchemy.orm import Session

from src.api.exceptions import ResourceNotFoundException, ValidationException, ConflictException
from src.app.commands.user.update_user_metrics_command import UpdateUserMetricsCommand
from src.infra.database.models.enums import FitnessGoalEnum, ActivityLevelEnum
from src.app.events.base import EventHandler, handles
from src.infra.cache.cache_keys import CacheKeys
from src.infra.cache.cache_service import CacheService
from src.infra.database.models.user.profile import UserProfile

logger = logging.getLogger(__name__)


@handles(UpdateUserMetricsCommand)
class UpdateUserMetricsCommandHandler(EventHandler[UpdateUserMetricsCommand, None]):
    """Handle updating user metrics (weight, activity level, body fat)."""

    def __init__(self, db: Session = None, cache_service: Optional[CacheService] = None):
        self.db = db
        self.cache_service = cache_service

    def set_dependencies(self, db: Session, **kwargs):
        self.db = db
        self.cache_service = kwargs.get("cache_service", self.cache_service)

    async def handle(self, command: UpdateUserMetricsCommand) -> None:
        if not self.db:
            raise RuntimeError("Database session not configured")

        # Validate at least one field is provided
        if not any([command.weight_kg, command.activity_level, command.body_fat_percent, command.fitness_goal]):
            raise ValidationException("At least one metric must be provided")

        try:
            # Find existing profile
            profile = self.db.query(UserProfile).filter(
                UserProfile.user_id == command.user_id
            ).first()

            if not profile:
                raise ResourceNotFoundException(f"User {command.user_id} not found. Profile required to update metrics.")

            # Update provided fields only
            if command.weight_kg is not None:
                if command.weight_kg <= 0:
                    raise ValidationException("Weight must be greater than 0")
                profile.weight_kg = command.weight_kg

            if command.activity_level is not None:
                valid_levels = [e.value for e in ActivityLevelEnum]
                # Also accept legacy aliases
                legacy_aliases = ['sedentary', 'light', 'moderate', 'active', 'extra']
                if command.activity_level not in valid_levels and command.activity_level not in legacy_aliases:
                    raise ValidationException(f"Activity level must be one of: {', '.join(valid_levels)}")
                profile.activity_level = command.activity_level

            if command.body_fat_percent is not None:
                if command.body_fat_percent < 0 or command.body_fat_percent > 70:
                    raise ValidationException("Body fat percentage must be between 0 and 70")
                profile.body_fat_percentage = command.body_fat_percent

            # Handle fitness goal update with cooldown logic
            if command.fitness_goal is not None:
                valid_goals = [e.value for e in FitnessGoalEnum]
                if command.fitness_goal not in valid_goals:
                    raise ValidationException(f"Fitness goal must be one of: {', '.join(valid_goals)}")
                
                # Check if goal is actually changing
                if profile.fitness_goal != command.fitness_goal:
                    # Apply 7-day cooldown unless override is requested
                    if not command.override:
                        # Refresh profile to get latest updated_at from database
                        self.db.refresh(profile)
                        last_changed = profile.updated_at or profile.created_at
                        if last_changed:
                            # Compare naive datetimes (database stores naive UTC)
                            cooldown_until = last_changed + timedelta(days=7)
                            now = datetime.utcnow()
                            if now < cooldown_until:
                                # Format cooldown_until as ISO with Z suffix for UTC
                                cooldown_iso = cooldown_until.isoformat() + "Z"
                                raise ConflictException(
                                    message="Goal was updated recently. Please wait before changing again.",
                                    details={
                                        "cooldown_until": cooldown_iso
                                    }
                                )
                    
                    profile.fitness_goal = command.fitness_goal

            # Ensure this profile is marked as current
            profile.is_current = True

            self.db.add(profile)
            self.db.commit()
            self.db.refresh(profile)
            await self._invalidate_user_profile(command.user_id)

        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating user metrics: {str(e)}")
            raise

    async def _invalidate_user_profile(self, user_id: str):
        if not self.cache_service:
            return
        cache_key, _ = CacheKeys.user_profile(user_id)
        await self.cache_service.invalidate(cache_key)
</file>

<file path="src/domain/model/user/tdee.py">
from dataclasses import dataclass
from enum import Enum
from typing import Optional


class Sex(Enum):
    MALE = "male"
    FEMALE = "female"


class ActivityLevel(Enum):
    SEDENTARY = "sedentary"
    LIGHT = "light"
    MODERATE = "moderate"
    ACTIVE = "active"
    EXTRA = "extra"


class Goal(Enum):
    CUT = "cut"
    BULK = "bulk"
    RECOMP = "recomp"


class UnitSystem(Enum):
    METRIC = "metric"
    IMPERIAL = "imperial"


@dataclass
class TdeeRequest:
    """Domain model for TDEE calculation request."""

    age: int
    sex: Sex
    height: float
    weight: float
    body_fat_pct: Optional[float]
    activity_level: ActivityLevel
    goal: Goal
    unit_system: UnitSystem = UnitSystem.METRIC

    def __post_init__(self):
        """Validate invariants."""
        if not (13 <= self.age <= 120):
            raise ValueError(f"Age must be between 13 and 120: {self.age}")

        if self.unit_system == UnitSystem.METRIC:
            if not (100 <= self.height <= 272):
                raise ValueError(f"Height must be between 100-272 cm: {self.height}")
        else:
            if not (39 <= self.height <= 107):
                raise ValueError(f"Height must be between 39-107 inches: {self.height}")

        if self.unit_system == UnitSystem.METRIC:
            if not (30 <= self.weight <= 250):
                raise ValueError(f"Weight must be between 30-250 kg: {self.weight}")
        else:
            if not (66 <= self.weight <= 551):
                raise ValueError(f"Weight must be between 66-551 lbs: {self.weight}")

        if self.body_fat_pct is not None:
            if not (5 <= self.body_fat_pct <= 55):
                raise ValueError(
                    f"Body fat percentage must be between 5-55%: {self.body_fat_pct}"
                )

    @property
    def height_cm(self) -> float:
        """Convert height to centimeters."""
        if self.unit_system == UnitSystem.METRIC:
            return self.height
        else:
            return self.height * 2.54

    @property
    def weight_kg(self) -> float:
        """Convert weight to kilograms."""
        if self.unit_system == UnitSystem.METRIC:
            return self.weight
        else:
            return self.weight * 0.453592


@dataclass
class MacroTargets:
    """Represents macro targets matching Flutter MacroTargets class."""

    calories: float
    protein: float
    fat: float
    carbs: float


@dataclass
class TdeeResponse:
    """Domain model for TDEE calculation response matching Flutter TdeeResult."""

    bmr: float
    tdee: float
    goal: Goal
    macros: MacroTargets
    formula_used: Optional[str] = (
        None  # BMR formula used (e.g., "Mifflin-St Jeor", "Katch-McArdle")
    )

    def to_dict(self) -> dict:
        """Convert to dictionary format for API response."""
        result = {
            "bmr": self.bmr,
            "tdee": self.tdee,
            "goal": self.goal,
            "macros": {
                "calories": self.macros.calories,
                "protein": self.macros.protein,
                "fat": self.macros.fat,
                "carbs": self.macros.carbs,
            },
        }
        if self.formula_used:
            result["formula_used"] = self.formula_used
        return result
</file>

<file path="src/app/handlers/command_handlers/__init__.py">
"""
command_handlers - Individual handler files.
Each handler is in its own file for better maintainability.
"""

from .add_custom_ingredient_command_handler import AddCustomIngredientCommandHandler
from .complete_onboarding_command_handler import CompleteOnboardingCommandHandler
from .delete_user_command_handler import DeleteUserCommandHandler
# Standalone handlers (already individual files)
from .create_manual_meal_command_handler import CreateManualMealCommandHandler
from .delete_meal_command_handler import DeleteMealCommandHandler
# Meal handlers (already extracted)
from .edit_meal_command_handler import EditMealCommandHandler
# Daily Meal handlers (newly extracted)
from .generate_daily_meal_suggestions_command_handler import GenerateDailyMealSuggestionsCommandHandler
from .generate_single_meal_command_handler import GenerateSingleMealCommandHandler
# Meal Suggestion handlers (legacy)
from .generate_meal_suggestions_command_handler import GenerateMealSuggestionsCommandHandler
from .save_meal_suggestion_command_handler import SaveMealSuggestionCommandHandler
# Session-based suggestion handlers (new orchestration-based)
from .accept_suggestion_handler import AcceptSuggestionHandler
from .discard_session_handler import DiscardSessionHandler
from .get_session_suggestions_handler import GetSessionSuggestionsHandler
from .regenerate_suggestions_handler import RegenerateSuggestionsHandler
from .reject_suggestion_handler import RejectSuggestionHandler
# User handlers (newly extracted)
from .save_user_onboarding_command_handler import SaveUserOnboardingCommandHandler
from .sync_user_command_handler import SyncUserCommandHandler
from .update_user_last_accessed_command_handler import UpdateUserLastAccessedCommandHandler
from .update_user_metrics_command_handler import UpdateUserMetricsCommandHandler
from .upload_meal_image_immediately_command_handler import UploadMealImageImmediatelyHandler
from .weekly_ingredient_based_meal_plan_command_handler import GenerateWeeklyIngredientBasedMealPlanCommandHandler
# Notification handlers
from .register_fcm_token_command_handler import RegisterFcmTokenCommandHandler
from .delete_fcm_token_command_handler import DeleteFcmTokenCommandHandler
from .update_notification_preferences_command_handler import UpdateNotificationPreferencesCommandHandler
# Ingredient handlers
from .recognize_ingredient_command_handler import RecognizeIngredientCommandHandler

__all__ = [
    # Meal handlers
    "EditMealCommandHandler",
    "AddCustomIngredientCommandHandler",
    "DeleteMealCommandHandler",
    # User handlers
    "SaveUserOnboardingCommandHandler",
    "SyncUserCommandHandler",
    "UpdateUserLastAccessedCommandHandler",
    "CompleteOnboardingCommandHandler",
    "DeleteUserCommandHandler",
    "UpdateUserMetricsCommandHandler",
    # Daily Meal handlers
    "GenerateDailyMealSuggestionsCommandHandler",
    "GenerateSingleMealCommandHandler",
    # Meal Suggestion handlers (legacy)
    "GenerateMealSuggestionsCommandHandler",
    "SaveMealSuggestionCommandHandler",
    # Session-based suggestion handlers (new orchestration-based)
    "RegenerateSuggestionsHandler",
    "GetSessionSuggestionsHandler",
    "AcceptSuggestionHandler",
    "RejectSuggestionHandler",
    "DiscardSessionHandler",
    # Standalone handlers
    "CreateManualMealCommandHandler",
    "GenerateWeeklyIngredientBasedMealPlanCommandHandler",
    "UploadMealImageImmediatelyHandler",
    # Notification handlers
    "RegisterFcmTokenCommandHandler",
    "DeleteFcmTokenCommandHandler",
    "UpdateNotificationPreferencesCommandHandler",
    # Ingredient handlers
    "RecognizeIngredientCommandHandler",
]
</file>

<file path="src/api/routes/v1/user_profiles.py">
"""
User profiles API endpoints - Event-driven architecture.
Handles user profile management and TDEE calculations.
"""
from fastapi import APIRouter, Depends

from src.api.dependencies.auth import get_current_user_id
from src.api.dependencies.event_bus import get_configured_event_bus
from src.api.exceptions import handle_exception
from src.api.mappers.tdee_mapper import TdeeMapper
from src.api.schemas.request import OnboardingCompleteRequest
from src.api.schemas.request.user_profile_update_requests import UpdateMetricsRequest
from src.api.schemas.response import TdeeCalculationResponse, UserMetricsResponse
from src.app.commands.user import SaveUserOnboardingCommand
from src.app.commands.user.update_user_metrics_command import UpdateUserMetricsCommand
from src.app.queries.tdee import GetUserTdeeQuery
from src.app.queries.user import GetUserMetricsQuery
from src.domain.model.user import TdeeResponse, Goal, MacroTargets
from src.infra.event_bus import EventBus

router = APIRouter(prefix="/v1/user-profiles", tags=["User Profiles"])


@router.post("/", response_model=None)
async def save_user_onboarding(
    request: OnboardingCompleteRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Save user onboarding data and return TDEE calculation.

    Creates/updates:
    - User profile with physical attributes
    - Pain points and dietary preferences
    - Fitness goals and activity level
    - Meal preferences
    - Returns TDEE calculation and macro targets

    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Create command
        command = SaveUserOnboardingCommand(
            user_id=user_id,
            age=request.age,
            gender=request.gender,
            height_cm=request.height,
            weight_kg=request.weight,
            body_fat_percentage=request.body_fat_percentage,
            activity_level=request.activity_level,
            fitness_goal=request.goal,
            pain_points=request.pain_points,
            dietary_preferences=request.dietary_preferences,
            meals_per_day=request.meals_per_day
        )

        await event_bus.send(command)
        return True

    except Exception as e:
        raise handle_exception(e) from e

@router.get("/metrics", response_model=UserMetricsResponse)
async def get_user_metrics(
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get user's current metrics for settings display.
    
    Retrieves the user's current profile metrics including:
    - Physical attributes (age, gender, height, weight, body fat)
    - Activity level
    - Fitness goal
    - Target weight
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Create query
        query = GetUserMetricsQuery(user_id=user_id)
        
        # Send query
        result = await event_bus.send(query)
        
        return UserMetricsResponse(**result)
        
    except Exception as e:
        raise handle_exception(e) from e


@router.get("/tdee", response_model=TdeeCalculationResponse)
async def get_user_tdee(
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Get user's current TDEE calculation based on their profile.
    
    Retrieves the user's current profile and calculates:
    - BMR using Mifflin-St Jeor or Katch-McArdle formula
    - TDEE based on activity level
    - Macro targets based on fitness goal
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Create query
        query = GetUserTdeeQuery(user_id=user_id)
        
        # Send query
        result = await event_bus.send(query)

        # Map goal string to enum
        goal_map = {
            'cut': Goal.CUT,
            'bulk': Goal.BULK,
            'recomp': Goal.RECOMP
        }

        # Create domain response
        domain_response = TdeeResponse(
            bmr=result["bmr"],
            tdee=result["tdee"],
            goal=goal_map[result["profile_data"]["fitness_goal"]],
            macros=MacroTargets(
                calories=result["macros"]["calories"],
                protein=result["macros"]["protein"],
                carbs=result["macros"]["carbs"],
                fat=result["macros"]["fat"]
            )
        )
        
        # Use mapper to convert to response DTO
        mapper = TdeeMapper()
        response = mapper.to_response_dto(domain_response)
        
        # Add additional metadata
        response.activity_multiplier = result["activity_multiplier"]
        response.formula_used = result["formula_used"]
        
        return response
        
    except Exception as e:
        raise handle_exception(e) from e

@router.post("/metrics", response_model=TdeeCalculationResponse)
async def update_user_metrics(
    request: UpdateMetricsRequest,
    user_id: str = Depends(get_current_user_id),
    event_bus: EventBus = Depends(get_configured_event_bus)
):
    """
    Update user metrics (weight, activity level, body fat, fitness goal) and return updated TDEE/macros.
    
    Unified endpoint for profile updates.
    
    Authentication required: User ID is automatically extracted from the Firebase token.
    """
    try:
        # Update metrics (including optional fitness goal)
        command = UpdateUserMetricsCommand(
            user_id=user_id,
            weight_kg=request.weight_kg,
            activity_level=request.activity_level,
            body_fat_percent=request.body_fat_percent,
            fitness_goal=request.fitness_goal.value if request.fitness_goal else None,
            override=request.override,
        )

        await event_bus.send(command)

        # Return updated TDEE/macros
        query = GetUserTdeeQuery(user_id=user_id)
        result = await event_bus.send(query)

        goal_map = {
            'cut': Goal.CUT,
            'bulk': Goal.BULK,
            'recomp': Goal.RECOMP
        }

        domain_response = TdeeResponse(
            bmr=result["bmr"],
            tdee=result["tdee"],
            goal=goal_map[result["profile_data"]["fitness_goal"]],
            macros=MacroTargets(
                calories=result["macros"]["calories"],
                protein=result["macros"]["protein"],
                carbs=result["macros"]["carbs"],
                fat=result["macros"]["fat"]
            )
        )

        mapper = TdeeMapper()
        response = mapper.to_response_dto(domain_response)
        response.activity_multiplier = result["activity_multiplier"]
        response.formula_used = result["formula_used"]
        return response

    except Exception as e:
        raise handle_exception(e) from e
</file>

<file path="src/domain/services/meal_suggestion/suggestion_orchestration_service.py">
"""
Orchestration service for Phase 06 meal suggestions with full recipe support.
Handles session tracking, AI generation with timeout, and portion multipliers.
"""


import asyncio
import logging
import time
import uuid
from datetime import datetime
from typing import List, Optional, Tuple

from src.domain.model.meal_suggestion import (
    MealSuggestion,
    SuggestionSession,
    SuggestionStatus,
    MacroEstimate,
    Ingredient,
    RecipeStep,
    MealType,
)
from src.domain.ports.meal_generation_service_port import MealGenerationServicePort
from src.domain.ports.meal_suggestion_repository_port import (
    MealSuggestionRepositoryPort,
)
from src.domain.ports.user_repository_port import UserRepositoryPort
from src.domain.services.portion_calculation_service import PortionCalculationService
from src.domain.services.tdee_service import TdeeCalculationService

from src.domain.services.meal_suggestion.recipe_search_service import RecipeSearchService, RecipeSearchCriteria
from src.domain.model.user import TdeeRequest, Sex, ActivityLevel, Goal, UnitSystem

logger = logging.getLogger(__name__)


class SuggestionOrchestrationService:
    """
    Orchestrates meal suggestion generation with session tracking.
    Implements timeout handling and portion multipliers.
    """

    GENERATION_TIMEOUT_SECONDS = 45  # Increased from 30s - full recipe generation needs ~30-35s
    SUGGESTIONS_COUNT = 3
    MIN_ACCEPTABLE_RESULTS = 2  # Return at least 2 meals for acceptable UX

    # Parallel generation constants
    PARALLEL_SINGLE_MEAL_TOKENS = 4000  # Full recipe with detailed ingredients/steps
    PARALLEL_SINGLE_MEAL_TIMEOUT = 25   # Reduced from 35s (faster without description)
    PARALLEL_STAGGER_MS = 500  # 500ms between requests to prevent rate limiting

    def __init__(
        self,
        generation_service: MealGenerationServicePort,
        suggestion_repo: MealSuggestionRepositoryPort,
        user_repo: UserRepositoryPort,
        tdee_service: TdeeCalculationService = None,
        portion_service: PortionCalculationService = None,
        recipe_search: RecipeSearchService = None,
        redis_client=None,
    ):
        self._generation = generation_service
        self._repo = suggestion_repo
        self._user_repo = user_repo
        self._tdee_service = tdee_service or TdeeCalculationService()
        self._portion_service = portion_service or PortionCalculationService()
        self._recipe_search = recipe_search  # Optional for Phase 2
        self._redis_client = redis_client

    async def generate_suggestions(
        self,
        user_id: str,
        meal_type: str,
        meal_portion_type: str,
        ingredients: List[str],
        cooking_time_minutes: int,
    ) -> Tuple[SuggestionSession, List[MealSuggestion]]:
        """Generate initial 3 suggestions and create session."""
        # Get user profile using port-compliant method
        profile = await asyncio.to_thread(self._user_repo.get_profile, user_id)
        if not profile:
            raise ValueError(f"User {user_id} profile not found")

        # Calculate daily TDEE from profile
        daily_tdee = self._calculate_daily_tdee(profile)

        # Get meals_per_day from profile (default to 3)
        meals_per_day = getattr(profile, "meals_per_day", 3)

        # Calculate target calories using PortionCalculationService
        portion_target = self._portion_service.get_target_for_meal_type(
            meal_type=meal_portion_type,
            daily_target=int(daily_tdee),
            meals_per_day=meals_per_day,
        )
        target_calories = portion_target.target_calories

        # Extract dietary preferences and allergies (Phase 1 optimization)
        dietary_preferences = getattr(profile, 'dietary_preferences', None) or []
        allergies = getattr(profile, 'allergies', None) or []

        # Create session with dietary info
        session = SuggestionSession(
            id=f"session_{uuid.uuid4().hex[:16]}",
            user_id=user_id,
            meal_type=meal_type,
            meal_portion_type=meal_portion_type,
            target_calories=target_calories,
            ingredients=ingredients,
            cooking_time_minutes=cooking_time_minutes,
            dietary_preferences=dietary_preferences,
            allergies=allergies,
        )

        # Generate with timeout
        suggestions = await self._generate_with_timeout(
            session=session,
            exclude_ids=[],
        )

        # Track shown IDs
        session.add_shown_ids([s.id for s in suggestions])

        # Persist session and suggestions using port-compliant methods
        await self._repo.save_session(session)
        await self._repo.save_suggestions(suggestions)

        return session, suggestions

    async def regenerate_suggestions(
        self,
        user_id: str,
        session_id: str,
        exclude_ids: List[str],
    ) -> Tuple[SuggestionSession, List[MealSuggestion]]:
        """Regenerate 3 NEW suggestions excluding previously shown."""
        session = await self._repo.get_session(session_id)
        if not session or session.user_id != user_id:
            raise ValueError(f"Session {session_id} not found")

        # Combine shown with explicitly excluded
        all_excluded = list(set(session.shown_suggestion_ids + exclude_ids))

        # Generate new suggestions
        suggestions = await self._generate_with_timeout(
            session=session,
            exclude_ids=all_excluded,
        )

        # Update session
        session.add_shown_ids([s.id for s in suggestions])
        await self._repo.update_session(session)
        await self._repo.save_suggestions(suggestions)

        return session, suggestions

    async def get_session_suggestions(
        self,
        user_id: str,
        session_id: str,
    ) -> Tuple[SuggestionSession, List[MealSuggestion]]:
        """Get current session suggestions."""
        session = await self._repo.get_session(session_id)
        if not session or session.user_id != user_id:
            raise ValueError(f"Session {session_id} not found")

        suggestions = await self._repo.get_session_suggestions(session_id)
        return session, suggestions

    async def accept_suggestion(
        self,
        user_id: str,
        suggestion_id: str,
        portion_multiplier: int,
        consumed_at: Optional[datetime],
    ) -> dict:
        """Accept suggestion with portion multiplier (returns meal data for saving)."""
        suggestion = await self._repo.get_suggestion(suggestion_id)
        if not suggestion or suggestion.user_id != user_id:
            raise ValueError(f"Suggestion {suggestion_id} not found")

        # Apply portion multiplier
        adjusted_macros = suggestion.macros.multiply(portion_multiplier)

        # Mark as accepted
        suggestion.status = SuggestionStatus.ACCEPTED
        await self._repo.update_suggestion(suggestion)

        return {
            "meal_id": f"meal_{uuid.uuid4().hex[:16]}",
            "meal_name": suggestion.meal_name,
            "adjusted_macros": adjusted_macros,
            "saved_at": consumed_at or datetime.utcnow(),
            "suggestion": suggestion,
        }

    async def reject_suggestion(
        self,
        user_id: str,
        suggestion_id: str,
        feedback: Optional[str],
    ) -> None:
        """Reject suggestion with optional feedback."""
        suggestion = await self._repo.get_suggestion(suggestion_id)
        if not suggestion or suggestion.user_id != user_id:
            raise ValueError(f"Suggestion {suggestion_id} not found")

        suggestion.status = SuggestionStatus.REJECTED
        await self._repo.update_suggestion(suggestion)
        logger.info(f"Rejected suggestion {suggestion_id}: {feedback}")

    async def discard_session(
        self,
        user_id: str,
        session_id: str,
    ) -> None:
        """Discard entire session and cleanup."""
        session = await self._repo.get_session(session_id)
        if not session or session.user_id != user_id:
            raise ValueError(f"Session {session_id} not found")

        await self._repo.delete_session(session_id)

    def _calculate_daily_tdee(self, profile) -> float:
        """
        Calculate daily TDEE (Total Daily Energy Expenditure) from user profile.
        Returns target calories based on user's fitness goal.
        """
        try:
            # Map profile data to TDEE request
            sex = Sex.MALE if profile.gender.lower() == "male" else Sex.FEMALE

            activity_map = {
                "sedentary": ActivityLevel.SEDENTARY,
                "light": ActivityLevel.LIGHT,
                "moderate": ActivityLevel.MODERATE,
                "active": ActivityLevel.ACTIVE,
                "extra": ActivityLevel.EXTRA,
                "extra": ActivityLevel.EXTRA,
            }

            goal_map = {
                "cut": Goal.CUT,
                "bulk": Goal.BULK,
                "recomp": Goal.RECOMP,
            }

            tdee_request = TdeeRequest(
                age=profile.age,
                sex=sex,
                height=profile.height_cm,
                weight=profile.weight_kg,
                activity_level=activity_map.get(
                    profile.activity_level, ActivityLevel.MODERATE
                ),
                goal=goal_map.get(profile.fitness_goal, Goal.RECOMP),
                body_fat_pct=profile.body_fat_percentage,
                unit_system=UnitSystem.METRIC,
            )

            # Calculate TDEE
            result = self._tdee_service.calculate_tdee(tdee_request)
            return result.macros.calories

        except Exception as e:
            logger.warning(
                f"Failed to calculate TDEE: {e}. Using default 2000 calories."
            )
            return 2000.0

    async def _generate_with_timeout(
        self,
        session: SuggestionSession,
        exclude_ids: List[str],
    ) -> List[MealSuggestion]:
        """
        Generate suggestions using 2-phase approach.
        Phase 1: Generate 6 diverse meal names (~1s)
        Phase 2: Generate 6 recipes in parallel, take first 3 successful (~8-10s)
        Target latency: 9-12s (9-11s average, 12-14s P95)
        """
        return await self._generate_parallel_hybrid(session, exclude_ids)

    async def _generate_parallel_hybrid(
        self,
        session: SuggestionSession,
        exclude_ids: List[str],
    ) -> List[MealSuggestion]:
        """
        Two-phase generation with over-generation for reliability.
        Phase 1: Generate 4 diverse meal names (1 call, ~1-2s)
        Phase 2: Generate 4 recipes in parallel, take first 3 successes (~6-8s)
        Target latency: 7-10s (faster + more reliable with reduced API pressure)
        """
        start_time = time.time()

        # STEP 1: Generate 4 diverse meal names in one call
        from src.domain.services.meal_suggestion.suggestion_prompt_builder import (
            build_meal_names_prompt,
            build_recipe_details_prompt,
        )
        from src.domain.schemas.meal_generation_schemas import (
            MealNamesResponse,
            RecipeDetailsResponse,
        )

        logger.info(f"[PHASE-1-START] session={session.id} | generating 4 diverse meal names")

        names_prompt = build_meal_names_prompt(session)
        names_system = "You are a creative chef. Generate 4 VERY DIFFERENT meal names with diverse flavors and cooking styles."
        
        phase1_elapsed = 0.0  # Initialize to prevent UnboundLocalError
        try:
            names_raw = await asyncio.wait_for(
                asyncio.to_thread(
                    self._generation.generate_meal_plan,
                    names_prompt,
                    names_system,
                    "json",
                    1000,  # Token limit for name generation
                    MealNamesResponse,  # Structured output schema (guarantees valid format)
                ),
                timeout=10,  # Quick timeout for name generation
            )
            
            meal_names = names_raw.get("meal_names", [])

            # Deduplicate meal names while preserving order
            seen = set()
            unique_names = []
            for name in meal_names:
                if name.lower() not in seen:
                    seen.add(name.lower())
                    unique_names.append(name)
            meal_names = unique_names

            if len(meal_names) != 4:
                logger.warning(
                    f"[PHASE-1-INCOMPLETE] session={session.id} | "
                    f"got {len(meal_names)} names, expected 4"
                )
                # Pad with generic names if needed
                while len(meal_names) < 4:
                    meal_names.append(f"Healthy {session.meal_type.title()} #{len(meal_names) + 1}")
            
            phase1_elapsed = time.time() - start_time
            logger.info(
                f"[PHASE-1-COMPLETE] session={session.id} | "
                f"elapsed={phase1_elapsed:.2f}s | "
                f"names={meal_names}"
            )
            
        except Exception as e:
            phase1_elapsed = time.time() - start_time
            logger.error(
                f"[PHASE-1-FAILED] session={session.id} | "
                f"elapsed={phase1_elapsed:.2f}s | "
                f"error_type={type(e).__name__} | error={e}"
            )
            # Fallback to generic names
            meal_names = [
                f"Healthy {session.meal_type.title()} #{i+1}"
                for i in range(4)
            ]
        
        # STEP 2: Generate full recipes for each name in parallel
        logger.info(f"[PHASE-2-START] session={session.id} | generating recipes for {meal_names}")
        
        recipe_prompts = [
            build_recipe_details_prompt(meal_name, session)
            for meal_name in meal_names
        ]
        
        # Generate recipes in parallel
        recipe_system = "You are a professional chef. Generate complete recipe details as valid JSON. CRITICAL: MUST finish entire JSON - include all fields."

        async def generate_recipe(prompt: str, meal_name: str, index: int) -> Optional[MealSuggestion]:
            """Generate recipe details for a given meal name."""
            try:
                raw = await asyncio.wait_for(
                    asyncio.to_thread(
                        self._generation.generate_meal_plan,
                        prompt,
                        recipe_system,
                        "json",
                        self.PARALLEL_SINGLE_MEAL_TOKENS,
                        RecipeDetailsResponse,  # Structured output schema
                    ),
                    timeout=self.PARALLEL_SINGLE_MEAL_TIMEOUT,
                )

                # Parse recipe response (guaranteed valid by Pydantic schema)
                recipe_data = raw
                
                # Extract validated fields (schema ensures these exist and are valid)
                # NOTE: description field removed in Phase 01 schema optimization
                ingredients = recipe_data.get("ingredients", [])
                recipe_steps = recipe_data.get("recipe_steps", [])
                prep_time = recipe_data.get("prep_time_minutes", session.cooking_time_minutes)
                
                # Schema guarantees 4-6 ingredients and 3-4 steps, but double-check
                if not ingredients or not recipe_steps:
                    logger.warning(
                        f"[PHASE-2-UNEXPECTED-EMPTY] index={index} | "
                        f"ingredients={len(ingredients)} | steps={len(recipe_steps)}"
                    )
                    return None
                
                # Build MealSuggestion with the meal_name from Phase 1
                return MealSuggestion(
                    id=f"sug_{uuid.uuid4().hex[:16]}",
                    session_id=session.id,
                    user_id=session.user_id,
                    meal_name=meal_name,  # Use name from Phase 1
                    description="",  # Empty string (field removed from schema in Phase 01)
                    meal_type=MealType(session.meal_type),
                    macros=MacroEstimate(
                        calories=session.target_calories,
                        protein=20,
                        carbs=30,
                        fat=10,  # Placeholder, will be enriched
                    ),
                    ingredients=[Ingredient(**ing) for ing in ingredients],
                    recipe_steps=[RecipeStep(**step) for step in recipe_steps],
                    prep_time_minutes=prep_time,
                    confidence_score=0.85,
                )
            
            except asyncio.TimeoutError:
                logger.warning(
                    f"[PHASE-2-TIMEOUT] index={index} | "
                    f"meal_name={meal_name} | timeout={self.PARALLEL_SINGLE_MEAL_TIMEOUT}s"
                )
                return None
            except Exception as e:
                logger.warning(
                    f"[PHASE-2-FAIL] index={index} | "
                    f"meal_name={meal_name} | error_type={type(e).__name__} | error={e}"
                )
                return None

        # Over-generation strategy: Start 4 recipes, take first 3 successes
        # Staggered starts (500ms) to prevent rate limiting
        gen_start = time.time()

        # Create tasks with staggered starts
        tasks = []
        for i in range(4):
            if i > 0:
                # Add 500ms delay to prevent rate limiting (reduced from 6 to 4 parallel)
                await asyncio.sleep(self.PARALLEL_STAGGER_MS / 1000)
                logger.debug(f"[STAGGER] Starting request {i} after {self.PARALLEL_STAGGER_MS}ms delay")

            task = asyncio.create_task(
                generate_recipe(recipe_prompts[i], meal_names[i], i)
            )
            tasks.append(task)

        # Use as_completed to get first 3 successes and cancel remaining (S1 fix: cancel inside loop)
        successful_results = []
        for coro in asyncio.as_completed(tasks):
            try:
                result = await coro
                if result is not None:
                    successful_results.append(result)
                    logger.debug(f"[SUCCESS] Got meal {len(successful_results)}/3")
                    if len(successful_results) >= 3:
                        # Cancel remaining tasks immediately (S1: cleaner pattern)
                        cancelled_count = sum(1 for task in tasks if not task.done() and not task.cancel() is False)
                        logger.info(f"[EARLY-STOP] Got 3 meals, cancelled {cancelled_count} remaining tasks")
                        break
            except Exception as e:
                logger.warning(f"[RECIPE-ERROR] {type(e).__name__}: {e}")
                continue

        logger.info(
            f"[PHASE-2-COMPLETE] session={session.id} | "
            f"success={len(successful_results)}/4 | "
            f"gen_elapsed={time.time() - gen_start:.2f}s"
        )

        # W2 fix: Check for minimum acceptable results
        if len(successful_results) < self.MIN_ACCEPTABLE_RESULTS:
            if not successful_results:
                raise RuntimeError(
                    f"Failed to generate any recipes from 4 attempts"
                )
            else:
                logger.error(
                    f"[PHASE-2-INSUFFICIENT] session={session.id} | "
                    f"only {len(successful_results)} meals (minimum {self.MIN_ACCEPTABLE_RESULTS} required)"
                )
                raise RuntimeError(
                    f"Insufficient recipes generated: {len(successful_results)}/{self.MIN_ACCEPTABLE_RESULTS} minimum"
                )

        # Log if partial success but acceptable
        if len(successful_results) < 3:
            logger.warning(
                f"[PHASE-2-PARTIAL] session={session.id} | "
                f"returning {len(successful_results)}/3 meals (above minimum threshold)"
            )

        suggestions = successful_results

        total_elapsed = time.time() - start_time
        phase2_elapsed = total_elapsed - phase1_elapsed
        
        logger.info(
            f"[TWO-PHASE-COMPLETE] session={session.id} | "
            f"total_elapsed={total_elapsed:.2f}s | "
            f"phase1={phase1_elapsed:.2f}s | "
            f"phase2={phase2_elapsed:.2f}s | "
            f"returned={len(suggestions)} meals (target 3) | "
            f"meals={[s.meal_name for s in suggestions]}"
        )

        return suggestions

    def _normalize_confidence(self, score: float) -> float:
        """Normalize confidence score to 0-1 range (AI may return 1-5 scale)."""
        if score > 1.0:
            # Assume 1-5 scale, convert to 0-1
            return min(1.0, score / 5.0)
        return max(0.0, min(1.0, score))
</file>

<file path="src/infra/database/config.py">
import logging
import os

from dotenv import load_dotenv
from sqlalchemy import create_engine
from sqlalchemy.ext.asyncio import AsyncAttrs
from sqlalchemy.orm import DeclarativeBase, sessionmaker

load_dotenv()

logger = logging.getLogger(__name__)

SSL_ENABLED = os.getenv("DB_SSL_ENABLED", "true").lower() == "true"
SSL_VERIFY_CERT = os.getenv("DB_SSL_VERIFY_CERT", "false").lower() == "true"
SSL_VERIFY_IDENTITY = os.getenv("DB_SSL_VERIFY_IDENTITY", "false").lower() == "true"

logger.info(
    "SSL Configuration: enabled=%s, verify_cert=%s, verify_identity=%s",
    SSL_ENABLED,
    SSL_VERIFY_CERT,
    SSL_VERIFY_IDENTITY,
)

DATABASE_URL = os.getenv("DATABASE_URL")

if DATABASE_URL:
    SQLALCHEMY_DATABASE_URL = DATABASE_URL
    if SQLALCHEMY_DATABASE_URL.startswith("mysql://"):
        SQLALCHEMY_DATABASE_URL = SQLALCHEMY_DATABASE_URL.replace(
            "mysql://", "mysql+mysqlconnector://", 1
        )
    elif SQLALCHEMY_DATABASE_URL.startswith("mysql+pymysql://"):
        SQLALCHEMY_DATABASE_URL = SQLALCHEMY_DATABASE_URL.replace(
            "mysql+pymysql://", "mysql+mysqlconnector://", 1
        )

    if SSL_ENABLED:
        ssl_params = [
            "ssl_disabled=false",
            f"ssl_verify_cert={str(SSL_VERIFY_CERT).lower()}",
            f"ssl_verify_identity={str(SSL_VERIFY_IDENTITY).lower()}",
            "ssl_ca=",
        ]

        if "?" in SQLALCHEMY_DATABASE_URL:
            SQLALCHEMY_DATABASE_URL += "&" + "&".join(ssl_params)
        else:
            SQLALCHEMY_DATABASE_URL += "?" + "&".join(ssl_params)

        masked_url = SQLALCHEMY_DATABASE_URL
        if "://" in masked_url and "@" in masked_url:
            protocol, remainder = masked_url.split("://", maxsplit=1)
            if ":" in remainder and "@" in remainder:
                auth_host = remainder.split("@")[0]
                if ":" in auth_host:
                    user = auth_host.split(":")[0]
                    masked_url = masked_url.replace(auth_host, f"{user}:***")
        logger.info("Final Database URL: %s", masked_url)
        logger.info("SSL Parameters added: %s", ssl_params)
else:
    db_user = os.getenv("DB_USER", "root")
    db_password = os.getenv("DB_PASSWORD", "")
    db_host = os.getenv("DB_HOST", "localhost")
    db_port = os.getenv("DB_PORT", "3306")
    db_name = os.getenv("DB_NAME", "mealtrack")

    base_url = f"mysql+mysqlconnector://{db_user}:{db_password}@{db_host}:{db_port}/{db_name}"
    if SSL_ENABLED:
        ssl_params = [
            "ssl_disabled=false",
            f"ssl_verify_cert={str(SSL_VERIFY_CERT).lower()}",
            f"ssl_verify_identity={str(SSL_VERIFY_IDENTITY).lower()}",
            "ssl_ca=",
        ]
        SQLALCHEMY_DATABASE_URL = base_url + "?" + "&".join(ssl_params)
    else:
        SQLALCHEMY_DATABASE_URL = base_url

UVICORN_WORKERS = int(os.getenv("UVICORN_WORKERS", "4"))
POOL_SIZE_PER_WORKER = int(os.getenv("POOL_SIZE_PER_WORKER", "5"))
POOL_MAX_OVERFLOW = int(os.getenv("POOL_MAX_OVERFLOW", "10"))
POOL_TIMEOUT = int(os.getenv("POOL_TIMEOUT", "30"))
POOL_RECYCLE = int(os.getenv("POOL_RECYCLE", "300"))
POOL_ECHO = os.getenv("POOL_ECHO", "false").lower() == "true"

POOL_SIZE = max(1, UVICORN_WORKERS * POOL_SIZE_PER_WORKER)
TOTAL_POOL_CAPACITY = POOL_SIZE + POOL_MAX_OVERFLOW

logger.info(
    "Connection pool configuration -> workers: %s, pool_size: %s, "
    "max_overflow: %s, total_capacity: %s, timeout: %ss, recycle: %ss",
    UVICORN_WORKERS,
    POOL_SIZE,
    POOL_MAX_OVERFLOW,
    TOTAL_POOL_CAPACITY,
    POOL_TIMEOUT,
    POOL_RECYCLE,
)

engine = create_engine(
    SQLALCHEMY_DATABASE_URL,
    echo=False,
    echo_pool=POOL_ECHO,
    pool_pre_ping=True,
    pool_recycle=POOL_RECYCLE,
    pool_size=POOL_SIZE,
    max_overflow=POOL_MAX_OVERFLOW,
    pool_timeout=POOL_TIMEOUT,
    connect_args={
        "connection_timeout": 60,
        "charset": "utf8mb4",
        "autocommit": False,
        "ssl_disabled": not SSL_ENABLED,
        "ssl_verify_cert": SSL_VERIFY_CERT,
        "ssl_verify_identity": SSL_VERIFY_IDENTITY,
        "ssl_ca": "",
    },
)

SessionLocal = sessionmaker(
    bind=engine,
    autocommit=False,
    autoflush=False,
    expire_on_commit=False,
)


class Base(AsyncAttrs, DeclarativeBase):
    """Base declarative class with async attribute support."""


def get_db():
    """
    Dependency for FastAPI to get a database session.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
</file>

<file path="src/api/base_dependencies.py">
import logging
import os
from typing import Optional

from fastapi import Depends
from sqlalchemy.orm import Session

from src.domain.parsers.gpt_response_parser import GPTResponseParser
from src.domain.ports.food_cache_service_port import FoodCacheServicePort
from src.domain.ports.food_data_service_port import FoodDataServicePort
from src.domain.ports.ai_chat_service_port import AIChatServicePort
from src.domain.ports.food_mapping_service_port import FoodMappingServicePort
from src.domain.ports.image_store_port import ImageStorePort
from src.domain.ports.meal_repository_port import MealRepositoryPort
from src.domain.ports.notification_repository_port import NotificationRepositoryPort
from src.domain.ports.vision_ai_service_port import VisionAIServicePort
from src.domain.services.food_mapping_service import FoodMappingService
from src.domain.services.notification_service import NotificationService
from src.infra.adapters.cloudinary_image_store import CloudinaryImageStore
from src.infra.adapters.food_cache_service import FoodCacheService
from src.infra.adapters.food_data_service import FoodDataService
from src.infra.adapters.image_store import ImageStore
from src.infra.adapters.vision_ai_service import VisionAIService
from src.infra.cache.cache_service import CacheService
from src.infra.cache.metrics import CacheMonitor
from src.infra.cache.redis_client import RedisClient
from src.infra.database.config import SessionLocal
from src.infra.repositories.meal_repository import MealRepository
from src.infra.repositories.notification_repository import NotificationRepository
from src.infra.services.ai.openai_chat_service import OpenAIChatService
from src.infra.services.firebase_service import FirebaseService
from src.infra.services.scheduled_notification_service import ScheduledNotificationService
from src.infra.config.settings import settings


# Note: Old handler imports removed - using event-driven architecture now
# from src.app.handlers.activity_handler import ActivityHandler
# ... etc


# Globals
logger = logging.getLogger(__name__)
_redis_client: Optional[RedisClient] = None
_cache_service: Optional[CacheService] = None
_cache_monitor = CacheMonitor()

# Singleton service instances (initialized once, reused across requests)
_image_store: Optional[ImageStorePort] = None
_ai_chat_service: Optional[AIChatServicePort] = None
_vision_service: Optional[VisionAIServicePort] = None
_recipe_search_service = None  # RecipeSearchService singleton


async def initialize_cache_layer() -> None:
    """Initialize Redis cache if enabled."""
    global _redis_client, _cache_service

    if not settings.CACHE_ENABLED:
        logger.info("Caching disabled via settings")
        return

    if _redis_client is None:
        _redis_client = RedisClient(
            redis_url=settings.redis_url,
            max_connections=settings.REDIS_MAX_CONNECTIONS,
        )
        await _redis_client.connect()

    _cache_service = CacheService(
        redis_client=_redis_client,
        default_ttl=settings.CACHE_DEFAULT_TTL,
        monitor=_cache_monitor,
        enabled=settings.CACHE_ENABLED,
    )


async def shutdown_cache_layer() -> None:
    """Gracefully close Redis connections."""
    global _redis_client, _cache_service

    if _cache_service:
        _cache_service = None
    if _redis_client:
        await _redis_client.disconnect()
        _redis_client = None


# Database
def get_db():
    """
    Get a database session.
    
    Yields:
        Session: SQLAlchemy database session
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# Image Store (singleton pattern)
def get_image_store() -> ImageStorePort:
    """
    Get the image store adapter instance (singleton).

    Returns:
        ImageStorePort: The image store adapter (Cloudinary or Mock)
    """
    global _image_store
    if _image_store is None:
        use_mock = bool(int(os.getenv("USE_MOCK_STORAGE", "0")))
        if use_mock:
            _image_store = ImageStore()
        else:
            _image_store = CloudinaryImageStore()
    return _image_store


# Meal Repository
def get_meal_repository(db: Session = Depends(get_db)) -> MealRepositoryPort:
    """
    Get the meal repository instance.
    
    Args:
        db: Database session
        
    Returns:
        MealRepositoryPort: The meal repository
    """
    return MealRepository(db)


# Vision Service (singleton pattern)
def get_vision_service() -> VisionAIServicePort:
    """
    Get the vision AI service instance (singleton).

    Returns:
        VisionAIServicePort: The vision service
    """
    global _vision_service
    if _vision_service is None:
        _vision_service = VisionAIService()
    return _vision_service


# AI Chat Service (singleton pattern)
def get_ai_chat_service() -> AIChatServicePort:
    """
    Get the AI chat service instance (singleton) using the LLM provider factory.

    Supports multiple LLM providers (OpenAI, Gemini) with auto-detection.
    Provider selection priority:
    1. LLM_PROVIDER environment variable (if set)
    2. Auto-detect from available API keys (OPENAI_API_KEY > GOOGLE_API_KEY)

    Returns:
        AIChatServicePort: The configured LLM provider instance

    Raises:
        ValueError: If no LLM provider can be configured (no API keys available)
    """
    global _ai_chat_service
    if _ai_chat_service is not None:
        return _ai_chat_service

    from src.infra.services.ai.llm_provider_factory import LLMProviderFactory
    from src.infra.config.settings import settings

    try:
        provider = settings.LLM_PROVIDER
        if provider:
            logger.info(f"Using configured LLM provider: {provider}")

        # Get model from settings if available
        model = None
        if provider == "openai":
            model = settings.OPENAI_MODEL
        elif provider == "gemini":
            model = settings.GEMINI_MODEL

        _ai_chat_service = LLMProviderFactory.create_provider(
            provider=provider,
            model=model
        )
        return _ai_chat_service
    except ValueError as e:
        logger.error(f"Failed to create LLM provider: {e}")
        raise ValueError(
            "AI chat service is not available. "
            "Please configure at least one LLM provider by setting "
            "OPENAI_API_KEY or GOOGLE_API_KEY environment variable."
        ) from e


# GPT Parser
def get_gpt_parser() -> GPTResponseParser:
    """
    Get the GPT response parser instance.
    
    Returns:
        GPTResponseParser: The parser instance
    """
    return GPTResponseParser()

# Food Data Service
def get_food_data_service() -> FoodDataServicePort:
    """
    Get the food data service instance.
    
    Returns:
        FoodDataServicePort: The food data service
    """
    return FoodDataService()

# Food Cache Service
def get_food_cache_service() -> FoodCacheServicePort:
    """
    Get the food cache service instance.
    
    Returns:
        FoodCacheServicePort: The food cache service
    """
    return FoodCacheService(cache_service=_cache_service)


def get_cache_service() -> Optional[CacheService]:
    """Expose cache service for dependency injection."""
    return _cache_service


def get_cache_monitor() -> CacheMonitor:
    """Return shared cache monitor for metrics."""
    return _cache_monitor

# Food Mapping Service
def get_food_mapping_service() -> FoodMappingServicePort:
    """
    Get the food mapping service instance.
    
    Returns:
        FoodMappingServicePort: The food mapping service
    """
    return FoodMappingService()

# Notification Repository
def get_notification_repository(db: Session = Depends(get_db)) -> NotificationRepositoryPort:
    """
    Get the notification repository instance.
    
    Args:
        db: Database session
        
    Returns:
        NotificationRepositoryPort: The notification repository
    """
    return NotificationRepository(db)


# Firebase Service (singleton pattern - create once and reuse)
_firebase_service = None

def get_firebase_service() -> FirebaseService:
    """
    Get the Firebase service instance (singleton).
    
    Returns:
        FirebaseService: The Firebase service
    """
    global _firebase_service
    if _firebase_service is None:
        _firebase_service = FirebaseService()
    return _firebase_service


# Notification Service
def get_notification_service(
    notification_repository: NotificationRepositoryPort = Depends(get_notification_repository),
    firebase_service: FirebaseService = Depends(get_firebase_service)
) -> NotificationService:
    """
    Get the notification service instance.
    
    Args:
        notification_repository: Notification repository
        firebase_service: Firebase service
        
    Returns:
        NotificationService: The notification service
    """
    return NotificationService(notification_repository, firebase_service)


# Scheduled Notification Service (singleton pattern - create once and reuse)
_scheduled_notification_service = None

def get_scheduled_notification_service() -> ScheduledNotificationService:
    """
    Get the scheduled notification service instance (singleton).
    This is created during application startup in the lifespan function.
    
    Returns:
        ScheduledNotificationService: The scheduled notification service
    """
    return _scheduled_notification_service


def initialize_scheduled_notification_service() -> ScheduledNotificationService:
    """
    Initialize the scheduled notification service during application startup.
    
    Returns:
        ScheduledNotificationService: The initialized scheduled notification service
    """
    global _scheduled_notification_service
    if _scheduled_notification_service is None:
        # Create instances without using Depends (we're not in request context)
        notification_repository = NotificationRepository()
        firebase_service = get_firebase_service()
        notification_service = NotificationService(notification_repository, firebase_service)
        _scheduled_notification_service = ScheduledNotificationService(
            notification_repository, 
            notification_service
        )
    return _scheduled_notification_service


# Phase 06: Meal Suggestion Dependencies
def get_redis_client() -> Optional[RedisClient]:
    """Get Redis client for meal suggestions repository."""
    return _redis_client


def get_meal_suggestion_repository():
    """Get meal suggestion repository (Phase 06)."""
    from src.infra.repositories.meal_suggestion_repository import MealSuggestionRepository
    if _redis_client is None:
        raise RuntimeError("Redis client not initialized. Ensure cache layer is initialized.")
    return MealSuggestionRepository(_redis_client)


def get_suggestion_orchestration_service(
    db: Session = Depends(get_db),
):
    """Get suggestion orchestration service with Phase 1 & 2 optimizations."""
    from src.domain.services.meal_suggestion.suggestion_orchestration_service import SuggestionOrchestrationService
    from src.domain.services.meal_suggestion.recipe_search_service import RecipeSearchService
    from src.infra.adapters.meal_generation_service import MealGenerationService
    from src.infra.repositories.user_repository import UserRepository

    global _recipe_search_service

    meal_gen_service = MealGenerationService()
    suggestion_repo = get_meal_suggestion_repository()
    user_repo = UserRepository(db)

    # Phase 2 optimization: Recipe search (hybrid retrieval) - singleton pattern
    # Reuse service instance to avoid loading ~80MB SentenceTransformer model on every request
    if _recipe_search_service is None:
        try:
            _recipe_search_service = RecipeSearchService()
            logger.info("Recipe search service initialized for hybrid retrieval (singleton)")
        except Exception as e:
            logger.warning(f"Recipe search not available, using AI-only generation: {e}")
            _recipe_search_service = None

    recipe_search = _recipe_search_service

    return SuggestionOrchestrationService(
        generation_service=meal_gen_service,
        suggestion_repo=suggestion_repo,
        user_repo=user_repo,
        recipe_search=recipe_search,
        redis_client=_redis_client,
    )


# Note: Old handler functions removed - using event-driven architecture now
# The event bus configuration in event_bus.py handles all dependencies
</file>

<file path="src/infra/repositories/user_repository.py">
"""Repository for user-related database operations."""
import json
import logging
from typing import Optional, List

from sqlalchemy.exc import IntegrityError
from sqlalchemy.orm import Session, selectinload

from src.infra.cache.cache_keys import CacheKeys
from src.infra.database.models.user.profile import UserProfile
from src.infra.database.models.user.user import User

logger = logging.getLogger(__name__)


_USER_RELATIONSHIP_LOADS = (
    selectinload(User.profiles),
    selectinload(User.subscriptions),
)


class UserRepository:
    """Repository for user operations."""
    
    def __init__(self, db: Session):
        self.db = db
    
    def save(self, user: User) -> User:
        """Save or update a user."""
        if not user.id:
            self.db.add(user)
        else:
            self.db.merge(user)
        try:
            self.db.commit()
            self.db.refresh(user)
            return user
        except IntegrityError:
            self.db.rollback()
            raise ValueError("User with this email or username already exists")
    
    def create_user(self, email: str, username: str, password_hash: str, firebase_uid: str) -> User:
        """Create a new user (deprecated - use save instead)."""
        user = User(
            email=email,
            username=username,
            password_hash=password_hash,
            firebase_uid=firebase_uid,
            is_active=True
        )
        return self.save(user)
    
    def find_by_id(self, user_id: str) -> Optional[User]:
        """Find user by ID (only active users)."""
        return (
            self.db.query(User)
            .options(*_USER_RELATIONSHIP_LOADS)
            .filter(
                User.id == user_id,
                User.is_active == True
            )
            .first()
        )
    
    def get(self, user_id: str) -> Optional[User]:
        """Get user by ID (deprecated - use find_by_id)."""
        return self.find_by_id(user_id)
    
    def get_user_by_id(self, user_id: str) -> Optional[User]:
        """Get user by ID (deprecated - use find_by_id)."""
        return self.find_by_id(user_id)

    def find_by_email(self, email: str) -> Optional[User]:
        """Find user by email (only active users)."""
        return (
            self.db.query(User)
            .options(*_USER_RELATIONSHIP_LOADS)
            .filter(
                User.email == email,
                User.is_active == True
            )
            .first()
        )
    
    def get_user_by_email(self, email: str) -> Optional[User]:
        """Get user by email (deprecated - use find_by_email)."""
        return self.find_by_email(email)

    def find_by_username(self, username: str) -> Optional[User]:
        """Find user by username (only active users)."""
        return (
            self.db.query(User)
            .options(*_USER_RELATIONSHIP_LOADS)
            .filter(
                User.username == username,
                User.is_active == True
            )
            .first()
        )
    
    def get_user_by_username(self, username: str) -> Optional[User]:
        """Get user by username (deprecated - use find_by_username)."""
        return self.find_by_username(username)

    def find_by_firebase_uid(self, firebase_uid: str) -> Optional[User]:
        """Find user by Firebase UID (only active users)."""
        return (
            self.db.query(User)
            .options(*_USER_RELATIONSHIP_LOADS)
            .filter(
                User.firebase_uid == firebase_uid,
                User.is_active == True
            )
            .first()
        )
    
    def get_user_by_firebase_uid(self, firebase_uid: str) -> Optional[User]:
        """Get user by Firebase UID (deprecated - use find_by_firebase_uid)."""
        return self.find_by_firebase_uid(firebase_uid)
    
    def create_user_profile(self, user_id: str, age: int, gender: str, 
                          height_cm: float, weight_kg: float, 
                          body_fat_percentage: Optional[float] = None,
                          activity_level: str = 'sedentary',
                          fitness_goal: str = 'maintenance',
                          target_weight_kg: Optional[float] = None,
                          meals_per_day: int = 3,
                          snacks_per_day: int = 1,
                          dietary_preferences: List[str] = None,
                          health_conditions: List[str] = None,
                          allergies: List[str] = None) -> UserProfile:
        """Create a new user profile. Marks previous profiles as not current."""
        # Mark all existing profiles as not current
        self.db.query(UserProfile).filter(
            UserProfile.user_id == user_id,
            UserProfile.is_current ==  True
        ).update({"is_current": False}, synchronize_session='evaluate')
        self.db.flush()
        
        profile = UserProfile(
            user_id=user_id,
            age=age,
            gender=gender,
            height_cm=height_cm,
            weight_kg=weight_kg,
            body_fat_percentage=body_fat_percentage,
            is_current=True,
            # Goal fields
            activity_level=activity_level,
            fitness_goal=fitness_goal,
            target_weight_kg=target_weight_kg,
            meals_per_day=meals_per_day,
            snacks_per_day=snacks_per_day,
            # Preference fields
            dietary_preferences=dietary_preferences or [],
            health_conditions=health_conditions or [],
            allergies=allergies or []
        )
        self.db.add(profile)
        self.db.commit()  # This will commit both the old profile updates and new profile creation
        self.db.refresh(profile)
        return profile
    
    def get_current_user_profile(self, user_id: str) -> Optional[UserProfile]:
        """Get the current user profile."""
        return self.db.query(UserProfile).filter(
            UserProfile.user_id == user_id,
            UserProfile.is_current == True
        ).first()
    
    def get_profile(self, user_id: str) -> Optional[UserProfile]:
        """Get user profile by user ID (implements UserRepositoryPort interface)."""
        return self.get_current_user_profile(user_id)

    async def get_current_profile_cached(
        self,
        user_id: str,
        redis_client=None
    ) -> Optional[UserProfile]:
        """
        Get current profile with 1-hour Redis cache.
        Optimized for meal suggestion generation.
        """
        # Use standard cache key to match invalidation logic in command handlers
        cache_key, _ = CacheKeys.user_profile(user_id)
        
        # Try cache first
        if redis_client:
            try:
                cached_data = await redis_client.get(cache_key)

                if cached_data:
                    data = json.loads(cached_data)
                    # Reconstruct profile object
                    profile = UserProfile()
                    profile.id = data["id"]
                    profile.user_id = data["user_id"]
                    profile.age = data["age"]
                    profile.gender = data["gender"]
                    profile.height_cm = data["height_cm"]
                    profile.weight_kg = data["weight_kg"]
                    profile.body_fat_percentage = data.get("body_fat_percentage")
                    profile.activity_level = data["activity_level"]
                    profile.fitness_goal = data["fitness_goal"]
                    profile.meals_per_day = data["meals_per_day"]
                    profile.dietary_preferences = data.get("dietary_preferences", [])
                    profile.allergies = data.get("allergies", [])
                    logger.debug(f"Cache hit for user profile {user_id}")
                    return profile
            except Exception as e:
                logger.warning(f"Failed to read profile from cache: {e}")

        # Cache miss - query DB (optimized, no relationships)
        profile = self.db.query(UserProfile).filter(
            UserProfile.user_id == user_id,
            UserProfile.is_current == True
        ).first()

        # Cache for 1 hour
        if profile and redis_client:
            try:
                cache_data = json.dumps({
                    "id": profile.id,
                    "user_id": profile.user_id,
                    "age": profile.age,
                    "gender": profile.gender,
                    "height_cm": profile.height_cm,
                    "weight_kg": profile.weight_kg,
                    "body_fat_percentage": profile.body_fat_percentage,
                    "activity_level": profile.activity_level,
                    "fitness_goal": profile.fitness_goal,
                    "meals_per_day": profile.meals_per_day,
                    "dietary_preferences": profile.dietary_preferences or [],
                    "allergies": profile.allergies or []
                })
                await redis_client.set(cache_key, cache_data, ttl=3600)  # 1 hour TTL
                logger.debug(f"Cached user profile {user_id}")
            except Exception as e:
                logger.warning(f"Failed to cache profile: {e}")

        return profile

    def update_user_preferences(self, user_id: str, dietary_preferences: List[str] = None,
                              health_conditions: List[str] = None, allergies: List[str] = None) -> Optional[UserProfile]:
        """Update user preferences in their current profile."""
        profile = self.get_current_user_profile(user_id)
        if not profile:
            return None
            
        if dietary_preferences is not None:
            profile.dietary_preferences = dietary_preferences
        if health_conditions is not None:
            profile.health_conditions = health_conditions
        if allergies is not None:
            profile.allergies = allergies
            
        self.db.commit()
        self.db.refresh(profile)
        return profile
    
    def update_user_goals(self, user_id: str, activity_level: str = None, fitness_goal: str = None,
                         target_weight_kg: Optional[float] = None, meals_per_day: int = None,
                         snacks_per_day: int = None) -> Optional[UserProfile]:
        """Update user goals in their current profile."""
        profile = self.get_current_user_profile(user_id)
        if not profile:
            return None
            
        if activity_level is not None:
            profile.activity_level = activity_level
        if fitness_goal is not None:
            profile.fitness_goal = fitness_goal
        if target_weight_kg is not None:
            profile.target_weight_kg = target_weight_kg
        if meals_per_day is not None:
            profile.meals_per_day = meals_per_day
        if snacks_per_day is not None:
            profile.snacks_per_day = snacks_per_day
            
        self.db.commit()
        self.db.refresh(profile)
        return profile
    
    def update_user_timezone(self, user_id: str, timezone: str) -> bool:
        """Update user's timezone."""
        try:
            user = self.find_by_id(user_id)
            if user:
                user.timezone = timezone
                self.db.commit()
                return True
            return False
        except Exception as e:
            self.db.rollback()
            logger.error(f"Error updating timezone for user {user_id}: {e}")
            raise e
</file>

<file path="src/api/main.py">
"""
Main application file for the MealTrack API.

This file initializes the FastAPI application, sets up middleware,
includes routes, and handles application lifecycle events.
"""

import json
import logging
import os
import time
from contextlib import asynccontextmanager

import firebase_admin
from dotenv import load_dotenv
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from firebase_admin import credentials
from sqlalchemy import text

from src.api.base_dependencies import (
    initialize_cache_layer,
    initialize_scheduled_notification_service,
    shutdown_cache_layer,
)
from src.api.middleware.dev_auth_bypass import add_dev_auth_bypass
from src.api.routes.v1.activities import router as activities_router
from src.api.routes.v1.feature_flags import router as feature_flags_router
from src.api.routes.v1.foods import router as foods_router
from src.api.routes.v1.monitoring import router as monitoring_router

from src.api.routes.v1.chat import router as chat_router
from src.api.routes.v1.chat_ws import router as chat_ws_router
from src.api.routes.v1.meal_plans import router as meal_plans_router
from src.api.routes.v1.meal_suggestions import router as meal_suggestions_router
from src.api.routes.v1.meals import router as meals_router
from src.api.routes.v1.notifications import router as notifications_router
from src.api.routes.v1.user_profiles import router as user_profiles_router
from src.api.routes.v1.users import router as users_router
from src.api.routes.v1.webhooks import router as webhooks_router
from src.api.routes.v1.health import router as health_router
from src.api.routes.v1.ingredients import router as ingredients_router
from src.infra.database.config import engine
from src.infra.database.migration_manager import MigrationManager

load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


def initialize_firebase():
    """
    Initialize Firebase Admin SDK.

    Supports three methods (in priority order):
    1. Service account JSON file path via FIREBASE_CREDENTIALS (recommended for local development)
    2. Service account JSON string via FIREBASE_SERVICE_ACCOUNT_JSON (recommended for production)
    3. Default credentials (fallback for cloud environments)

    Environment Variables:
    - FIREBASE_CREDENTIALS: Path to service account JSON file
    - FIREBASE_SERVICE_ACCOUNT_JSON: Service account JSON as string
    """
    try:
        # Check if already initialized
        firebase_admin.get_app()
        logger.info("Firebase already initialized")
        return
    except ValueError:
        # Not initialized yet, proceed with initialization
        pass

    try:
        environment = os.getenv("ENVIRONMENT", "development")
        
        # Option 1: Check for service account file path
        credentials_path = os.getenv("FIREBASE_CREDENTIALS")
        if credentials_path and os.path.exists(credentials_path):
            cred = credentials.Certificate(credentials_path)
            firebase_admin.initialize_app(cred)
            logger.info("Firebase initialized with service account file (environment: %s)", environment)
            return

        # Option 2: Check for service account JSON string
        service_account_json = os.getenv("FIREBASE_SERVICE_ACCOUNT_JSON")
        if service_account_json:
            try:
                service_account_dict = json.loads(service_account_json)
                cred = credentials.Certificate(service_account_dict)
                firebase_admin.initialize_app(cred)
                logger.info("Firebase initialized with service account JSON string (environment: %s)", environment)
                return
            except json.JSONDecodeError as e:
                logger.error("Invalid JSON in FIREBASE_SERVICE_ACCOUNT_JSON: %s", e)
                raise ValueError("FIREBASE_SERVICE_ACCOUNT_JSON contains invalid JSON") from e

        # Option 3: Fall back to default credentials
        firebase_admin.initialize_app()
        logger.info("Firebase initialized with default credentials (environment: %s)", environment)

    except Exception as e:
        logger.error("Failed to initialize Firebase: %s", e)
        raise


@asynccontextmanager
async def lifespan(app: FastAPI):
    """Handle application startup and shutdown events."""
    # Startup
    logger.info("Starting MealTrack API...")

    # Initialize Firebase Admin SDK
    try:
        initialize_firebase()
    except Exception as e:
        logger.error("Failed to initialize Firebase: %s", e)
        raise

    # Run database migrations
    try:
        migration_manager = MigrationManager.from_environment(engine)
        success = migration_manager.initialize_and_migrate()

        if not success:
            logger.error("Database migrations failed!")
            # Optionally, you can decide to exit here or continue in degraded mode
            # For now, we'll log the error and continue
            if os.getenv("FAIL_ON_MIGRATION_ERROR", "false").lower() == "true":
                logger.error(
                    "Exiting due to migration failure (FAIL_ON_MIGRATION_ERROR=true)"
                )
                raise RuntimeError("Database migration failed")
    except Exception as e:
        logger.error("Failed to run migrations: %s", e)
        if os.getenv("FAIL_ON_MIGRATION_ERROR", "false").lower() == "true":
            raise

    # Initialize and start scheduled notification service
    scheduled_service = None
    try:
        logger.info("Initializing scheduled notification service...")
        scheduled_service = initialize_scheduled_notification_service()
        await scheduled_service.start()
        logger.info("Scheduled notification service started successfully!")
    except Exception as e:
        logger.error(f"Failed to start scheduled notification service: {e}")
        # Continue running the API even if notification service fails

    # Initialize Redis cache
    try:
        await initialize_cache_layer()
    except Exception as exc:
        logger.error("Failed to initialize cache layer: %s", exc)
        if os.getenv("FAIL_ON_CACHE_ERROR", "false").lower() == "true":
            raise

    logger.info("MealTrack API started successfully!")
    yield

    # Shutdown
    logger.info("Shutting down MealTrack API...")
    
    # Stop scheduled notification service
    if scheduled_service:
        try:
            logger.info("Stopping scheduled notification service...")
            await scheduled_service.stop()
            logger.info("Scheduled notification service stopped successfully!")
        except Exception as e:
            logger.error(f"Error stopping scheduled notification service: {e}")

    # Disconnect cache
    await shutdown_cache_layer()


app = FastAPI(
    title="MealTrack API",
    description="API for meal tracking, nutritional analysis with AI vision capabilities, and smart meal planning",
    version="0.2.0",
    lifespan=lifespan,
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Dev auth bypass: inject a fixed user during development
add_dev_auth_bypass(app)

# Include all routers
app.include_router(health_router)
app.include_router(chat_router)
app.include_router(chat_ws_router)  # WebSocket router
app.include_router(meals_router)
app.include_router(activities_router)
app.include_router(feature_flags_router)
app.include_router(meal_plans_router)
app.include_router(meal_suggestions_router)
# app.include_router(daily_meals_router)
app.include_router(user_profiles_router)
app.include_router(users_router)
app.include_router(foods_router)
app.include_router(monitoring_router)
app.include_router(webhooks_router)
app.include_router(notifications_router)
app.include_router(ingredients_router)

# Serve static files from uploads directory (development)
if os.environ.get("ENVIRONMENT") == "development":
    uploads_path = os.getenv(
        "UPLOADS_DIR", "./uploads"
    )  # Default to './uploads' if UPLOADS_DIR is not set
    if os.path.exists(uploads_path):
        app.mount("/uploads", StaticFiles(directory=uploads_path), name="uploads")

if __name__ == "__main__":
    import uvicorn

    uvicorn.run("api.main:app", host="0.0.0.0", port=8000, reload=True)
</file>

<file path="src/api/dependencies/event_bus.py">
"""
Event bus dependency for FastAPI with proper type registrations.
"""
from typing import Optional

from fastapi import Depends
from sqlalchemy.orm import Session

from src.api.base_dependencies import (
    get_ai_chat_service,
    get_db,
    get_image_store,
    get_meal_repository,
    get_notification_repository,
    get_vision_service,
    get_gpt_parser,
    get_food_data_service,
    get_food_cache_service,
    get_food_mapping_service,
    get_cache_service,
    get_suggestion_orchestration_service,
)
from src.app.commands.daily_meal import (
    GenerateDailyMealSuggestionsCommand,
    GenerateSingleMealCommand,
)
# Import all commands
from src.app.commands.meal import (
    UploadMealImageImmediatelyCommand,
    EditMealCommand,
    AddCustomIngredientCommand,
    DeleteMealCommand,
)
from src.app.commands.meal.create_manual_meal_command import CreateManualMealCommand
from src.app.commands.meal_plan import (
    GenerateWeeklyIngredientBasedMealPlanCommand,
)
from src.app.commands.meal_suggestion import (
    GenerateMealSuggestionsCommand,
    SaveMealSuggestionCommand,
    RegenerateSuggestionsCommand,
    AcceptSuggestionCommand,
    RejectSuggestionCommand,
    DiscardSessionCommand,
)
from src.app.queries.meal_suggestion import GetSessionSuggestionsQuery
from src.app.commands.notification import (
    RegisterFcmTokenCommand,
    DeleteFcmTokenCommand,
    UpdateNotificationPreferencesCommand,
)
from src.app.commands.user import (
    SaveUserOnboardingCommand,
    CompleteOnboardingCommand,
    DeleteUserCommand,
)
from src.app.commands.user.sync_user_command import (
    SyncUserCommand,
    UpdateUserLastAccessedCommand,
)
from src.app.commands.user.update_user_metrics_command import UpdateUserMetricsCommand
from src.app.events.meal import MealImageUploadedEvent
# Import all command handlers from module
from src.app.handlers.command_handlers import (
    EditMealCommandHandler,
    AddCustomIngredientCommandHandler,
    DeleteMealCommandHandler,
    SaveUserOnboardingCommandHandler,
    SyncUserCommandHandler,
    UpdateUserLastAccessedCommandHandler,
    CompleteOnboardingCommandHandler,
    DeleteUserCommandHandler,
    GenerateDailyMealSuggestionsCommandHandler,
    GenerateSingleMealCommandHandler,
    CreateManualMealCommandHandler,
    UpdateUserMetricsCommandHandler,
    UploadMealImageImmediatelyHandler,
    GenerateWeeklyIngredientBasedMealPlanCommandHandler,
    GenerateMealSuggestionsCommandHandler,
    SaveMealSuggestionCommandHandler,
    RegenerateSuggestionsHandler,
    GetSessionSuggestionsHandler,
    AcceptSuggestionHandler,
    RejectSuggestionHandler,
    DiscardSessionHandler,
)
from src.app.handlers.command_handlers import (
    RegisterFcmTokenCommandHandler,
    DeleteFcmTokenCommandHandler,
    UpdateNotificationPreferencesCommandHandler,
)
# Ingredient handlers
from src.app.handlers.command_handlers import (
    RecognizeIngredientCommandHandler,
)
from src.app.commands.ingredient import RecognizeIngredientCommand
# Import event handlers
from src.app.handlers.event_handlers.meal_analysis_event_handler import (
    MealAnalysisEventHandler,
)
# Import all query handlers from module
from src.app.handlers.query_handlers import (
    GetUserTdeeQueryHandler,
    SearchFoodsQueryHandler,
    GetFoodDetailsQueryHandler,
    GetMealByIdQueryHandler,
    GetDailyMacrosQueryHandler,
    GetUserProfileQueryHandler,
    GetUserByFirebaseUidQueryHandler,
    GetUserOnboardingStatusQueryHandler,
    GetDailyActivitiesQueryHandler,
    GetMealPlanQueryHandler,
    GetMealsFromPlanByDateQueryHandler,
    GetMealsByDateQueryHandler,
    GetMealSuggestionsForProfileQueryHandler,
    GetSingleMealForProfileQueryHandler,
    GetMealPlanningSummaryQueryHandler,
    GetUserMetricsQueryHandler,
)
from src.app.handlers.query_handlers import (
    GetNotificationPreferencesQueryHandler,
)
# Chat handlers
from src.app.handlers.command_handlers.chat import (
    CreateThreadCommandHandler,
    SendMessageCommandHandler,
    DeleteThreadCommandHandler,
)
from src.app.handlers.query_handlers.chat import (
    GetThreadsQueryHandler,
    GetThreadQueryHandler,
    GetMessagesQueryHandler,
)
from src.app.commands.chat import (
    CreateThreadCommand,
    SendMessageCommand,
    DeleteThreadCommand,
)
from src.app.queries.chat import (
    GetThreadsQuery,
    GetThreadQuery,
    GetMessagesQuery,
)
from src.app.queries.activity import GetDailyActivitiesQuery
from src.app.queries.daily_meal import (
    GetMealSuggestionsForProfileQuery,
    GetSingleMealForProfileQuery,
    GetMealPlanningSummaryQuery,
)
from src.app.queries.food.get_food_details_query import GetFoodDetailsQuery
from src.app.queries.food.search_foods_query import SearchFoodsQuery
# Import all queries
from src.app.queries.meal import (
    GetMealByIdQuery,
    GetDailyMacrosQuery,
)
from src.app.queries.meal_plan import (
    GetMealsFromPlanByDateQuery,
    GetMealPlanQuery,
    GetMealsByDateQuery,
)
from src.app.queries.notification import GetNotificationPreferencesQuery
from src.app.queries.tdee import GetUserTdeeQuery
from src.app.queries.user import GetUserProfileQuery, GetUserMetricsQuery
from src.app.queries.user.get_user_by_firebase_uid_query import GetUserByFirebaseUidQuery
from src.app.queries.user.get_user_onboarding_status_query import GetUserOnboardingStatusQuery
from src.domain.ports.ai_chat_service_port import AIChatServicePort
from src.domain.ports.food_cache_service_port import FoodCacheServicePort
from src.domain.ports.food_data_service_port import FoodDataServicePort
from src.domain.ports.food_mapping_service_port import FoodMappingServicePort
from src.infra.cache.cache_service import CacheService
from src.infra.event_bus import PyMediatorEventBus, EventBus

# Singleton lightweight event bus for food search (no heavy dependencies)
_food_search_event_bus: Optional[EventBus] = None


def get_food_search_event_bus() -> EventBus:
    """
    Get a lightweight event bus for food search operations (singleton).

    This event bus only registers food-related handlers and does NOT
    initialize heavy services like Cloudinary, Gemini, etc.

    Returns:
        EventBus: Lightweight event bus for food search
    """
    global _food_search_event_bus
    if _food_search_event_bus is not None:
        return _food_search_event_bus

    from src.api.base_dependencies import (
        get_food_data_service,
        get_food_cache_service,
        get_food_mapping_service,
    )

    event_bus = PyMediatorEventBus()

    # Only register food-related handlers (lightweight)
    food_data_service = get_food_data_service()
    food_cache_service = get_food_cache_service()
    food_mapping_service = get_food_mapping_service()

    event_bus.register_handler(
        SearchFoodsQuery,
        SearchFoodsQueryHandler(
            food_data_service, food_cache_service, food_mapping_service
        ),
    )
    event_bus.register_handler(
        GetFoodDetailsQuery,
        GetFoodDetailsQueryHandler(
            food_data_service, food_cache_service, food_mapping_service
        ),
    )

    _food_search_event_bus = event_bus
    return _food_search_event_bus


async def get_configured_event_bus(
    db: Session = Depends(get_db),
    image_store = Depends(get_image_store),
    meal_repository = Depends(get_meal_repository),
    notification_repository = Depends(get_notification_repository),
    vision_service = Depends(get_vision_service),
    gpt_parser = Depends(get_gpt_parser),
    food_data_service: FoodDataServicePort = Depends(get_food_data_service),
    food_cache_service: FoodCacheServicePort = Depends(get_food_cache_service),
    food_mapping_service: FoodMappingServicePort = Depends(get_food_mapping_service),
    cache_service: Optional[CacheService] = Depends(get_cache_service),
    ai_chat_service: AIChatServicePort = Depends(get_ai_chat_service),
    suggestion_service = Depends(get_suggestion_orchestration_service),
) -> EventBus:
    """
    Get an event bus with all handlers configured.
    """
    event_bus = PyMediatorEventBus()

    # Register meal command handlers
    event_bus.register_handler(
        UploadMealImageImmediatelyCommand,
        UploadMealImageImmediatelyHandler(
            image_store=image_store,
            meal_repository=meal_repository,
            vision_service=vision_service,
            gpt_parser=gpt_parser,
            cache_service=cache_service,
        ),
    )

    # Register meal edit command handlers
    event_bus.register_handler(
        EditMealCommand,
        EditMealCommandHandler(
            meal_repository=meal_repository,
            food_service=food_data_service,
            nutrition_calculator=None,  # TODO: Add nutrition calculator if needed
            cache_service=cache_service,
        ),
    )

    event_bus.register_handler(
        AddCustomIngredientCommand,
        AddCustomIngredientCommandHandler(
            meal_repository=meal_repository,
            cache_service=cache_service,
        ),
    )

    event_bus.register_handler(
        DeleteMealCommand,
        DeleteMealCommandHandler(
            meal_repository=meal_repository,
            cache_service=cache_service,
        ),
    )

    # Register manual meal creation command handler
    event_bus.register_handler(
        CreateManualMealCommand,
        CreateManualMealCommandHandler(
            meal_repository=meal_repository,
            food_data_service=food_data_service,
            mapping_service=food_mapping_service,
            cache_service=cache_service,
        ),
    )

    # Register food database query handlers
    event_bus.register_handler(
        SearchFoodsQuery,
        SearchFoodsQueryHandler(
            food_data_service, food_cache_service, food_mapping_service
        ),
    )
    event_bus.register_handler(
        GetFoodDetailsQuery,
        GetFoodDetailsQueryHandler(
            food_data_service, food_cache_service, food_mapping_service
        ),
    )

    # Register meal query handlers
    event_bus.register_handler(
        GetMealByIdQuery, GetMealByIdQueryHandler(meal_repository)
    )
    event_bus.register_handler(
        GetDailyMacrosQuery,
        GetDailyMacrosQueryHandler(
            meal_repository,
            db,
            cache_service=cache_service,
        ),
    )

    # Register activity query handlers
    event_bus.register_handler(
        GetDailyActivitiesQuery, GetDailyActivitiesQueryHandler(meal_repository)
    )

    # Register daily meal handlers
    event_bus.register_handler(
        GenerateDailyMealSuggestionsCommand,
        GenerateDailyMealSuggestionsCommandHandler(),
    )
    event_bus.register_handler(
        GenerateSingleMealCommand, GenerateSingleMealCommandHandler()
    )
    event_bus.register_handler(
        GetMealSuggestionsForProfileQuery,
        GetMealSuggestionsForProfileQueryHandler(db),
    )
    event_bus.register_handler(
        GetSingleMealForProfileQuery, GetSingleMealForProfileQueryHandler(db)
    )
    event_bus.register_handler(
        GetMealPlanningSummaryQuery, GetMealPlanningSummaryQueryHandler(db)
    )

    # Register meal plan handlers
    event_bus.register_handler(
        GenerateWeeklyIngredientBasedMealPlanCommand,
        GenerateWeeklyIngredientBasedMealPlanCommandHandler(db),
    )
    event_bus.register_handler(GetMealPlanQuery, GetMealPlanQueryHandler())
    event_bus.register_handler(
        GetMealsFromPlanByDateQuery, GetMealsFromPlanByDateQueryHandler(db)
    )
    event_bus.register_handler(
        GetMealsByDateQuery, GetMealsByDateQueryHandler(meal_repository)
    )
    
    # Register meal suggestion handlers
    event_bus.register_handler(
        GenerateMealSuggestionsCommand,
        GenerateMealSuggestionsCommandHandler(suggestion_service),
    )
    event_bus.register_handler(
        SaveMealSuggestionCommand,
        SaveMealSuggestionCommandHandler(db=db),
    )
    event_bus.register_handler(
        RegenerateSuggestionsCommand,
        RegenerateSuggestionsHandler(suggestion_service),
    )
    event_bus.register_handler(
        GetSessionSuggestionsQuery,
        GetSessionSuggestionsHandler(suggestion_service),
    )
    event_bus.register_handler(
        AcceptSuggestionCommand,
        AcceptSuggestionHandler(suggestion_service),
    )
    event_bus.register_handler(
        RejectSuggestionCommand,
        RejectSuggestionHandler(suggestion_service),
    )
    event_bus.register_handler(
        DiscardSessionCommand,
        DiscardSessionHandler(suggestion_service),
    )

    # Register user handlers
    event_bus.register_handler(
        SaveUserOnboardingCommand,
        SaveUserOnboardingCommandHandler(db, cache_service=cache_service),
    )
    event_bus.register_handler(SyncUserCommand, SyncUserCommandHandler(db))
    event_bus.register_handler(
        UpdateUserLastAccessedCommand, UpdateUserLastAccessedCommandHandler(db)
    )
    event_bus.register_handler(
        CompleteOnboardingCommand,
        CompleteOnboardingCommandHandler(db, cache_service=cache_service),
    )
    event_bus.register_handler(
        DeleteUserCommand, DeleteUserCommandHandler(db)
    )
    event_bus.register_handler(
        UpdateUserMetricsCommand,
        UpdateUserMetricsCommandHandler(db, cache_service=cache_service),
    )
    event_bus.register_handler(
        GetUserProfileQuery,
        GetUserProfileQueryHandler(db),
    )
    event_bus.register_handler(
        GetUserByFirebaseUidQuery, GetUserByFirebaseUidQueryHandler(db)
    )
    event_bus.register_handler(
        GetUserOnboardingStatusQuery, GetUserOnboardingStatusQueryHandler(db)
    )
    event_bus.register_handler(
        GetUserMetricsQuery, GetUserMetricsQueryHandler(db)
    )
    event_bus.register_handler(GetUserTdeeQuery, GetUserTdeeQueryHandler(db))

    # Register notification handlers
    event_bus.register_handler(
        RegisterFcmTokenCommand,
        RegisterFcmTokenCommandHandler(notification_repository, db)
    )
    event_bus.register_handler(
        DeleteFcmTokenCommand,
        DeleteFcmTokenCommandHandler(notification_repository)
    )
    event_bus.register_handler(
        UpdateNotificationPreferencesCommand,
        UpdateNotificationPreferencesCommandHandler(notification_repository)
    )
    event_bus.register_handler(
        GetNotificationPreferencesQuery,
        GetNotificationPreferencesQueryHandler(notification_repository)
    )

    # Register ingredient recognition handler
    event_bus.register_handler(
        RecognizeIngredientCommand,
        RecognizeIngredientCommandHandler(vision_service=vision_service)
    )

    # Register chat handlers
    from src.infra.repositories.chat_repository import ChatRepository
    
    chat_repository = ChatRepository(db)
    
    event_bus.register_handler(
        CreateThreadCommand,
        CreateThreadCommandHandler(chat_repository)
    )
    event_bus.register_handler(
        SendMessageCommand,
        SendMessageCommandHandler(chat_repository, ai_chat_service)
    )
    event_bus.register_handler(
        DeleteThreadCommand,
        DeleteThreadCommandHandler(chat_repository)
    )
    event_bus.register_handler(
        GetThreadsQuery,
        GetThreadsQueryHandler(chat_repository)
    )
    event_bus.register_handler(
        GetThreadQuery,
        GetThreadQueryHandler(chat_repository)
    )
    event_bus.register_handler(
        GetMessagesQuery,
        GetMessagesQueryHandler(chat_repository)
    )

    # Register domain event subscribers
    meal_analysis_handler = MealAnalysisEventHandler(
        meal_repository=meal_repository,
        vision_service=vision_service,
        gpt_parser=gpt_parser,
        image_store=image_store,
    )
    event_bus.subscribe(
        MealImageUploadedEvent, meal_analysis_handler
    )

    return event_bus
</file>

</files>
